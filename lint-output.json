[{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\agent-registry.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\analytics\\backfill-dedup.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\analytics\\backfill-engine.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\analytics\\output-estimator.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\analytics\\token-extractor.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\analytics\\token-tracker.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\analytics\\tokscale-adapter.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\analytics\\transcript-parser.test.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'entry' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":188,"column":26,"nodeType":"Identifier","messageId":"unusedVar","endLine":188,"endColumn":31,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\analytics\\transcript-scanner.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\analytics\\transcript-token-extractor.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\auto-update.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\auto-upgrade-prompt.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\bash-history.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\cli-config-stop-callback.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\cli-notify-profile.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\codex-backoff.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\compatibility-security.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\compatibility.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\consensus-execution-handoff.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\delegation-enforcement-levels.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\delegation-enforcer-integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\delegation-enforcer.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\directory-context-injector.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\disable-tools.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\doctor-conflicts.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\example.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\helpers\\prompt-test-helpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\hooks.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\hooks\\learner\\bridge.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\hooks\\learner\\parser.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\hud-agents.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\hud-axiom.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\hud-suggestions.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\hud-windows.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\hud\\analytics-display.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\hud\\call-counts.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\hud\\context-warning.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\hud\\cwd.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\hud\\defaults.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\hud\\git.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\hud\\model.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\hud\\render.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\hud\\sanitize.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\hud\\skills.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\hud\\state.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\hud\\thinking.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\hud\\top-agents.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\hud\\usage-api.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\hud\\version-display.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\hud\\windows-platform.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\inline-prompt-integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\inline-success-shape.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\installer-hooks-merge.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\installer-hud-skip.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\installer.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\job-management-sqlite.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\job-management.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\job-state-db.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\learner\\auto-learner.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\learner\\matcher.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\live-data.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\load-agent-prompt.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\lsp-servers.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\mcp-fallback-429.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\mcp-server-workflows.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\mnemosyne\\config.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\mnemosyne\\detector.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\mnemosyne\\finder.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\mnemosyne\\loader.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\mnemosyne\\parser.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\mnemosyne\\validator.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\model-routing.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\multi-model-mcp-integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\multi-model-mcp.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\notepad.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\omc-tools-contract.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\omc-tools-server.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\permission-enforcement.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\prompt-file-only.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\prompt-injection.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\providers\\azure-devops.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\providers\\bitbucket.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\providers\\detection.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\providers\\gitea.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\providers\\github.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\providers\\gitlab.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\ralph-prd.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\ralph-progress.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\rate-limit-wait\\daemon.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\rate-limit-wait\\integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\rate-limit-wait\\rate-limit-monitor.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\rate-limit-wait\\tmux-detector.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\session-catalog.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\session-migration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\skills.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\standalone-server.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\task-continuation.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\tools\\skills-tools.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\tools\\trace-tools.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\types.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\validate-and-read-file.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\__tests__\\version-helper.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\agents\\analyst.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\agents\\architect.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\agents\\coordinator-deprecated.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\agents\\critic.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\agents\\deep-executor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\agents\\definitions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\agents\\delegation-validator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\agents\\designer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\agents\\document-specialist.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\agents\\executor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\agents\\explore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\agents\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\agents\\planner.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\agents\\preamble.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\agents\\prompt-generator.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":191,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":191,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5080,5083],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5080,5083],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":200,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":200,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5326,5329],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5326,5329],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Dynamic Prompt Generator for Oh-My-Claude-Sisyphus\n *\n * Generates orchestrator prompts dynamically from agent metadata.\n * Adding a new agent to definitions.ts automatically includes it in the generated prompt.\n */\n\nimport type { AgentConfig } from './types.js';\nimport {\n  buildHeader,\n  buildAgentRegistry,\n  buildTriggerTable,\n  buildToolSelectionSection,\n  buildDelegationMatrix,\n  buildOrchestrationPrinciples,\n  buildWorkflow,\n  buildCriticalRules,\n  buildCompletionChecklist\n} from './prompt-sections/index.js';\n\n/**\n * Options for controlling what sections are included in generated prompt\n */\nexport interface GeneratorOptions {\n  /** Include agent registry section (default: true) */\n  includeAgents?: boolean;\n  /** Include trigger table section (default: true) */\n  includeTriggers?: boolean;\n  /** Include tool selection guidance (default: true) */\n  includeTools?: boolean;\n  /** Include delegation matrix (default: true) */\n  includeDelegationTable?: boolean;\n  /** Include orchestration principles (default: true) */\n  includePrinciples?: boolean;\n  /** Include workflow section (default: true) */\n  includeWorkflow?: boolean;\n  /** Include critical rules (default: true) */\n  includeRules?: boolean;\n  /** Include completion checklist (default: true) */\n  includeChecklist?: boolean;\n}\n\n/**\n * Default generator options (all sections enabled)\n */\nconst DEFAULT_OPTIONS: Required<GeneratorOptions> = {\n  includeAgents: true,\n  includeTriggers: true,\n  includeTools: true,\n  includeDelegationTable: true,\n  includePrinciples: true,\n  includeWorkflow: true,\n  includeRules: true,\n  includeChecklist: true\n};\n\n/**\n * Generate complete orchestrator prompt from agent definitions\n *\n * @param agents - Array of agent configurations\n * @param options - Options controlling which sections to include\n * @returns Generated orchestrator prompt string\n *\n * @example\n * ```typescript\n * import { getAgentDefinitions } from './definitions.js';\n * import { generateOrchestratorPrompt } from './prompt-generator.js';\n *\n * const agents = Object.values(getAgentDefinitions()).map(def => ({\n *   name: def.name,\n *   description: def.description,\n *   prompt: def.prompt,\n *   tools: def.tools,\n *   model: def.model,\n *   metadata: def.metadata\n * }));\n *\n * const prompt = generateOrchestratorPrompt(agents);\n * console.log(prompt);\n * ```\n */\nexport function generateOrchestratorPrompt(\n  agents: AgentConfig[],\n  options?: GeneratorOptions\n): string {\n  const opts = { ...DEFAULT_OPTIONS, ...options };\n  const sections: string[] = [];\n\n  // Always include header\n  sections.push(buildHeader());\n  sections.push('');\n\n  // Agent registry\n  if (opts.includeAgents) {\n    sections.push(buildAgentRegistry(agents));\n  }\n\n  // Orchestration principles\n  if (opts.includePrinciples) {\n    sections.push(buildOrchestrationPrinciples());\n    sections.push('');\n  }\n\n  // Trigger table\n  if (opts.includeTriggers) {\n    const triggerSection = buildTriggerTable(agents);\n    if (triggerSection) {\n      sections.push(triggerSection);\n    }\n  }\n\n  // Tool selection guidance\n  if (opts.includeTools) {\n    sections.push(buildToolSelectionSection(agents));\n  }\n\n  // Delegation matrix\n  if (opts.includeDelegationTable) {\n    sections.push(buildDelegationMatrix(agents));\n  }\n\n  // Workflow\n  if (opts.includeWorkflow) {\n    sections.push(buildWorkflow());\n    sections.push('');\n  }\n\n  // Critical rules\n  if (opts.includeRules) {\n    sections.push(buildCriticalRules());\n    sections.push('');\n  }\n\n  // Completion checklist\n  if (opts.includeChecklist) {\n    sections.push(buildCompletionChecklist());\n  }\n\n  return sections.join('\\n');\n}\n\n/**\n * Build agent section only (for embedding in other prompts)\n */\nexport function buildAgentSection(agents: AgentConfig[]): string {\n  return buildAgentRegistry(agents);\n}\n\n/**\n * Build triggers section only\n */\nexport function buildTriggersSection(agents: AgentConfig[]): string {\n  return buildTriggerTable(agents);\n}\n\n/**\n * Build tool selection section only (alias for buildToolSelectionSection from prompt-sections)\n */\nexport { buildToolSelectionSection };\n\n/**\n * Build delegation table section only\n */\nexport function buildDelegationTableSection(agents: AgentConfig[]): string {\n  return buildDelegationMatrix(agents);\n}\n\n/**\n * Convert agent definitions record to array of AgentConfig for generation\n *\n * @param definitions - Record of agent definitions from getAgentDefinitions()\n * @returns Array of AgentConfig suitable for prompt generation\n *\n * @example\n * ```typescript\n * import { getAgentDefinitions } from './definitions.js';\n * import { convertDefinitionsToConfigs, generateOrchestratorPrompt } from './prompt-generator.js';\n *\n * const definitions = getAgentDefinitions();\n * const agents = convertDefinitionsToConfigs(definitions);\n * const prompt = generateOrchestratorPrompt(agents);\n * ```\n */\nexport function convertDefinitionsToConfigs(\n  definitions: Record<string, {\n    description: string;\n    prompt: string;\n    tools?: string[];\n    disallowedTools?: string[];\n    model?: string;\n    metadata?: any;\n  }>\n): AgentConfig[] {\n  return Object.entries(definitions).map(([name, def]) => ({\n    name,\n    description: def.description,\n    prompt: def.prompt,\n    tools: def.tools,\n    disallowedTools: def.disallowedTools,\n    model: def.model as any,\n    metadata: def.metadata\n  }));\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\agents\\prompt-sections\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\agents\\qa-tester.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\agents\\scientist.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\agents\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\agents\\utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\agents\\vision.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\agents\\writer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\analytics\\analytics-summary.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\analytics\\backfill-dedup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\analytics\\backfill-engine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\analytics\\cost-estimator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\analytics\\export.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\analytics\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\analytics\\metrics-collector.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":7,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":7,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[157,160],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[157,160],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":23,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":23,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[480,483],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[480,483],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":72,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":72,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1772,1775],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1772,1775],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":73,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":73,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1789,1792],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1789,1792],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as fs from 'fs/promises';\nimport * as path from 'path';\n\nexport interface MetricEvent {\n  timestamp: string;\n  type: string;\n  data: Record<string, any>;\n  sessionId?: string;\n}\n\nexport interface MetricQuery {\n  type?: string;\n  startDate?: string;\n  endDate?: string;\n  sessionId?: string;\n  limit?: number;\n  offset?: number;\n}\n\nconst METRICS_LOG_FILE = '.omc/logs/metrics.jsonl';\n\nexport class MetricsCollector {\n  async recordEvent(type: string, data: Record<string, any>, sessionId?: string): Promise<void> {\n    const event: MetricEvent = {\n      timestamp: new Date().toISOString(),\n      type,\n      data,\n      sessionId\n    };\n\n    await this.appendToLog(event);\n  }\n\n  async query(query: MetricQuery): Promise<MetricEvent[]> {\n    const logPath = path.resolve(process.cwd(), METRICS_LOG_FILE);\n\n    try {\n      const content = await fs.readFile(logPath, 'utf-8');\n      const lines = content.trim().split('\\n').filter(l => l.length > 0);\n\n      let events: MetricEvent[] = lines.map(line => JSON.parse(line));\n\n      // Apply filters\n      if (query.type) {\n        events = events.filter(e => e.type === query.type);\n      }\n\n      if (query.sessionId) {\n        events = events.filter(e => e.sessionId === query.sessionId);\n      }\n\n      if (query.startDate) {\n        events = events.filter(e => e.timestamp >= query.startDate!);\n      }\n\n      if (query.endDate) {\n        events = events.filter(e => e.timestamp <= query.endDate!);\n      }\n\n      // Apply pagination\n      const offset = query.offset || 0;\n      const limit = query.limit || events.length;\n\n      return events.slice(offset, offset + limit);\n    } catch (_error) {\n      return [];\n    }\n  }\n\n  async aggregate(\n    query: MetricQuery,\n    aggregator: (events: MetricEvent[]) => any\n  ): Promise<any> {\n    const events = await this.query(query);\n    return aggregator(events);\n  }\n\n  private async appendToLog(event: MetricEvent): Promise<void> {\n    const logPath = path.resolve(process.cwd(), METRICS_LOG_FILE);\n    const logDir = path.dirname(logPath);\n\n    await fs.mkdir(logDir, { recursive: true });\n    await fs.appendFile(logPath, JSON.stringify(event) + '\\n', 'utf-8');\n  }\n}\n\n// Common aggregators\nexport const aggregators = {\n  sum: (field: string) => (events: MetricEvent[]) => {\n    return events.reduce((sum, e) => sum + (e.data[field] || 0), 0);\n  },\n\n  avg: (field: string) => (events: MetricEvent[]) => {\n    if (events.length === 0) return 0;\n    const sum = aggregators.sum(field)(events);\n    return sum / events.length;\n  },\n\n  count: () => (events: MetricEvent[]) => {\n    return events.length;\n  },\n\n  groupBy: (field: string) => (events: MetricEvent[]) => {\n    const groups: Record<string, MetricEvent[]> = {};\n    for (const event of events) {\n      const key = event.data[field]?.toString() || 'unknown';\n      if (!groups[key]) groups[key] = [];\n      groups[key].push(event);\n    }\n    return groups;\n  },\n\n  max: (field: string) => (events: MetricEvent[]) => {\n    if (events.length === 0) return 0;\n    return Math.max(...events.map(e => e.data[field] || 0));\n  },\n\n  min: (field: string) => (events: MetricEvent[]) => {\n    if (events.length === 0) return 0;\n    return Math.min(...events.map(e => e.data[field] || 0));\n  }\n};\n\n// Singleton instance\nlet globalCollector: MetricsCollector | null = null;\n\nexport function getMetricsCollector(): MetricsCollector {\n  if (!globalCollector) {\n    globalCollector = new MetricsCollector();\n  }\n  return globalCollector;\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\analytics\\output-estimator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\analytics\\query-engine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\analytics\\session-catalog.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\analytics\\session-manager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\analytics\\session-types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\analytics\\token-extractor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\analytics\\token-tracker.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\analytics\\tokscale-adapter.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":84,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":84,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2385,2388],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2385,2388],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":87,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":87,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2493,2496],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2493,2496],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":106,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":106,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3314,3317],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3314,3317],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * TokScale Adapter Module\n *\n * Provides a centralized adapter for @tokscale/core with graceful fallback\n * when the native module is unavailable. This enables optional high-performance\n * token counting and pricing lookup while maintaining compatibility in all environments.\n */\n\nimport { ModelPricing, PRICING } from './types.js';\n\n/**\n * Interface for the tokscale adapter - wraps tokscale's native API\n */\nexport interface TokscaleAdapter {\n  /** Whether tokscale native module is available */\n  isAvailable: boolean;\n\n  /** Get unified report from tokscale - wraps parseLocalSources + finalizeReport */\n  getReport?: () => Promise<TokscaleReport>;\n\n  /** Look up pricing for a model from tokscale's database */\n  lookupPricing?: (modelName: string) => Promise<ModelPricing | null>;\n\n  /** Version of the tokscale native module */\n  version?: string;\n}\n\n/**\n * Unified report from tokscale\n */\nexport interface TokscaleReport {\n  totalInputTokens: number;\n  totalOutputTokens: number;\n  totalCacheCreationTokens: number;\n  totalCacheReadTokens: number;\n  totalCost: number;\n  totalEntries: number;\n  byModel: Record<string, { tokens: number; cost: number }>;\n}\n\n/**\n * Fallback adapter when tokscale is not available\n */\nconst FALLBACK_ADAPTER: TokscaleAdapter = {\n  isAvailable: false\n};\n\n/** Cached adapter instance */\nlet cachedAdapter: TokscaleAdapter | null = null;\n\n/** Whether we've already attempted to load tokscale */\nlet loadAttempted = false;\n\n/**\n * Lazily loads and caches the tokscale adapter\n *\n * @returns Promise resolving to the adapter (either native or fallback)\n */\nexport async function getTokscaleAdapter(): Promise<TokscaleAdapter> {\n  // Return cached adapter if available\n  if (cachedAdapter !== null) {\n    return cachedAdapter;\n  }\n\n  // Return fallback if we already tried and failed\n  if (loadAttempted) {\n    return FALLBACK_ADAPTER;\n  }\n\n  loadAttempted = true;\n\n  try {\n    // Suppress tokscale internal warnings during import/initialization\n    // These warnings come from tokscale's model provider parsing and spam the CLI output\n    const originalWarn = console.warn;\n    console.warn = (...args: unknown[]) => {\n      const msg = args[0];\n      if (typeof msg === 'string' && msg.startsWith('[tokscale]')) {\n        return; // Suppress tokscale internal warnings\n      }\n      originalWarn.apply(console, args);\n    };\n\n    let tokscale: any;\n    try {\n      // Dynamic import of @tokscale/core\n      tokscale = await import('@tokscale/core') as any;\n\n      // Verify native module is functional via health check\n      // Note: healthCheck returns a string \"tokscale-core is healthy!\" when working\n      if (typeof tokscale.healthCheck === 'function') {\n        const health = tokscale.healthCheck();\n        // String response means healthy, non-string or falsy means unhealthy\n        if (!health || (typeof health === 'object' && !health.nativeAvailable)) {\n          console.warn('[tokscale-adapter] Native module not available, using fallback');\n          cachedAdapter = FALLBACK_ADAPTER;\n          return cachedAdapter;\n        }\n      }\n    } finally {\n      // Always restore original console.warn\n      console.warn = originalWarn;\n    }\n\n    // Helper to convert tokscale's entries array to our byModel format\n    const convertEntriesToByModel = (entries: any[]): Record<string, { tokens: number; cost: number }> => {\n      const result: Record<string, { tokens: number; cost: number }> = {};\n      if (!entries || !Array.isArray(entries)) {\n        return result;\n      }\n\n      for (const entry of entries) {\n        const modelName = entry.model ?? 'unknown';\n        result[modelName] = {\n          tokens: (entry.input ?? 0) + (entry.output ?? 0),\n          cost: entry.cost ?? 0\n        };\n      }\n\n      return result;\n    };\n\n    // Build adapter with wrapped functions matching tokscale's actual API\n    cachedAdapter = {\n      isAvailable: true,\n      version: (typeof tokscale.version === 'function' ? tokscale.version() : tokscale.version) ?? 'unknown',\n\n      getReport: async () => {\n        try {\n          // Use getModelReport which is the high-level API that works\n          const report = await tokscale.getModelReport({ sources: ['claude'] });\n\n          // Convert tokscale ModelReport to our TokscaleReport\n          // Field mapping: totalInput -> totalInputTokens, totalOutput -> totalOutputTokens, etc.\n          return {\n            totalInputTokens: report.totalInput ?? 0,\n            totalOutputTokens: report.totalOutput ?? 0,\n            totalCacheCreationTokens: report.totalCacheWrite ?? 0,\n            totalCacheReadTokens: report.totalCacheRead ?? 0,\n            totalCost: report.totalCost ?? 0,\n            totalEntries: report.totalMessages ?? 0,\n            byModel: convertEntriesToByModel(report.entries ?? [])\n          };\n        } catch (error) {\n          console.warn('[tokscale-adapter] getReport failed:', error instanceof Error ? error.message : String(error));\n          throw error;\n        }\n      },\n\n      lookupPricing: async (modelName: string) => {\n        try {\n          const result = await tokscale.lookupPricing(modelName);\n          if (result && result.pricing) {\n            const pricing = result.pricing;\n            // Convert per-token costs to per-million costs\n            const inputPerMillion = (pricing.inputCostPerToken ?? 0) * 1_000_000;\n            const outputPerMillion = (pricing.outputCostPerToken ?? 0) * 1_000_000;\n\n            // Calculate cache multipliers from absolute costs\n            // cacheWriteMarkup: ratio of cache creation cost to input cost\n            // cacheReadDiscount: 1 - (cache read cost / input cost)\n            const cacheWriteMarkup = pricing.inputCostPerToken > 0\n              ? (pricing.cacheCreationInputTokenCost ?? pricing.inputCostPerToken * 1.25) / pricing.inputCostPerToken - 1\n              : 0.25;\n            const cacheReadDiscount = pricing.inputCostPerToken > 0\n              ? 1 - (pricing.cacheReadInputTokenCost ?? pricing.inputCostPerToken * 0.1) / pricing.inputCostPerToken\n              : 0.9;\n\n            return {\n              inputPerMillion,\n              outputPerMillion,\n              cacheWriteMarkup,\n              cacheReadDiscount\n            };\n          }\n          return null;\n        } catch (error) {\n          console.warn('[tokscale-adapter] lookupPricing failed for', modelName, ':', error instanceof Error ? error.message : String(error));\n          return null;\n        }\n      }\n    } as TokscaleAdapter;\n\n    return cachedAdapter!;\n  } catch (error) {\n    // Expected when @tokscale/core is not installed\n    const message = error instanceof Error ? error.message : String(error);\n\n    // Only log if it's not a simple \"module not found\" error\n    if (!message.includes('Cannot find module') && !message.includes('MODULE_NOT_FOUND')) {\n      console.warn(`[tokscale-adapter] Failed to load: ${message}`);\n    }\n\n    cachedAdapter = FALLBACK_ADAPTER;\n    return cachedAdapter;\n  }\n}\n\n/**\n * Normalizes a model name to match our pricing keys\n *\n * @param modelName - Raw model name from transcript\n * @returns Normalized model key\n */\nfunction normalizeModelName(modelName: string): string {\n  const lower = modelName.toLowerCase();\n\n  if (lower.includes('haiku')) return 'claude-haiku-4';\n  if (lower.includes('sonnet')) return 'claude-sonnet-4.6';\n  if (lower.includes('opus')) return 'claude-opus-4.6';\n\n  // Check exact matches\n  if (PRICING[modelName]) return modelName;\n\n  // Default\n  return 'claude-sonnet-4.6';\n}\n\n/**\n * Gets fallback pricing from the static PRICING table\n *\n * @param modelName - Model name to look up\n * @returns ModelPricing with fallback to Sonnet if unknown\n */\nexport function getFallbackPricing(modelName: string): ModelPricing {\n  const normalized = normalizeModelName(modelName);\n  return PRICING[normalized] ?? PRICING['claude-sonnet-4.6'];\n}\n\n/**\n * Looks up pricing for a model, preferring tokscale's database with fallback\n *\n * This function provides the best available pricing:\n * 1. If tokscale is available, uses its up-to-date pricing database\n * 2. Falls back to static PRICING table if tokscale unavailable or model not found\n *\n * @param modelName - Model name to look up pricing for\n * @returns Promise resolving to ModelPricing\n */\nexport async function lookupPricingWithFallback(modelName: string): Promise<ModelPricing> {\n  const adapter = await getTokscaleAdapter();\n\n  // Try tokscale lookup first if available\n  if (adapter.isAvailable && adapter.lookupPricing) {\n    try {\n      const pricing = await adapter.lookupPricing(modelName);\n      if (pricing !== null && pricing.inputPerMillion > 0 && pricing.outputPerMillion > 0) {\n        return pricing;\n      }\n    } catch {\n      // Silently fall through to fallback\n    }\n  }\n\n  // Use static fallback pricing\n  return getFallbackPricing(modelName);\n}\n\n/**\n * Checks if tokscale native module is currently available\n *\n * @returns Promise resolving to boolean indicating availability\n */\nexport async function isTokscaleAvailable(): Promise<boolean> {\n  const adapter = await getTokscaleAdapter();\n  return adapter.isAvailable;\n}\n\n/**\n * Resets the adapter cache (useful for testing)\n */\nexport function resetAdapterCache(): void {\n  cachedAdapter = null;\n  loadAttempted = false;\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\analytics\\transcript-parser.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\analytics\\transcript-scanner.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\analytics\\transcript-token-extractor.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":55,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":55,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1363,1366],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1363,1366],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":84,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":84,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2232,2235],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2232,2235],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":125,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":125,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3571,3574],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3571,3574],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createHash } from 'crypto';\nimport type { TokenUsage, TranscriptEntry } from './types.js';\n\n/**\n * Extracted usage with metadata\n */\nexport interface ExtractedUsage {\n  usage: TokenUsage;\n  entryId: string;\n  sourceFile: string;\n}\n\n/**\n * Task spawn info extracted from assistant entries\n */\nexport interface TaskSpawnInfo {\n  toolUseId: string;\n  agentType: string;\n}\n\n/**\n * Normalize model name to pricing tier\n */\nfunction normalizeModelName(model: string): string {\n  const lower = model.toLowerCase();\n\n  if (lower.includes('opus')) {\n    return 'claude-opus-4.6';\n  } else if (lower.includes('sonnet')) {\n    return 'claude-sonnet-4.6';\n  } else if (lower.includes('haiku')) {\n    return 'claude-haiku-4';\n  }\n\n  // Fallback to original if no match\n  return model;\n}\n\n/**\n * Extract Task tool spawn info from an assistant entry.\n * Returns all Task tool calls with their toolUseId and agentType.\n *\n * This is used to build a lookup table for attributing progress entries\n * to the correct agent.\n */\nexport function extractTaskSpawns(entry: TranscriptEntry): TaskSpawnInfo[] {\n  const spawns: TaskSpawnInfo[] = [];\n\n  if (entry.type !== 'assistant' || !entry.message?.content) {\n    return spawns;\n  }\n\n  for (const block of entry.message.content) {\n    if (block.type === 'tool_use' && block.name === 'Task') {\n      const toolUseId = (block as any).id;\n      const input = block.input as { subagent_type?: string } | undefined;\n      if (toolUseId && input?.subagent_type) {\n        spawns.push({\n          toolUseId,\n          agentType: input.subagent_type\n        });\n      }\n    }\n  }\n\n  return spawns;\n}\n\n/**\n * Detect agent name from transcript entry context\n *\n * For PROGRESS entries: Use the agentLookup to find the agent from parentToolUseID\n * For ASSISTANT entries: These are main session responses, return undefined\n *\n * NOTE: entry.slug is the SESSION slug (random words like \"validated-cooking-twilight\")\n * and should NOT be used as agent name.\n */\nfunction detectAgentName(\n  entry: TranscriptEntry,\n  agentLookup?: Map<string, string>\n): string | undefined {\n  // For progress entries, look up agent from parentToolUseID\n  if (entry.type === 'progress') {\n    const parentToolUseID = (entry as any).parentToolUseID;\n    if (parentToolUseID && agentLookup) {\n      return agentLookup.get(parentToolUseID);\n    }\n    // Fallback to agentId if it looks like an agent type\n    if (entry.agentId && entry.agentId.includes(':')) {\n      return entry.agentId;\n    }\n    return undefined;\n  }\n\n  // For assistant entries: these are main session responses\n  // Even if they contain Task tool calls, the usage is for the main session\n  // (the cost of generating the Task call), not the spawned agent's cost\n  return undefined;\n}\n\n/**\n * Generate unique entry ID for deduplication\n */\nfunction generateEntryId(sessionId: string, timestamp: string, model: string): string {\n  const hash = createHash('sha256');\n  hash.update(`${sessionId}:${timestamp}:${model}`);\n  return hash.digest('hex');\n}\n\n/**\n * Extract token usage from transcript entry\n *\n * @param entry - Transcript entry from JSONL file\n * @param sessionId - Session ID (override if not in entry)\n * @param sourceFile - Source file path for tracking\n * @param agentLookup - Map of toolUseId  agentType for attributing progress entries\n * @returns ExtractedUsage or null if entry has no usage data\n */\nexport function extractTokenUsage(\n  entry: TranscriptEntry,\n  sessionId: string,\n  sourceFile: string,\n  agentLookup?: Map<string, string>\n): ExtractedUsage | null {\n  let usage: any;\n  let model: string | undefined;\n\n  // Handle assistant entries\n  if (entry.type === 'assistant' && entry.message?.usage) {\n    usage = entry.message.usage;\n    model = entry.message.model;\n  }\n  // Handle progress entries from agent responses\n  else if (entry.type === 'progress' && entry.data?.message?.message?.usage) {\n    usage = entry.data.message.message.usage;\n    model = entry.data.message.message.model;\n  }\n  // No usage data found\n  else {\n    return null;\n  }\n\n  if (!model) {\n    return null;\n  }\n\n  // Skip synthetic model entries\n  if (model === '<synthetic>') {\n    return null;\n  }\n\n  // Use ACTUAL output_tokens from transcript (not estimates!)\n  const outputTokens = usage.output_tokens;\n  const inputTokens = usage.input_tokens || 0;\n\n  // Handle cache tokens\n  const cacheCreationTokens = usage.cache_creation_input_tokens || 0;\n  const cacheReadTokens = usage.cache_read_input_tokens || 0;\n\n  const tokenUsage: TokenUsage = {\n    timestamp: entry.timestamp,\n    sessionId: sessionId || entry.sessionId,\n    agentName: detectAgentName(entry, agentLookup),\n    modelName: normalizeModelName(model),\n    inputTokens,\n    outputTokens,\n    cacheCreationTokens,\n    cacheReadTokens\n  };\n\n  const entryId = generateEntryId(\n    tokenUsage.sessionId,\n    tokenUsage.timestamp,\n    tokenUsage.modelName\n  );\n\n  return {\n    usage: tokenUsage,\n    entryId,\n    sourceFile\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\analytics\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\cli\\analytics.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":76,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":76,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2468,2471],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2468,2471],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":76,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":76,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2483,2486],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2483,2486],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\n\nimport { program } from 'commander';\nimport chalk from 'chalk';\nimport { statsCommand } from './commands/stats.js';\nimport { costCommand } from './commands/cost.js';\nimport { sessionsCommand } from './commands/sessions.js';\nimport { agentsCommand } from './commands/agents.js';\nimport { exportCommand } from './commands/export.js';\nimport { cleanupCommand } from './commands/cleanup.js';\nimport {\n  launchTokscaleTUI,\n  isTokscaleCLIAvailable,\n  getInstallInstructions\n} from './utils/tokscale-launcher.js';\n\nprogram\n  .name('omc-analytics')\n  .description('OMC Analytics CLI - Token tracking, cost reports, and session management')\n  .version('1.0.0');\n\n// Stats command\nprogram\n  .command('stats')\n  .description('Show current session statistics')\n  .option('--json', 'Output as JSON')\n  .action(statsCommand);\n\n// Cost command\nprogram\n  .command('cost [period]')\n  .description('Generate cost report (period: daily, weekly, monthly)')\n  .option('--json', 'Output as JSON')\n  .action((period = 'monthly', options) => {\n    if (!['daily', 'weekly', 'monthly'].includes(period)) {\n      console.error('Invalid period. Use: daily, weekly, or monthly');\n      process.exit(1);\n    }\n    costCommand(period as 'daily' | 'weekly' | 'monthly', options);\n  });\n\n// Sessions command\nprogram\n  .command('sessions')\n  .description('View session history')\n  .option('--json', 'Output as JSON')\n  .option('--limit <number>', 'Limit number of sessions', '10')\n  .action(options => {\n    sessionsCommand({ ...options, limit: parseInt(options.limit) });\n  });\n\n// Agents command\nprogram\n  .command('agents')\n  .description('Show agent usage breakdown')\n  .option('--json', 'Output as JSON')\n  .option('--limit <number>', 'Limit number of agents', '10')\n  .action(options => {\n    agentsCommand({ ...options, limit: parseInt(options.limit) });\n  });\n\n// Export command\nprogram\n  .command('export <type> <format> <output>')\n  .description('Export data (type: cost, sessions, patterns; format: json, csv)')\n  .option('--period <period>', 'Period for cost report (daily, weekly, monthly)', 'monthly')\n  .action((type, format, output, options) => {\n    if (!['cost', 'sessions', 'patterns'].includes(type)) {\n      console.error('Invalid type. Use: cost, sessions, or patterns');\n      process.exit(1);\n    }\n    if (!['json', 'csv'].includes(format)) {\n      console.error('Invalid format. Use: json or csv');\n      process.exit(1);\n    }\n    exportCommand(type as any, format as any, output, options);\n  });\n\n// Cleanup command\nprogram\n  .command('cleanup')\n  .description('Clean up old logs and orphaned background tasks')\n  .option('--retention <days>', 'Retention period in days', '30')\n  .action(options => {\n    cleanupCommand({ ...options, retention: parseInt(options.retention) });\n  });\n\n// TUI command\nprogram\n  .command('tui')\n  .description('Launch tokscale interactive TUI for token visualization')\n  .option('--models', 'Show models view')\n  .option('--daily', 'Show daily/monthly view')\n  .option('--no-claude', 'Show all providers (not just Claude)')\n  .action(async (options) => {\n    const available = await isTokscaleCLIAvailable();\n\n    if (!available) {\n      console.log(chalk.yellow('tokscale is not installed.'));\n      console.log(getInstallInstructions());\n      process.exit(1);\n    }\n\n    const view = options.models ? 'models'\n               : options.daily ? 'daily'\n               : 'overview';\n\n    try {\n      await launchTokscaleTUI({\n        view,\n        claude: options.claude\n      });\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      console.error(chalk.red(`Failed to launch TUI: ${message}`));\n      process.exit(1);\n    }\n  });\n\nprogram.parse();\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\cli\\commands\\__tests__\\cleanup.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\cli\\commands\\agents.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\cli\\commands\\backfill.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\cli\\commands\\cleanup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\cli\\commands\\cost.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\cli\\commands\\doctor-conflicts.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\cli\\commands\\export.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\cli\\commands\\sessions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\cli\\commands\\stats.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\cli\\commands\\teleport.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\cli\\commands\\wait.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\cli\\index.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":331,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":331,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10946,10949],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10946,10949],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":331,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":331,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10961,10964],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10961,10964],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":685,"column":92,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":685,"endColumn":95,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23326,23329],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23326,23329],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":954,"column":90,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":954,"endColumn":93,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[33069,33072],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[33069,33072],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\n\n/**\n * Oh-My-Claude-Sisyphus CLI\n *\n * Command-line interface for the Sisyphus multi-agent system.\n *\n * Commands:\n * - run: Start an interactive session\n * - init: Initialize configuration in current directory\n * - config: Show or edit configuration\n * - setup: Sync all OMC components (hooks, agents, skills)\n */\n\nimport { Command } from 'commander';\nimport chalk from 'chalk';\nimport { _readFileSync, writeFileSync, mkdirSync, existsSync } from 'fs';\nimport * as fs from 'fs/promises';\nimport { join, dirname } from 'path';\nimport { fileURLToPath } from 'url';\nimport { homedir } from 'os';\nimport {\n  loadConfig,\n  getConfigPaths,\n  generateConfigSchema\n} from '../config/loader.js';\nimport { createSisyphusSession } from '../index.js';\nimport {\n  checkForUpdates,\n  performUpdate,\n  formatUpdateNotification,\n  getInstalledVersion,\n  getOMCConfig,\n  reconcileUpdateRuntime,\n  CONFIG_FILE,\n  type OMCConfig,\n} from '../features/auto-update.js';\nimport {\n  install as installSisyphus,\n  isInstalled,\n  getInstallInfo\n} from '../installer/index.js';\nimport { statsCommand } from './commands/stats.js';\nimport { costCommand } from './commands/cost.js';\nimport { sessionsCommand } from './commands/sessions.js';\nimport { agentsCommand } from './commands/agents.js';\nimport { exportCommand } from './commands/export.js';\nimport { cleanupCommand } from './commands/cleanup.js';\nimport { backfillCommand } from './commands/backfill.js';\nimport {\n  launchTokscaleTUI,\n  isTokscaleCLIAvailable,\n  getInstallInstructions\n} from './utils/tokscale-launcher.js';\nimport {\n  waitCommand,\n  waitStatusCommand,\n  waitDaemonCommand,\n  waitDetectCommand\n} from './commands/wait.js';\nimport { doctorConflictsCommand } from './commands/doctor-conflicts.js';\nimport {\n  teleportCommand,\n  teleportListCommand,\n  teleportRemoveCommand\n} from './commands/teleport.js';\n\nimport { getRuntimePackageVersion } from '../lib/version.js';\nimport { launchCommand } from './launch.js';\nimport { interopCommand } from './interop.js';\n\nconst ___dirname = dirname(fileURLToPath(import.meta.url));\n\nconst version = getRuntimePackageVersion();\n\nconst program = new Command();\n\n// Helper functions for auto-backfill\nasync function checkIfBackfillNeeded(): Promise<boolean> {\n  const tokenLogPath = join(homedir(), '.omc', 'state', 'token-tracking.jsonl');\n  try {\n    await fs.access(tokenLogPath);\n    const stats = await fs.stat(tokenLogPath);\n    // Backfill if file is older than 1 hour or very small\n    const ageMs = Date.now() - stats.mtimeMs;\n    return stats.size < 100 || ageMs > 3600000;\n  } catch {\n    return true; // File doesn't exist\n  }\n}\n\nasync function runQuickBackfill(silent: boolean = false): Promise<void> {\n  const { BackfillEngine } = await import('../analytics/backfill-engine.js');\n  const engine = new BackfillEngine();\n  const result = await engine.run({ verbose: false });\n  if (result.entriesAdded > 0 && !silent) {\n    console.log(chalk.green(`Backfilled ${result.entriesAdded} entries in ${result.timeElapsed}ms`));\n  }\n}\n\n// Auto-backfill before analytics commands\nasync function ensureBackfillDone(): Promise<void> {\n  const shouldBackfill = await checkIfBackfillNeeded();\n  if (shouldBackfill) {\n    await runQuickBackfill(true); // Silent backfill for subcommands\n  }\n}\n\n// Display enhanced banner using gradient-string (loaded dynamically)\nasync function displayAnalyticsBanner() {\n  try {\n    // @ts-expect-error - gradient-string will be installed during setup\n    const gradient = await import('gradient-string');\n    const banner = gradient.default.pastel.multiline([\n      '',\n      '   Oh-My-ClaudeCode - Analytics Dashboard   ',\n      ''\n    ].join('\\n'));\n    console.log(banner);\n    console.log('');\n  } catch (_error) {\n    // Fallback if gradient-string not installed\n    console.log('');\n    console.log('   Oh-My-ClaudeCode - Analytics Dashboard   ');\n    console.log('');\n    console.log('');\n  }\n}\n\n// Default action when running 'omc' with no args\n// Check env var to decide between dashboard and launch\nasync function defaultAction() {\n  const defaultActionMode = process.env.OMC_DEFAULT_ACTION || 'launch';\n\n  if (defaultActionMode === 'dashboard') {\n    await displayAnalyticsDashboard();\n  } else {\n    // Launch Claude Code by default\n    await launchCommand([]);\n  }\n}\n\n// Analytics dashboard - moved from defaultAction\nasync function displayAnalyticsDashboard() {\n  await displayAnalyticsBanner();\n\n  // Check if we need to backfill for agent data\n  const shouldAutoBackfill = await checkIfBackfillNeeded();\n  if (shouldAutoBackfill) {\n    console.log(chalk.yellow('First run detected - backfilling agent data...'));\n    await runQuickBackfill();\n  }\n\n  // Show aggregate session stats\n  console.log(chalk.bold(' Aggregate Session Statistics'));\n  console.log(chalk.gray(''.repeat(50)));\n  await statsCommand({ json: false });\n\n  console.log('\\n');\n\n  // Show cost breakdown\n  console.log(chalk.bold(' Cost Analysis (Monthly)'));\n  console.log(chalk.gray(''.repeat(50)));\n  await costCommand('monthly', { json: false });\n\n  console.log('\\n');\n\n  // Show top agents\n  console.log(chalk.bold(' Top Agents'));\n  console.log(chalk.gray(''.repeat(50)));\n  await agentsCommand({ json: false, limit: 10 });\n\n  console.log('\\n');\n  console.log(chalk.dim('Run with --help to see all available commands'));\n\n  // Show tokscale hint if available\n  const tuiAvailable = await isTokscaleCLIAvailable();\n\n  if (tuiAvailable) {\n    console.log('');\n    console.log(chalk.dim('Tip: Run `omc tui` for an interactive token visualization dashboard'));\n  }\n}\n\nprogram\n  .name('omc')\n  .description('Multi-agent orchestration system for Claude Agent SDK with analytics')\n  .version(version)\n  .action(defaultAction);\n\n/**\n * Launch command - Native tmux shell launch for Claude Code\n */\nprogram\n  .command('launch [args...]')\n  .description('Launch Claude Code with native tmux shell integration')\n  .allowUnknownOption()\n  .addHelpText('after', `\nExamples:\n  $ omc launch                   Launch Claude Code\n  $ omc launch --madmax          Launch with permissions bypass\n  $ omc launch --yolo            Launch with permissions bypass (alias)\n\nEnvironment:\n  Set OMC_DEFAULT_ACTION=dashboard to show analytics dashboard when running 'omc' with no args`)\n  .action(async (args: string[]) => {\n    await launchCommand(args);\n  });\n\n/**\n * Dashboard command - Show analytics dashboard\n */\nprogram\n  .command('dashboard')\n  .description('Show analytics dashboard (aggregate stats, costs, agents)')\n  .addHelpText('after', `\nNote: This was the default 'omc' behavior. Now 'omc' launches Claude Code by default.\nSet OMC_DEFAULT_ACTION=dashboard to restore the old behavior.`)\n  .action(async () => {\n    await displayAnalyticsDashboard();\n  });\n\n/**\n * Interop command - Split-pane tmux session with OMC and OMX\n */\nprogram\n  .command('interop')\n  .description('Launch split-pane tmux session with Claude Code (OMC) and Codex (OMX)')\n  .addHelpText('after', `\nRequirements:\n  - Must be running inside a tmux session\n  - Claude CLI must be installed\n  - Codex CLI recommended (graceful fallback if missing)`)\n  .action(() => {\n    interopCommand();\n  });\n\n/**\n * Analytics Commands\n */\n\n// Stats command\nprogram\n  .command('stats')\n  .description('Show aggregate statistics (or specific session with --session)')\n  .option('--json', 'Output as JSON')\n  .option('--session <id>', 'Show stats for specific session (defaults to aggregate)')\n  .addHelpText('after', `\nExamples:\n  $ omc stats                    Show aggregate statistics\n  $ omc stats --session abc123   Show stats for a specific session\n  $ omc stats --json             Output as JSON for scripting`)\n  .action(async (options) => {\n    await ensureBackfillDone();\n    await statsCommand(options);\n  });\n\n// Cost command\nprogram\n  .command('cost [period]')\n  .description('Generate cost report (period: daily, weekly, monthly)')\n  .option('--json', 'Output as JSON')\n  .addHelpText('after', `\nExamples:\n  $ omc cost                     Show monthly cost report\n  $ omc cost daily               Show daily cost breakdown\n  $ omc cost weekly --json       Export weekly costs as JSON`)\n  .action(async (period = 'monthly', options) => {\n    if (!['daily', 'weekly', 'monthly'].includes(period)) {\n      console.error(chalk.red(`Invalid period \"${period}\". Valid options: daily, weekly, monthly`));\n      console.error(chalk.gray('Example: omc cost weekly'));\n      process.exit(1);\n    }\n    await ensureBackfillDone();\n    await costCommand(period as 'daily' | 'weekly' | 'monthly', options);\n  });\n\n// Sessions command\nprogram\n  .command('sessions')\n  .description('View session history')\n  .option('--json', 'Output as JSON')\n  .option('-n, --limit <number>', 'Limit number of sessions', '10')\n  .addHelpText('after', `\nExamples:\n  $ omc sessions                 Show last 10 sessions\n  $ omc sessions --limit 50      Show last 50 sessions\n  $ omc sessions --json          Export session history as JSON`)\n  .action(async (options) => {\n    await ensureBackfillDone();\n    await sessionsCommand({ ...options, limit: parseInt(options.limit) });\n  });\n\n// Agents command\nprogram\n  .command('agents')\n  .description('Show agent usage breakdown')\n  .option('--json', 'Output as JSON')\n  .option('-n, --limit <number>', 'Limit number of agents', '10')\n  .addHelpText('after', `\nExamples:\n  $ omc agents                   Show top 10 agents by usage\n  $ omc agents --limit 20        Show top 20 agents\n  $ omc agents --json            Export agent data as JSON`)\n  .action(async (options) => {\n    await ensureBackfillDone();\n    await agentsCommand({ ...options, limit: parseInt(options.limit) });\n  });\n\n// Export command\nprogram\n  .command('export <type> <format> <output>')\n  .description('Export data (type: cost, sessions, patterns; format: json, csv)')\n  .option('--period <period>', 'Period for cost report (daily, weekly, monthly)', 'monthly')\n  .addHelpText('after', `\nExamples:\n  $ omc export cost json costs.json           Export monthly costs to JSON\n  $ omc export sessions csv sessions.csv      Export sessions to CSV\n  $ omc export cost csv data.csv --period weekly   Export weekly costs`)\n  .action((type, format, output, options) => {\n    if (!['cost', 'sessions', 'patterns'].includes(type)) {\n      console.error(chalk.red(`Invalid type \"${type}\". Valid options: cost, sessions, patterns`));\n      console.error(chalk.gray('Example: omc export cost json output.json'));\n      process.exit(1);\n    }\n    if (!['json', 'csv'].includes(format)) {\n      console.error(chalk.red(`Invalid format \"${format}\". Valid options: json, csv`));\n      console.error(chalk.gray('Example: omc export sessions csv sessions.csv'));\n      process.exit(1);\n    }\n    exportCommand(type as any, format as any, output, options);\n  });\n\n// Cleanup command\nprogram\n  .command('cleanup')\n  .description('Clean up old logs and orphaned background tasks')\n  .option('-r, --retention <days>', 'Retention period in days', '30')\n  .addHelpText('after', `\nExamples:\n  $ omc cleanup                  Clean up logs older than 30 days\n  $ omc cleanup --retention 7    Clean up logs older than 7 days`)\n  .action(options => {\n    cleanupCommand({ ...options, retention: parseInt(options.retention) });\n  });\n\n// Backfill command (deprecated - auto-backfill runs on every command)\nprogram\n  .command('backfill')\n  .description('[DEPRECATED] Backfill now runs automatically. Use for manual re-sync only.')\n  .option('--project <path>', 'Filter to specific project path')\n  .option('--from <date>', 'Start date (ISO format: YYYY-MM-DD)')\n  .option('--to <date>', 'End date (ISO format: YYYY-MM-DD)')\n  .option('--dry-run', 'Preview without writing data')\n  .option('--reset', 'Clear deduplication index and re-process all transcripts')\n  .option('-v, --verbose', 'Show detailed progress')\n  .option('--json', 'Output as JSON')\n  .addHelpText('after', `\nExamples:\n  $ omc backfill --reset                       Force full re-sync\n  $ omc backfill --project ~/myproject         Backfill specific project\n  $ omc backfill --from 2024-01-01 --verbose   Backfill from date with progress`)\n  .action(async (options) => {\n    if (!options.reset && !options.project && !options.from && !options.to) {\n      console.log(chalk.yellow('Note: Backfill now runs automatically with every omc command.'));\n      console.log(chalk.gray('Use --reset to force full re-sync, or --project/--from/--to for filtered backfill.\\n'));\n    }\n    await backfillCommand(options);\n  });\n\n// TUI command\nprogram\n  .command('tui')\n  .description('Launch tokscale interactive TUI for token visualization')\n  .option('--models', 'Show models view')\n  .option('--daily', 'Show daily/monthly view')\n  .option('--no-claude', 'Show all providers (not just Claude)')\n  .addHelpText('after', `\nExamples:\n  $ omc tui                      Launch interactive dashboard\n  $ omc tui --light              Use light theme\n  $ omc tui --daily              Start with daily view`)\n  .action(async (options) => {\n    const available = await isTokscaleCLIAvailable();\n\n    if (!available) {\n      console.log(chalk.yellow('tokscale is not installed.'));\n      console.log(getInstallInstructions());\n      process.exit(1);\n    }\n\n    const view = options.models ? 'models'\n               : options.daily ? 'daily'\n               : 'overview';\n\n    try {\n      await launchTokscaleTUI({\n        view,\n        claude: options.claude\n      });\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      console.error(chalk.red(`Failed to launch TUI: ${message}`));\n      console.error(chalk.gray('Try running \"omc tui\" again, or check if tokscale is properly installed.'));\n      process.exit(1);\n    }\n  });\n\n/**\n * Init command - Initialize configuration\n */\nprogram\n  .command('init')\n  .description('Initialize Sisyphus configuration in the current directory')\n  .option('-g, --global', 'Initialize global user configuration')\n  .option('-f, --force', 'Overwrite existing configuration')\n  .addHelpText('after', `\nExamples:\n  $ omc init                     Initialize in current directory\n  $ omc init --global            Initialize global configuration\n  $ omc init --force             Overwrite existing config`)\n  .action(async (options) => {\n    console.log(chalk.yellow('  DEPRECATED: The init command is deprecated.'));\n    console.log(chalk.gray('Configuration is now managed automatically. Use /ultrapower:omc-setup instead.\\n'));\n\n    const paths = getConfigPaths();\n    const targetPath = options.global ? paths.user : paths.project;\n    const targetDir = dirname(targetPath);\n\n    console.log(chalk.blue('Oh-My-ClaudeCode Configuration Setup\\n'));\n\n    // Check if config already exists\n    if (existsSync(targetPath) && !options.force) {\n      console.log(chalk.yellow(`Configuration already exists at ${targetPath}`));\n      console.log(chalk.gray('Use --force to overwrite'));\n      return;\n    }\n\n    // Create directory if needed\n    if (!existsSync(targetDir)) {\n      mkdirSync(targetDir, { recursive: true });\n      console.log(chalk.green(`Created directory: ${targetDir}`));\n    }\n\n    // Generate config content\n    const configContent = `// Oh-My-ClaudeCode Configuration\n// See: https://github.com/liangjie559567/ultrapower for documentation\n{\n  \"$schema\": \"./sisyphus-schema.json\",\n\n  // Agent model configurations\n  \"agents\": {\n    \"sisyphus\": {\n      // Main orchestrator - uses the most capable model\n      \"model\": \"claude-opus-4-6-20260205\"\n    },\n    \"architect\": {\n      // Architecture and debugging expert\n      \"model\": \"claude-opus-4-6-20260205\",\n      \"enabled\": true\n    },\n    \"researcher\": {\n      // Documentation and codebase analysis\n      \"model\": \"claude-sonnet-4-6-20260217\"\n    },\n    \"explore\": {\n      // Fast pattern matching - uses fastest model\n      \"model\": \"claude-3-5-haiku-20241022\"\n    },\n    \"frontendEngineer\": {\n      \"model\": \"claude-sonnet-4-6-20260217\",\n      \"enabled\": true\n    },\n    \"documentWriter\": {\n      \"model\": \"claude-3-5-haiku-20241022\",\n      \"enabled\": true\n    },\n    \"multimodalLooker\": {\n      \"model\": \"claude-sonnet-4-6-20260217\",\n      \"enabled\": true\n    }\n  },\n\n  // Feature toggles\n  \"features\": {\n    \"parallelExecution\": true,\n    \"lspTools\": true,\n    \"astTools\": true,\n    \"continuationEnforcement\": true,\n    \"autoContextInjection\": true\n  },\n\n  // MCP server integrations\n  \"mcpServers\": {\n    \"exa\": {\n      \"enabled\": true\n      // Set EXA_API_KEY environment variable for API key\n    },\n    \"context7\": {\n      \"enabled\": true\n    }\n  },\n\n  // Permission settings\n  \"permissions\": {\n    \"allowBash\": true,\n    \"allowEdit\": true,\n    \"allowWrite\": true,\n    \"maxBackgroundTasks\": 5\n  },\n\n  // Magic keyword triggers (customize if desired)\n  \"magicKeywords\": {\n    \"ultrawork\": [\"ultrawork\", \"ulw\", \"uw\"],\n    \"search\": [\"search\", \"find\", \"locate\"],\n    \"analyze\": [\"analyze\", \"investigate\", \"examine\"]\n  }\n}\n`;\n\n    writeFileSync(targetPath, configContent);\n    console.log(chalk.green(`Created configuration: ${targetPath}`));\n\n    // Also create the JSON schema for editor support\n    const schemaPath = join(targetDir, 'sisyphus-schema.json');\n    writeFileSync(schemaPath, JSON.stringify(generateConfigSchema(), null, 2));\n    console.log(chalk.green(`Created JSON schema: ${schemaPath}`));\n\n    console.log(chalk.blue('\\nSetup complete!'));\n    console.log(chalk.gray('Edit the configuration file to customize your setup.'));\n\n    // Create AGENTS.md template if it doesn't exist\n    const agentsMdPath = join(process.cwd(), 'AGENTS.md');\n    if (!existsSync(agentsMdPath) && !options.global) {\n      const agentsMdContent = `# Project Agents Configuration\n\nThis file provides context and instructions to AI agents working on this project.\n\n## Project Overview\n\n<!-- Describe your project here -->\n\n## Architecture\n\n<!-- Describe the architecture and key components -->\n\n## Conventions\n\n<!-- List coding conventions, naming patterns, etc. -->\n\n## Important Files\n\n<!-- List key files agents should know about -->\n\n## Common Tasks\n\n<!-- Describe common development tasks and how to perform them -->\n`;\n      writeFileSync(agentsMdPath, agentsMdContent);\n      console.log(chalk.green(`Created AGENTS.md template`));\n    }\n  });\n\n/**\n * Config command - Show or validate configuration\n */\nprogram\n  .command('config')\n  .description('Show current configuration')\n  .option('-v, --validate', 'Validate configuration')\n  .option('-p, --paths', 'Show configuration file paths')\n  .addHelpText('after', `\nExamples:\n  $ omc config                   Show current configuration\n  $ omc config --validate        Validate configuration files\n  $ omc config --paths           Show config file locations\n\n  }`)\n  .action(async (options) => {\n    if (options.paths) {\n      const paths = getConfigPaths();\n      console.log(chalk.blue('Configuration file paths:'));\n      console.log(`  User:    ${paths.user}`);\n      console.log(`  Project: ${paths.project}`);\n\n      console.log(chalk.blue('\\nFile status:'));\n      console.log(`  User:    ${existsSync(paths.user) ? chalk.green('exists') : chalk.gray('not found')}`);\n      console.log(`  Project: ${existsSync(paths.project) ? chalk.green('exists') : chalk.gray('not found')}`);\n      return;\n    }\n\n    const config = loadConfig();\n\n    if (options.validate) {\n      console.log(chalk.blue('Validating configuration...\\n'));\n\n      // Check for required fields\n      const warnings: string[] = [];\n      const errors: string[] = [];\n\n      if (!process.env.ANTHROPIC_API_KEY) {\n        warnings.push('ANTHROPIC_API_KEY environment variable not set');\n      }\n\n      if (config.mcpServers?.exa?.enabled && !process.env.EXA_API_KEY && !config.mcpServers.exa.apiKey) {\n        warnings.push('Exa is enabled but EXA_API_KEY is not set');\n      }\n\n      if (errors.length > 0) {\n        console.log(chalk.red('Errors:'));\n        errors.forEach(e => console.log(chalk.red(`  - ${e}`)));\n      }\n\n      if (warnings.length > 0) {\n        console.log(chalk.yellow('Warnings:'));\n        warnings.forEach(w => console.log(chalk.yellow(`  - ${w}`)));\n      }\n\n      if (errors.length === 0 && warnings.length === 0) {\n        console.log(chalk.green('Configuration is valid!'));\n      }\n\n      return;\n    }\n\n    console.log(chalk.blue('Current configuration:\\n'));\n    console.log(JSON.stringify(config, null, 2));\n  });\n\n/**\n * Config stop-callback subcommand - Configure stop hook callbacks\n */\nconst _configStopCallback = program\n  .command('config-stop-callback <type>')\n  .description('Configure stop hook callbacks (file/telegram/discord)')\n  .option('--enable', 'Enable callback')\n  .option('--disable', 'Disable callback')\n  .option('--path <path>', 'File path (supports {session_id}, {date}, {time})')\n  .option('--format <format>', 'File format: markdown | json')\n  .option('--token <token>', 'Bot token (telegram or discord-bot)')\n  .option('--chat <id>', 'Telegram chat ID')\n  .option('--webhook <url>', 'Discord webhook URL')\n  .option('--channel-id <id>', 'Discord bot channel ID (used with --profile)')\n  .option('--tag-list <csv>', 'Replace tag list (comma-separated, telegram/discord only)')\n  .option('--add-tag <tag>', 'Append one tag (telegram/discord only)')\n  .option('--remove-tag <tag>', 'Remove one tag (telegram/discord only)')\n  .option('--clear-tags', 'Clear all tags (telegram/discord only)')\n  .option('--profile <name>', 'Named notification profile to configure')\n  .option('--show', 'Show current configuration')\n  .addHelpText('after', `\nTypes:\n  file       File system callback (saves session summary to disk)\n  telegram   Telegram bot notification\n  discord    Discord webhook notification\n\nProfile types (use with --profile):\n  discord-bot  Discord Bot API (token + channel ID)\n  slack        Slack incoming webhook\n  webhook      Generic webhook (POST with JSON body)\n\nExamples:\n  $ omc config-stop-callback file --enable --path ~/.claude/logs/{date}.md\n  $ omc config-stop-callback telegram --enable --token <token> --chat <id>\n  $ omc config-stop-callback discord --enable --webhook <url>\n  $ omc config-stop-callback file --disable\n  $ omc config-stop-callback file --show\n\n  # Named profiles (stored in notificationProfiles):\n  $ omc config-stop-callback discord --profile work --enable --webhook <url>\n  $ omc config-stop-callback telegram --profile work --enable --token <tk> --chat <id>\n  $ omc config-stop-callback discord-bot --profile ops --enable --token <tk> --channel-id <id>\n\n  # Select profile at launch:\n  $ OMC_NOTIFY_PROFILE=work claude`)\n  .action(async (type: string, options) => {\n    // When --profile is used, route to profile-based config\n    if (options.profile) {\n      const profileValidTypes = ['file', 'telegram', 'discord', 'discord-bot', 'slack', 'webhook'];\n      if (!profileValidTypes.includes(type)) {\n        console.error(chalk.red(`Invalid type for profile: ${type}`));\n        console.error(chalk.gray(`Valid types: ${profileValidTypes.join(', ')}`));\n        process.exit(1);\n      }\n\n      const config = getOMCConfig() as OMCConfig & { notificationProfiles?: Record<string, any> };\n      config.notificationProfiles = config.notificationProfiles || {};\n      const profileName = options.profile as string;\n      const profile = config.notificationProfiles[profileName] || { enabled: true };\n\n      // Show current profile config\n      if (options.show) {\n        if (config.notificationProfiles[profileName]) {\n          console.log(chalk.blue(`Profile \"${profileName}\"  ${type} configuration:`));\n          const platformConfig = profile[type];\n          if (platformConfig) {\n            console.log(JSON.stringify(platformConfig, null, 2));\n          } else {\n            console.log(chalk.yellow(`No ${type} platform configured in profile \"${profileName}\".`));\n          }\n        } else {\n          console.log(chalk.yellow(`Profile \"${profileName}\" not found.`));\n        }\n        return;\n      }\n\n      let enabled: boolean | undefined;\n      if (options.enable) enabled = true;\n      else if (options.disable) enabled = false;\n\n      switch (type) {\n        case 'discord': {\n          const current = profile.discord;\n          if (enabled === true && (!options.webhook && !current?.webhookUrl)) {\n            console.error(chalk.red('Discord requires --webhook <webhook_url>'));\n            process.exit(1);\n          }\n          profile.discord = {\n            ...current,\n            enabled: enabled ?? current?.enabled ?? false,\n            webhookUrl: options.webhook ?? current?.webhookUrl,\n          };\n          break;\n        }\n        case 'discord-bot': {\n          const current = profile['discord-bot'];\n          if (enabled === true && (!options.token && !current?.botToken)) {\n            console.error(chalk.red('Discord bot requires --token <bot_token>'));\n            process.exit(1);\n          }\n          if (enabled === true && (!options.channelId && !current?.channelId)) {\n            console.error(chalk.red('Discord bot requires --channel-id <channel_id>'));\n            process.exit(1);\n          }\n          profile['discord-bot'] = {\n            ...current,\n            enabled: enabled ?? current?.enabled ?? false,\n            botToken: options.token ?? current?.botToken,\n            channelId: options.channelId ?? current?.channelId,\n          };\n          break;\n        }\n        case 'telegram': {\n          const current = profile.telegram;\n          if (enabled === true && (!options.token && !current?.botToken)) {\n            console.error(chalk.red('Telegram requires --token <bot_token>'));\n            process.exit(1);\n          }\n          if (enabled === true && (!options.chat && !current?.chatId)) {\n            console.error(chalk.red('Telegram requires --chat <chat_id>'));\n            process.exit(1);\n          }\n          profile.telegram = {\n            ...current,\n            enabled: enabled ?? current?.enabled ?? false,\n            botToken: options.token ?? current?.botToken,\n            chatId: options.chat ?? current?.chatId,\n          };\n          break;\n        }\n        case 'slack': {\n          const current = profile.slack;\n          if (enabled === true && (!options.webhook && !current?.webhookUrl)) {\n            console.error(chalk.red('Slack requires --webhook <webhook_url>'));\n            process.exit(1);\n          }\n          profile.slack = {\n            ...current,\n            enabled: enabled ?? current?.enabled ?? false,\n            webhookUrl: options.webhook ?? current?.webhookUrl,\n          };\n          break;\n        }\n        case 'webhook': {\n          const current = profile.webhook;\n          if (enabled === true && (!options.webhook && !current?.url)) {\n            console.error(chalk.red('Webhook requires --webhook <url>'));\n            process.exit(1);\n          }\n          profile.webhook = {\n            ...current,\n            enabled: enabled ?? current?.enabled ?? false,\n            url: options.webhook ?? current?.url,\n          };\n          break;\n        }\n        case 'file': {\n          console.error(chalk.yellow('File callbacks are not supported in notification profiles.'));\n          console.error(chalk.gray('Use without --profile for file callbacks.'));\n          process.exit(1);\n          break;\n        }\n      }\n\n      config.notificationProfiles[profileName] = profile;\n\n      try {\n        writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2), 'utf-8');\n        console.log(chalk.green(`\\u2713 Profile \"${profileName}\"  ${type} configured`));\n        console.log(JSON.stringify(profile[type], null, 2));\n      } catch (error) {\n        console.error(chalk.red('Failed to write configuration:'), error);\n        process.exit(1);\n      }\n      return;\n    }\n\n    // Legacy (non-profile) path\n    const validTypes = ['file', 'telegram', 'discord'];\n    if (!validTypes.includes(type)) {\n      console.error(chalk.red(`Invalid callback type: ${type}`));\n      console.error(chalk.gray(`Valid types: ${validTypes.join(', ')}`));\n      process.exit(1);\n    }\n\n    const config = getOMCConfig();\n    config.stopHookCallbacks = config.stopHookCallbacks || {};\n\n    // Show current config\n    if (options.show) {\n      const current = config.stopHookCallbacks[type as keyof typeof config.stopHookCallbacks];\n      if (current) {\n        console.log(chalk.blue(`Current ${type} callback configuration:`));\n        console.log(JSON.stringify(current, null, 2));\n      } else {\n        console.log(chalk.yellow(`No ${type} callback configured.`));\n      }\n      return;\n    }\n\n    // Determine enabled state\n    let enabled: boolean | undefined;\n    if (options.enable) {\n      enabled = true;\n    } else if (options.disable) {\n      enabled = false;\n    }\n\n    const hasTagListChanges = options.tagList !== undefined\n      || options.addTag !== undefined\n      || options.removeTag !== undefined\n      || options.clearTags;\n\n    const parseTagList = (value: string): string[] => value\n      .split(',')\n      .map((tag) => tag.trim())\n      .filter(Boolean);\n\n    const resolveTagList = (currentTagList?: string[]): string[] => {\n      let next = options.tagList !== undefined\n        ? parseTagList(options.tagList)\n        : [...(currentTagList ?? [])];\n\n      if (options.clearTags) {\n        next = [];\n      }\n\n      if (options.addTag !== undefined) {\n        const tagToAdd = String(options.addTag).trim();\n        if (tagToAdd && !next.includes(tagToAdd)) {\n          next.push(tagToAdd);\n        }\n      }\n\n      if (options.removeTag !== undefined) {\n        const tagToRemove = String(options.removeTag).trim();\n        if (tagToRemove) {\n          next = next.filter((tag) => tag !== tagToRemove);\n        }\n      }\n\n      return next;\n    };\n\n    // Update config based on type\n    switch (type) {\n      case 'file': {\n        const current = config.stopHookCallbacks.file;\n        config.stopHookCallbacks.file = {\n          enabled: enabled ?? current?.enabled ?? false,\n          path: options.path ?? current?.path ?? '~/.claude/session-logs/{session_id}.md',\n          format: (options.format as 'markdown' | 'json') ?? current?.format ?? 'markdown',\n        };\n        break;\n      }\n\n      case 'telegram': {\n        const current = config.stopHookCallbacks.telegram;\n        if (enabled === true && (!options.token && !current?.botToken)) {\n          console.error(chalk.red('Telegram requires --token <bot_token>'));\n          process.exit(1);\n        }\n        if (enabled === true && (!options.chat && !current?.chatId)) {\n          console.error(chalk.red('Telegram requires --chat <chat_id>'));\n          process.exit(1);\n        }\n        config.stopHookCallbacks.telegram = {\n          ...current,\n          enabled: enabled ?? current?.enabled ?? false,\n          botToken: options.token ?? current?.botToken,\n          chatId: options.chat ?? current?.chatId,\n          tagList: hasTagListChanges ? resolveTagList(current?.tagList) : current?.tagList,\n        };\n        break;\n      }\n\n      case 'discord': {\n        const current = config.stopHookCallbacks.discord;\n        if (enabled === true && (!options.webhook && !current?.webhookUrl)) {\n          console.error(chalk.red('Discord requires --webhook <webhook_url>'));\n          process.exit(1);\n        }\n        config.stopHookCallbacks.discord = {\n          ...current,\n          enabled: enabled ?? current?.enabled ?? false,\n          webhookUrl: options.webhook ?? current?.webhookUrl,\n          tagList: hasTagListChanges ? resolveTagList(current?.tagList) : current?.tagList,\n        };\n        break;\n      }\n    }\n\n    // Write config\n    try {\n      writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2), 'utf-8');\n      console.log(chalk.green(`\\u2713 Stop callback '${type}' configured`));\n      console.log(JSON.stringify(config.stopHookCallbacks[type as keyof typeof config.stopHookCallbacks], null, 2));\n    } catch (error) {\n      console.error(chalk.red('Failed to write configuration:'), error);\n      process.exit(1);\n    }\n  });\n\n/**\n * Config notify-profile subcommand - List, show, and delete notification profiles\n */\nprogram\n  .command('config-notify-profile [name]')\n  .description('Manage notification profiles')\n  .option('--list', 'List all profiles')\n  .option('--show', 'Show profile configuration')\n  .option('--delete', 'Delete a profile')\n  .addHelpText('after', `\nExamples:\n  $ omc config-notify-profile --list\n  $ omc config-notify-profile work --show\n  $ omc config-notify-profile work --delete\n\n  # Create/update profiles via config-stop-callback --profile:\n  $ omc config-stop-callback discord --profile work --enable --webhook <url>\n\n  # Select profile at launch:\n  $ OMC_NOTIFY_PROFILE=work claude`)\n  .action(async (name: string | undefined, options) => {\n    const config = getOMCConfig() as OMCConfig & { notificationProfiles?: Record<string, any> };\n    const profiles = config.notificationProfiles || {};\n\n    if (options.list || !name) {\n      const names = Object.keys(profiles);\n      if (names.length === 0) {\n        console.log(chalk.yellow('No notification profiles configured.'));\n        console.log(chalk.gray('Create one with: omc config-stop-callback <type> --profile <name> --enable ...'));\n      } else {\n        console.log(chalk.blue('Notification profiles:'));\n        for (const pName of names) {\n          const p = profiles[pName];\n          const platforms = ['discord', 'discord-bot', 'telegram', 'slack', 'webhook']\n            .filter((plat) => p[plat]?.enabled)\n            .join(', ');\n          const status = p.enabled !== false ? chalk.green('enabled') : chalk.red('disabled');\n          console.log(`  ${chalk.bold(pName)} [${status}]  ${platforms || 'no platforms'}`);\n        }\n      }\n      const activeProfile = process.env.OMC_NOTIFY_PROFILE;\n      if (activeProfile) {\n        console.log(chalk.gray(`\\nActive profile (OMC_NOTIFY_PROFILE): ${activeProfile}`));\n      }\n      return;\n    }\n\n    if (options.show) {\n      if (profiles[name]) {\n        console.log(chalk.blue(`Profile \"${name}\":`));\n        console.log(JSON.stringify(profiles[name], null, 2));\n      } else {\n        console.log(chalk.yellow(`Profile \"${name}\" not found.`));\n      }\n      return;\n    }\n\n    if (options.delete) {\n      if (!profiles[name]) {\n        console.log(chalk.yellow(`Profile \"${name}\" not found.`));\n        return;\n      }\n      delete profiles[name];\n      config.notificationProfiles = profiles;\n      if (Object.keys(profiles).length === 0) {\n        delete config.notificationProfiles;\n      }\n      try {\n        writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2), 'utf-8');\n        console.log(chalk.green(`\\u2713 Profile \"${name}\" deleted`));\n      } catch (error) {\n        console.error(chalk.red('Failed to write configuration:'), error);\n        process.exit(1);\n      }\n      return;\n    }\n\n    // Default: show the named profile\n    if (profiles[name]) {\n      console.log(chalk.blue(`Profile \"${name}\":`));\n      console.log(JSON.stringify(profiles[name], null, 2));\n    } else {\n      console.log(chalk.yellow(`Profile \"${name}\" not found.`));\n      console.log(chalk.gray('Create it with: omc config-stop-callback <type> --profile ' + name + ' --enable ...'));\n    }\n  });\n\n\n/**\n * Info command - Show system information\n */\nprogram\n  .command('info')\n  .description('Show system and agent information')\n  .addHelpText('after', `\nExamples:\n  $ omc info                     Show agents, features, and MCP servers`)\n  .action(async () => {\n    const session = createSisyphusSession();\n\n    console.log(chalk.blue.bold('\\nOh-My-ClaudeCode System Information\\n'));\n    console.log(chalk.gray(''.repeat(50)));\n\n    console.log(chalk.blue('\\nAvailable Agents:'));\n    const agents = session.queryOptions.options.agents;\n    for (const [name, agent] of Object.entries(agents)) {\n      console.log(`  ${chalk.green(name)}`);\n      console.log(`    ${chalk.gray(agent.description.split('\\n')[0])}`);\n    }\n\n    console.log(chalk.blue('\\nEnabled Features:'));\n    const features = session.config.features;\n    if (features) {\n      console.log(`  Parallel Execution:      ${features.parallelExecution ? chalk.green('enabled') : chalk.gray('disabled')}`);\n      console.log(`  LSP Tools:               ${features.lspTools ? chalk.green('enabled') : chalk.gray('disabled')}`);\n      console.log(`  AST Tools:               ${features.astTools ? chalk.green('enabled') : chalk.gray('disabled')}`);\n      console.log(`  Continuation Enforcement:${features.continuationEnforcement ? chalk.green('enabled') : chalk.gray('disabled')}`);\n      console.log(`  Auto Context Injection:  ${features.autoContextInjection ? chalk.green('enabled') : chalk.gray('disabled')}`);\n    }\n\n    console.log(chalk.blue('\\nMCP Servers:'));\n    const mcpServers = session.queryOptions.options.mcpServers;\n    for (const name of Object.keys(mcpServers)) {\n      console.log(`  ${chalk.green(name)}`);\n    }\n\n    console.log(chalk.blue('\\nMagic Keywords:'));\n    console.log(`  Ultrawork: ${chalk.cyan(session.config.magicKeywords?.ultrawork?.join(', ') ?? 'ultrawork, ulw, uw')}`);\n    console.log(`  Search:    ${chalk.cyan(session.config.magicKeywords?.search?.join(', ') ?? 'search, find, locate')}`);\n    console.log(`  Analyze:   ${chalk.cyan(session.config.magicKeywords?.analyze?.join(', ') ?? 'analyze, investigate, examine')}`);\n\n    console.log(chalk.gray('\\n'.repeat(50)));\n    console.log(chalk.gray(`Version: ${version}`));\n  });\n\n/**\n * Test command - Test prompt enhancement\n */\nprogram\n  .command('test-prompt <prompt>')\n  .description('Test how a prompt would be enhanced')\n  .addHelpText('after', `\nExamples:\n  $ omc test-prompt \"ultrawork fix bugs\"    See how magic keywords are detected\n  $ omc test-prompt \"analyze this code\"     Test prompt enhancement`)\n  .action(async (prompt: string) => {\n    const session = createSisyphusSession();\n\n    console.log(chalk.blue('Original prompt:'));\n    console.log(chalk.gray(prompt));\n\n    const keywords = session.detectKeywords(prompt);\n    if (keywords.length > 0) {\n      console.log(chalk.blue('\\nDetected magic keywords:'));\n      console.log(chalk.yellow(keywords.join(', ')));\n    }\n\n    console.log(chalk.blue('\\nEnhanced prompt:'));\n    console.log(chalk.green(session.processPrompt(prompt)));\n  });\n\n/**\n * Update command - Check for and install updates\n */\nprogram\n  .command('update')\n  .description('Check for and install updates')\n  .option('-c, --check', 'Only check for updates, do not install')\n  .option('-f, --force', 'Force reinstall even if up to date')\n  .option('-q, --quiet', 'Suppress output except for errors')\n  .option('--standalone', 'Force npm update even in plugin context')\n  .addHelpText('after', `\nExamples:\n  $ omc update                   Check and install updates\n  $ omc update --check           Only check, don't install\n  $ omc update --force           Force reinstall\n  $ omc update --standalone      Force npm update in plugin context`)\n  .action(async (options) => {\n    if (!options.quiet) {\n      console.log(chalk.blue('Oh-My-ClaudeCode Update\\n'));\n    }\n\n    try {\n      // Show current version\n      const installed = getInstalledVersion();\n      if (!options.quiet) {\n        console.log(chalk.gray(`Current version: ${installed?.version ?? 'unknown'}`));\n        console.log(chalk.gray(`Install method: ${installed?.installMethod ?? 'unknown'}`));\n        console.log('');\n      }\n\n      // Check for updates\n      if (!options.quiet) {\n        console.log('Checking for updates...');\n      }\n\n      const checkResult = await checkForUpdates();\n\n      if (!checkResult.updateAvailable && !options.force) {\n        if (!options.quiet) {\n          console.log(chalk.green(`\\n You are running the latest version (${checkResult.currentVersion})`));\n        }\n        return;\n      }\n\n      if (!options.quiet) {\n        console.log(formatUpdateNotification(checkResult));\n      }\n\n      // If check-only mode, stop here\n      if (options.check) {\n        if (checkResult.updateAvailable) {\n          console.log(chalk.yellow('\\nRun without --check to install the update.'));\n        }\n        return;\n      }\n\n      // Perform the update\n      if (!options.quiet) {\n        console.log(chalk.blue('\\nStarting update...\\n'));\n      }\n\n      const result = await performUpdate({ verbose: !options.quiet, standalone: options.standalone });\n\n      if (result.success) {\n        if (!options.quiet) {\n          console.log(chalk.green(`\\n ${result.message}`));\n          console.log(chalk.gray('\\nPlease restart your Claude Code session to use the new version.'));\n        }\n      } else {\n        console.error(chalk.red(`\\n ${result.message}`));\n        if (result.errors) {\n          result.errors.forEach(err => console.error(chalk.red(`  - ${err}`)));\n        }\n        process.exit(1);\n      }\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      console.error(chalk.red(`Update failed: ${message}`));\n      console.error(chalk.gray('Try again with \"omc update --force\", or reinstall with \"omc install --force\".'));\n      process.exit(1);\n    }\n  });\n\n/**\n * Update reconcile command - Internal command for post-update reconciliation\n * Called automatically after npm install to ensure hooks/settings are updated with NEW code\n */\nprogram\n  .command('update-reconcile')\n  .description('Internal: Reconcile runtime state after update (called by update command)')\n  .option('-v, --verbose', 'Show detailed output')\n  .action(async (options) => {\n    try {\n      const reconcileResult = reconcileUpdateRuntime({ verbose: options.verbose });\n      if (!reconcileResult.success) {\n        console.error(chalk.red('Reconciliation failed:'));\n        if (reconcileResult.errors) {\n          reconcileResult.errors.forEach(err => console.error(chalk.red(`  - ${err}`)));\n        }\n        process.exit(1);\n      }\n      if (options.verbose) {\n        console.log(chalk.green(reconcileResult.message));\n      }\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      console.error(chalk.red(`Reconciliation error: ${message}`));\n      process.exit(1);\n    }\n  });\n\n/**\n * Version command - Show version information\n */\nprogram\n  .command('version')\n  .description('Show detailed version information')\n  .addHelpText('after', `\nExamples:\n  $ omc version                  Show version, install method, and commit hash`)\n  .action(async () => {\n    const installed = getInstalledVersion();\n\n    console.log(chalk.blue.bold('\\nOh-My-ClaudeCode Version Information\\n'));\n    console.log(chalk.gray(''.repeat(50)));\n\n    console.log(`\\n  Package version:   ${chalk.green(version)}`);\n\n    if (installed) {\n      console.log(`  Installed version: ${chalk.green(installed.version)}`);\n      console.log(`  Install method:    ${chalk.cyan(installed.installMethod)}`);\n      console.log(`  Installed at:      ${chalk.gray(installed.installedAt)}`);\n      if (installed.lastCheckAt) {\n        console.log(`  Last update check: ${chalk.gray(installed.lastCheckAt)}`);\n      }\n      if (installed.commitHash) {\n        console.log(`  Commit hash:       ${chalk.gray(installed.commitHash)}`);\n      }\n    } else {\n      console.log(chalk.yellow('  No installation metadata found'));\n      console.log(chalk.gray('  (Run the install script to create version metadata)'));\n    }\n\n    console.log(chalk.gray('\\n'.repeat(50)));\n    console.log(chalk.gray('\\nTo check for updates, run: ultrapower update --check'));\n  });\n\n/**\n * Install command - Install agents and commands to ~/.claude/\n */\nprogram\n  .command('install')\n  .description('Install Sisyphus agents and commands to Claude Code config (~/.claude/)')\n  .option('-f, --force', 'Overwrite existing files')\n  .option('-q, --quiet', 'Suppress output except for errors')\n  .option('--skip-claude-check', 'Skip checking if Claude Code is installed')\n  .addHelpText('after', `\nExamples:\n  $ omc install                  Install to ~/.claude/\n  $ omc install --force          Reinstall, overwriting existing files\n  $ omc install --quiet          Silent install for scripts`)\n  .action(async (options) => {\n    if (!options.quiet) {\n      console.log(chalk.blue(''));\n      console.log(chalk.blue('         Oh-My-ClaudeCode Installer                        '));\n      console.log(chalk.blue('   Multi-Agent Orchestration for Claude Code               '));\n      console.log(chalk.blue(''));\n      console.log('');\n    }\n\n    // Check if already installed\n    if (isInstalled() && !options.force) {\n      const info = getInstallInfo();\n      if (!options.quiet) {\n        console.log(chalk.yellow('Sisyphus is already installed.'));\n        if (info) {\n          console.log(chalk.gray(`  Version: ${info.version}`));\n          console.log(chalk.gray(`  Installed: ${info.installedAt}`));\n        }\n        console.log(chalk.gray('\\nUse --force to reinstall.'));\n      }\n      return;\n    }\n\n    // Run installation\n    const result = installSisyphus({\n      force: options.force,\n      verbose: !options.quiet,\n      skipClaudeCheck: options.skipClaudeCheck\n    });\n\n    if (result.success) {\n      if (!options.quiet) {\n        console.log('');\n        console.log(chalk.green(''));\n        console.log(chalk.green('         Installation Complete!                            '));\n        console.log(chalk.green(''));\n        console.log('');\n        console.log(chalk.gray(`Installed to: ~/.claude/`));\n        console.log('');\n        console.log(chalk.yellow('Usage:'));\n        console.log('  claude                        # Start Claude Code normally');\n        console.log('');\n        console.log(chalk.yellow('Slash Commands:'));\n        console.log('  /sisyphus <task>              # Activate Sisyphus orchestration mode');\n        console.log('  /sisyphus-default             # Configure for current project');\n        console.log('  /sisyphus-default-global      # Configure globally');\n        console.log('  /ultrawork <task>             # Maximum performance mode');\n        console.log('  /deepsearch <query>           # Thorough codebase search');\n        console.log('  /analyze <target>             # Deep analysis mode');\n        console.log('  /plan <description>           # Start planning with Planner');\n        console.log('  /review [plan-path]           # Review plan with Critic');\n        console.log('');\n        console.log(chalk.yellow('Available Agents (via Task tool):'));\n        console.log(chalk.gray('  Base Agents:'));\n        console.log('    architect              - Architecture & debugging (Opus)');\n        console.log('    document-specialist   - External docs & reference lookup (Sonnet)');\n        console.log('    explore             - Fast pattern matching (Haiku)');\n        console.log('    designer            - UI/UX specialist (Sonnet)');\n        console.log('    writer              - Technical writing (Haiku)');\n        console.log('    vision              - Visual analysis (Sonnet)');\n        console.log('    critic               - Plan review (Opus)');\n        console.log('    analyst               - Pre-planning analysis (Opus)');\n        console.log('    orchestrator-sisyphus - Todo coordination (Opus)');\n        console.log('    executor            - Focused execution (Sonnet)');\n        console.log('    planner          - Strategic planning (Opus)');\n        console.log('    qa-tester           - Interactive CLI testing (Sonnet)');\n        console.log(chalk.gray('  Tiered Variants (for smart routing):'));\n        console.log('    architect-medium       - Simpler analysis (Sonnet)');\n        console.log('    architect-low          - Quick questions (Haiku)');\n        console.log('    executor-high       - Complex tasks (Opus)');\n        console.log('    executor-low        - Trivial tasks (Haiku)');\n        console.log('    designer-high       - Design systems (Opus)');\n        console.log('    designer-low        - Simple styling (Haiku)');\n        console.log('');\n        console.log(chalk.yellow('After Updates:'));\n        console.log('  Run \\'/sisyphus-default\\' (project) or \\'/sisyphus-default-global\\' (global)');\n        console.log('  to download the latest CLAUDE.md configuration.');\n        console.log('  This ensures you get the newest features and agent behaviors.');\n        console.log('');\n        console.log(chalk.blue('Quick Start:'));\n        console.log('  1. Run \\'claude\\' to start Claude Code');\n        console.log('  2. Type \\'/sisyphus-default\\' for project or \\'/sisyphus-default-global\\' for global');\n        console.log('  3. Or use \\'/sisyphus <task>\\' for one-time activation');\n      }\n    } else {\n      console.error(chalk.red(`Installation failed: ${result.message}`));\n      if (result.errors.length > 0) {\n        result.errors.forEach(err => console.error(chalk.red(`  - ${err}`)));\n      }\n      console.error(chalk.gray('\\nTry \"omc install --force\" to overwrite existing files.'));\n      console.error(chalk.gray('For more diagnostics, run \"omc doctor conflicts\".'));\n      process.exit(1);\n    }\n  });\n\n/**\n * Wait command - Rate limit wait and auto-resume\n *\n * Zero learning curve design:\n * - `omc wait` alone shows status and suggests next action\n * - `omc wait --start` starts the daemon (shortcut)\n * - `omc wait --stop` stops the daemon (shortcut)\n * - Subcommands available for power users\n */\nconst waitCmd = program\n  .command('wait')\n  .description('Rate limit wait and auto-resume (just run \"omc wait\" to get started)')\n  .option('--json', 'Output as JSON')\n  .option('--start', 'Start the auto-resume daemon')\n  .option('--stop', 'Stop the auto-resume daemon')\n  .addHelpText('after', `\nExamples:\n  $ omc wait                     Show status and suggestions\n  $ omc wait --start             Start auto-resume daemon\n  $ omc wait --stop              Stop auto-resume daemon\n  $ omc wait status              Show detailed rate limit status\n  $ omc wait detect              Scan for blocked tmux sessions`)\n  .action(async (options) => {\n    await waitCommand(options);\n  });\n\nwaitCmd\n  .command('status')\n  .description('Show detailed rate limit and daemon status')\n  .option('--json', 'Output as JSON')\n  .action(async (options) => {\n    await waitStatusCommand(options);\n  });\n\nwaitCmd\n  .command('daemon <action>')\n  .description('Start or stop the auto-resume daemon')\n  .option('-v, --verbose', 'Enable verbose logging')\n  .option('-f, --foreground', 'Run in foreground (blocking)')\n  .option('-i, --interval <seconds>', 'Poll interval in seconds', '60')\n  .addHelpText('after', `\nExamples:\n  $ omc wait daemon start            Start background daemon\n  $ omc wait daemon stop             Stop the daemon\n  $ omc wait daemon start -f         Run in foreground`)\n  .action(async (action: string, options) => {\n    if (action !== 'start' && action !== 'stop') {\n      console.error(chalk.red(`Invalid action \"${action}\". Valid options: start, stop`));\n      console.error(chalk.gray('Example: omc wait daemon start'));\n      process.exit(1);\n    }\n    await waitDaemonCommand(action as 'start' | 'stop', {\n      verbose: options.verbose,\n      foreground: options.foreground,\n      interval: parseInt(options.interval),\n    });\n  });\n\nwaitCmd\n  .command('detect')\n  .description('Scan for blocked Claude Code sessions in tmux')\n  .option('--json', 'Output as JSON')\n  .option('-l, --lines <number>', 'Number of pane lines to analyze', '15')\n  .action(async (options) => {\n    await waitDetectCommand({\n      json: options.json,\n      lines: parseInt(options.lines),\n    });\n  });\n\n/**\n * Teleport command - Quick worktree creation\n *\n * Usage:\n * - `omc teleport #123` - Create worktree for issue/PR #123\n * - `omc teleport my-feature` - Create worktree for feature branch\n * - `omc teleport list` - List existing worktrees\n * - `omc teleport remove <path>` - Remove a worktree\n */\nconst teleportCmd = program\n  .command('teleport [ref]')\n  .description('Create git worktree for isolated development (e.g., omc teleport #123)')\n  .option('--worktree', 'Create worktree (default behavior, flag kept for compatibility)')\n  .option('-p, --path <path>', 'Custom worktree path (default: ~/Workspace/omc-worktrees/)')\n  .option('-b, --base <branch>', 'Base branch to create from (default: main)')\n  .option('--json', 'Output as JSON')\n  .addHelpText('after', `\nExamples:\n  $ omc teleport #42             Create worktree for issue/PR #42\n  $ omc teleport add-auth        Create worktree for a feature branch\n  $ omc teleport list            List existing worktrees\n  $ omc teleport remove ./path   Remove a worktree`)\n  .action(async (ref: string | undefined, options) => {\n    if (!ref) {\n      // No ref provided, show help\n      console.log(chalk.blue('Teleport - Quick worktree creation\\n'));\n      console.log('Usage:');\n      console.log('  omc teleport <ref>           Create worktree for issue/PR/feature');\n      console.log('  omc teleport list            List existing worktrees');\n      console.log('  omc teleport remove <path>   Remove a worktree');\n      console.log('');\n      console.log('Reference formats:');\n      console.log('  #123                         Issue/PR in current repo');\n      console.log('  owner/repo#123               Issue/PR in specific repo');\n      console.log('  my-feature                   Feature branch name');\n      console.log('  https://github.com/...       GitHub URL');\n      console.log('');\n      console.log('Examples:');\n      console.log('  omc teleport #42             Create worktree for issue #42');\n      console.log('  omc teleport add-auth        Create worktree for feature \"add-auth\"');\n      console.log('');\n      return;\n    }\n\n    await teleportCommand(ref, {\n      worktree: true, // Always create worktree\n      worktreePath: options.path,\n      base: options.base,\n      json: options.json,\n    });\n  });\n\nteleportCmd\n  .command('list')\n  .description('List existing worktrees in ~/Workspace/omc-worktrees/')\n  .option('--json', 'Output as JSON')\n  .action(async (options) => {\n    await teleportListCommand(options);\n  });\n\nteleportCmd\n  .command('remove <path>')\n  .alias('rm')\n  .description('Remove a worktree')\n  .option('-f, --force', 'Force removal even with uncommitted changes')\n  .option('--json', 'Output as JSON')\n  .action(async (path: string, options) => {\n    await teleportRemoveCommand(path, options);\n  });\n\n/**\n * Doctor command - Diagnostic tools\n */\nconst doctorCmd = program\n  .command('doctor')\n  .description('Diagnostic tools for troubleshooting OMC installation')\n  .addHelpText('after', `\nExamples:\n  $ omc doctor conflicts         Check for plugin conflicts`);\n\ndoctorCmd\n  .command('conflicts')\n  .description('Check for plugin coexistence issues and configuration conflicts')\n  .option('--json', 'Output as JSON')\n  .addHelpText('after', `\nExamples:\n  $ omc doctor conflicts         Check for configuration issues\n  $ omc doctor conflicts --json  Output results as JSON`)\n  .action(async (options) => {\n    const exitCode = await doctorConflictsCommand(options);\n    process.exit(exitCode);\n  });\n\n/**\n * Setup command - Official CLI entry point for omc-setup\n *\n * User-friendly command that syncs all OMC components:\n * - Installs/updates hooks, agents, and skills\n * - Reconciles runtime state after updates\n * - Shows clear summary of what was installed/updated\n */\nprogram\n  .command('setup')\n  .description('Run OMC setup to sync all components (hooks, agents, skills)')\n  .option('-f, --force', 'Force reinstall even if already up to date')\n  .option('-q, --quiet', 'Suppress output except for errors')\n  .option('--skip-hooks', 'Skip hook installation')\n  .option('--force-hooks', 'Force reinstall hooks even if unchanged')\n  .addHelpText('after', `\nExamples:\n  $ omc setup                     Sync all OMC components\n  $ omc setup --force             Force reinstall everything\n  $ omc setup --quiet             Silent setup for scripts\n  $ omc setup --skip-hooks        Install without hooks\n  $ omc setup --force-hooks       Force reinstall hooks`)\n  .action(async (options) => {\n    if (!options.quiet) {\n      console.log(chalk.blue('Oh-My-ClaudeCode Setup\\n'));\n    }\n\n    // Step 1: Run installation (which handles hooks, agents, skills)\n    if (!options.quiet) {\n      console.log(chalk.gray('Syncing OMC components...'));\n    }\n\n    const result = installSisyphus({\n      force: !!options.force,\n      verbose: !options.quiet,\n      skipClaudeCheck: true,\n      forceHooks: !!options.forceHooks,\n    });\n\n    if (!result.success) {\n      console.error(chalk.red(`Setup failed: ${result.message}`));\n      if (result.errors.length > 0) {\n        result.errors.forEach(err => console.error(chalk.red(`  - ${err}`)));\n      }\n      process.exit(1);\n    }\n\n    // Step 2: Show summary\n    if (!options.quiet) {\n      console.log('');\n      console.log(chalk.green('Setup complete!'));\n      console.log('');\n\n      if (result.installedAgents.length > 0) {\n        console.log(chalk.gray(`  Agents:   ${result.installedAgents.length} synced`));\n      }\n      if (result.installedCommands.length > 0) {\n        console.log(chalk.gray(`  Commands: ${result.installedCommands.length} synced`));\n      }\n      if (result.installedSkills.length > 0) {\n        console.log(chalk.gray(`  Skills:   ${result.installedSkills.length} synced`));\n      }\n      if (result.hooksConfigured) {\n        console.log(chalk.gray('  Hooks:    configured'));\n      }\n      if (result.hookConflicts.length > 0) {\n        console.log('');\n        console.log(chalk.yellow('  Hook conflicts detected:'));\n        result.hookConflicts.forEach(c => {\n          console.log(chalk.yellow(`    - ${c.eventType}: ${c.existingCommand}`));\n        });\n      }\n\n      console.log('');\n      console.log(chalk.gray(`Version: ${version}`));\n      console.log(chalk.gray('Start Claude Code and use /ultrapower:omc-setup for interactive setup.'));\n    }\n  });\n\n/**\n * Postinstall command - Silent install for npm postinstall hook\n */\nprogram\n  .command('postinstall', { hidden: true })\n  .description('Run post-install setup (called automatically by npm)')\n  .action(async () => {\n    // Silent install - only show errors\n    const result = installSisyphus({\n      force: false,\n      verbose: false,\n      skipClaudeCheck: true\n    });\n\n    if (result.success) {\n      console.log(chalk.green(' Oh-My-ClaudeCode installed successfully!'));\n      console.log(chalk.gray('  Run \"ultrapower info\" to see available agents.'));\n      console.log(chalk.yellow('  Run \"/sisyphus-default\" (project) or \"/sisyphus-default-global\" (global) in Claude Code.'));\n    } else {\n      // Don't fail the npm install, just warn\n      console.warn(chalk.yellow(' Could not complete Sisyphus setup:'), result.message);\n      console.warn(chalk.gray('  Run \"ultrapower install\" manually to complete setup.'));\n    }\n  });\n\n// Parse arguments\nprogram.parse();\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\cli\\interop.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\cli\\launch.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\cli\\tmux-utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\cli\\utils\\formatting.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":6,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":6,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[141,144],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[141,144],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":9,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":9,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[194,197],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[194,197],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export interface TableColumn {\n  header: string;\n  field: string;\n  width: number;\n  align?: 'left' | 'right' | 'center';\n  format?: (value: any) => string;\n}\n\nexport function renderTable(data: any[], columns: TableColumn[]): string {\n  const lines: string[] = [];\n\n  // Header\n  const headerRow = columns.map(col => {\n    return padString(col.header, col.width, col.align || 'left');\n  }).join(' | ');\n\n  lines.push(headerRow);\n  lines.push(columns.map(col => '-'.repeat(col.width)).join('-+-'));\n\n  // Data rows\n  for (const row of data) {\n    const dataRow = columns.map(col => {\n      const value = row[col.field];\n      const formatted = col.format ? col.format(value) : String(value ?? '');\n      return padString(formatted, col.width, col.align || 'left');\n    }).join(' | ');\n\n    lines.push(dataRow);\n  }\n\n  return lines.join('\\n');\n}\n\nfunction padString(str: string, width: number, align: 'left' | 'right' | 'center'): string {\n  const stripAnsi = (s: string) => s.replace(/\\x1b\\[[0-9;]*m/g, '');\n  const visibleLength = stripAnsi(str).length;\n  const padding = Math.max(0, width - visibleLength);\n\n  if (align === 'right') {\n    return ' '.repeat(padding) + str;\n  } else if (align === 'center') {\n    const leftPad = Math.floor(padding / 2);\n    const rightPad = padding - leftPad;\n    return ' '.repeat(leftPad) + str + ' '.repeat(rightPad);\n  } else {\n    return str + ' '.repeat(padding);\n  }\n}\n\nexport const colors = {\n  red: (text: string) => `\\x1b[31m${text}\\x1b[0m`,\n  green: (text: string) => `\\x1b[32m${text}\\x1b[0m`,\n  yellow: (text: string) => `\\x1b[33m${text}\\x1b[0m`,\n  blue: (text: string) => `\\x1b[34m${text}\\x1b[0m`,\n  magenta: (text: string) => `\\x1b[35m${text}\\x1b[0m`,\n  cyan: (text: string) => `\\x1b[36m${text}\\x1b[0m`,\n  gray: (text: string) => `\\x1b[90m${text}\\x1b[0m`,\n  bold: (text: string) => `\\x1b[1m${text}\\x1b[0m`\n};\n\nexport function formatCostWithColor(cost: number): string {\n  if (cost < 1.0) return colors.green(`$${cost.toFixed(4)}`);\n  if (cost < 5.0) return colors.yellow(`$${cost.toFixed(4)}`);\n  return colors.red(`$${cost.toFixed(4)}`);\n}\n\nexport function formatTokenCount(tokens: number): string {\n  if (tokens < 1000) return `${tokens}`;\n  if (tokens < 1000000) return `${(tokens / 1000).toFixed(1)}k`;\n  return `${(tokens / 1000000).toFixed(2)}M`;\n}\n\nexport function formatDuration(ms: number): string {\n  const seconds = Math.floor(ms / 1000);\n  const minutes = Math.floor(seconds / 60);\n  const hours = Math.floor(minutes / 60);\n\n  if (hours > 0) return `${hours}h ${minutes % 60}m`;\n  if (minutes > 0) return `${minutes}m ${seconds % 60}s`;\n  return `${seconds}s`;\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\cli\\utils\\tokscale-launcher.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\commands\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\compatibility\\discovery.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":119,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":119,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3585,3588],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3585,3588],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\compatibility\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\compatibility\\mcp-bridge.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\compatibility\\permission-adapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\compatibility\\registry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\compatibility\\safe-regex.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\compatibility\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\config\\axiom-config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\config\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\config\\loader.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\constants\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\constants\\names.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\auto-update.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":40,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":40,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1756,1759],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1756,1759],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Auto-Update System\n *\n * Provides version checking and auto-update functionality for ultrapower.\n *\n * Features:\n * - Check for new versions from GitHub releases\n * - Download and install updates automatically\n * - Store version metadata for installed components\n * - Configurable update notifications\n */\n\nimport { readFileSync, writeFileSync, existsSync, mkdirSync } from 'fs';\nimport { join, dirname } from 'path';\nimport { execSync } from 'child_process';\nimport { TaskTool } from '../hooks/beads-context/types.js';\nimport { install as installSisyphus, HOOKS_DIR, isProjectScopedPlugin, isRunningAsPlugin } from '../installer/index.js';\nimport { getConfigDir } from '../utils/config-dir.js';\nimport type { NotificationConfig } from '../notifications/types.js';\n\n/** GitHub repository information */\nexport const REPO_OWNER = 'liangjie559567';\nexport const REPO_NAME = 'ultrapower';\nexport const GITHUB_API_URL = `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}`;\nexport const GITHUB_RAW_URL = `https://raw.githubusercontent.com/${REPO_OWNER}/${REPO_NAME}`;\n\n/**\n * Best-effort sync of the Claude Code marketplace clone.\n * The marketplace clone at ~/.claude/plugins/marketplaces/omc/ is used by\n * Claude Code to populate the plugin cache. If it's stale, `/plugin install`\n * and cache rebuilds reinstall old versions. (See #506)\n */\nfunction syncMarketplaceClone(verbose: boolean = false): { ok: boolean; message: string } {\n  const marketplacePath = join(getConfigDir(), 'plugins', 'marketplaces', 'omc');\n  if (!existsSync(marketplacePath)) {\n    return { ok: true, message: 'Marketplace clone not found; skipping' };\n  }\n\n  const stdio = verbose ? 'inherit' : 'pipe';\n  const execOpts = { encoding: 'utf-8' as const, stdio: stdio as any, timeout: 60000 };\n\n  try {\n    execSync(`git -C \"${marketplacePath}\" fetch --all --prune`, execOpts);\n  } catch (err) {\n    return { ok: false, message: `Failed to fetch marketplace clone: ${err instanceof Error ? err.message : err}` };\n  }\n\n  // Ensure we're on main (ignore errors for older clones on different branches)\n  try { execSync(`git -C \"${marketplacePath}\" checkout main`, { ...execOpts, timeout: 15000 }); } catch { /* ignore checkout errors on older clones */ }\n\n  try {\n    execSync(`git -C \"${marketplacePath}\" pull --ff-only origin main`, execOpts);\n  } catch (err) {\n    return { ok: false, message: `Failed to update marketplace clone: ${err instanceof Error ? err.message : err}` };\n  }\n\n  return { ok: true, message: 'Marketplace clone updated' };\n}\n\n/** Installation paths (respects CLAUDE_CONFIG_DIR env var) */\nexport const CLAUDE_CONFIG_DIR = getConfigDir();\nexport const VERSION_FILE = join(CLAUDE_CONFIG_DIR, '.omc-version.json');\nexport const CONFIG_FILE = join(CLAUDE_CONFIG_DIR, '.omc-config.json');\n\n/**\n * Stop hook callback configuration for file logging\n */\nexport interface StopCallbackFileConfig {\n  enabled: boolean;\n  /** File path with placeholders: {session_id}, {date}, {time} */\n  path: string;\n  /** Output format */\n  format?: 'markdown' | 'json';\n}\n\n/**\n * Stop hook callback configuration for Telegram\n */\nexport interface StopCallbackTelegramConfig {\n  enabled: boolean;\n  /** Telegram bot token */\n  botToken?: string;\n  /** Chat ID to send messages to */\n  chatId?: string;\n  /** Optional tags/usernames to prefix in notifications */\n  tagList?: string[];\n}\n\n/**\n * Stop hook callback configuration for Discord\n */\nexport interface StopCallbackDiscordConfig {\n  enabled: boolean;\n  /** Discord webhook URL */\n  webhookUrl?: string;\n  /** Optional tags/user IDs/roles to prefix in notifications */\n  tagList?: string[];\n}\n\n/**\n * Stop hook callbacks configuration\n */\nexport interface StopHookCallbacksConfig {\n  file?: StopCallbackFileConfig;\n  telegram?: StopCallbackTelegramConfig;\n  discord?: StopCallbackDiscordConfig;\n}\n\n/**\n * OMC configuration (stored in .omc-config.json)\n */\nexport interface OMCConfig {\n  /** Whether silent auto-updates are enabled (opt-in for security) */\n  silentAutoUpdate: boolean;\n  /** When the configuration was set */\n  configuredAt?: string;\n  /** Configuration schema version */\n  configVersion?: number;\n  /** Preferred task management tool */\n  taskTool?: TaskTool;\n  /** Configuration for the selected task tool */\n  taskToolConfig?: {\n    /** Use beads-mcp instead of CLI */\n    useMcp?: boolean;\n    /** Inject usage instructions at session start (default: true) */\n    injectInstructions?: boolean;\n  };\n  /** Whether initial setup has been completed (ISO timestamp) */\n  setupCompleted?: string;\n  /** Version of setup wizard that was completed */\n  setupVersion?: string;\n  /** Stop hook callback configuration (legacy, use notifications instead) */\n  stopHookCallbacks?: StopHookCallbacksConfig;\n  /** Multi-platform lifecycle notification configuration */\n  notifications?: NotificationConfig;\n  /** Named notification profiles (keyed by profile name) */\n  notificationProfiles?: Record<string, NotificationConfig>;\n  /** Whether HUD statusline is enabled (default: true). Set to false to skip HUD installation. */\n  hudEnabled?: boolean;\n  /** Whether to prompt for upgrade at session start when a new version is available (default: true).\n   *  Set to false to show a passive notification instead of an interactive prompt. */\n  autoUpgradePrompt?: boolean;\n}\n\n/**\n * Read the OMC configuration\n */\nexport function getOMCConfig(): OMCConfig {\n  if (!existsSync(CONFIG_FILE)) {\n    // No config file = disabled by default for security\n    return { silentAutoUpdate: false };\n  }\n\n  try {\n    const content = readFileSync(CONFIG_FILE, 'utf-8');\n    const config = JSON.parse(content) as OMCConfig;\n    return {\n      silentAutoUpdate: config.silentAutoUpdate ?? false,\n      configuredAt: config.configuredAt,\n      configVersion: config.configVersion,\n      taskTool: config.taskTool,\n      taskToolConfig: config.taskToolConfig,\n      setupCompleted: config.setupCompleted,\n      setupVersion: config.setupVersion,\n      stopHookCallbacks: config.stopHookCallbacks,\n      notifications: config.notifications,\n      notificationProfiles: config.notificationProfiles,\n      hudEnabled: config.hudEnabled,\n      autoUpgradePrompt: config.autoUpgradePrompt,\n    };\n  } catch {\n    // If config file is invalid, default to disabled for security\n    return { silentAutoUpdate: false };\n  }\n}\n\n/**\n * Check if silent auto-updates are enabled\n */\nexport function isSilentAutoUpdateEnabled(): boolean {\n  return getOMCConfig().silentAutoUpdate;\n}\n\n/**\n * Check if auto-upgrade prompt is enabled at session start\n * Returns true by default - users must explicitly opt out\n */\nexport function isAutoUpgradePromptEnabled(): boolean {\n  return getOMCConfig().autoUpgradePrompt !== false;\n}\n\n/**\n * Check if team feature is enabled\n * Returns false by default - requires explicit opt-in\n * Checks ~/.claude/settings.json first, then env var fallback\n */\nexport function isTeamEnabled(): boolean {\n  try {\n    const settingsPath = join(CLAUDE_CONFIG_DIR, 'settings.json');\n    if (existsSync(settingsPath)) {\n      const settings = JSON.parse(readFileSync(settingsPath, 'utf-8'));\n      const val = settings.env?.CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS;\n      if (val === '1' || val === 'true') {\n        return true;\n      }\n    }\n  } catch {\n    // Fall through to env check\n  }\n  const envVal = process.env.CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS;\n  return envVal === '1' || envVal === 'true';\n}\n\n/**\n * Version metadata stored after installation\n */\nexport interface VersionMetadata {\n  /** Currently installed version */\n  version: string;\n  /** Installation timestamp */\n  installedAt: string;\n  /** Last update check timestamp */\n  lastCheckAt?: string;\n  /** Git commit hash if installed from source */\n  commitHash?: string;\n  /** Installation method: 'script' | 'npm' | 'source' */\n  installMethod: 'script' | 'npm' | 'source';\n}\n\n/**\n * GitHub release information\n */\nexport interface ReleaseInfo {\n  tag_name: string;\n  name: string;\n  published_at: string;\n  html_url: string;\n  body: string;\n  prerelease: boolean;\n  draft: boolean;\n}\n\n/**\n * Update check result\n */\nexport interface UpdateCheckResult {\n  currentVersion: string | null;\n  latestVersion: string;\n  updateAvailable: boolean;\n  releaseInfo: ReleaseInfo;\n  releaseNotes: string;\n}\n\n/**\n * Update result\n */\nexport interface UpdateResult {\n  success: boolean;\n  previousVersion: string | null;\n  newVersion: string;\n  message: string;\n  errors?: string[];\n}\n\nexport interface UpdateReconcileResult {\n  success: boolean;\n  message: string;\n  errors?: string[];\n}\n\n/**\n * Read the current version metadata\n */\nexport function getInstalledVersion(): VersionMetadata | null {\n  if (!existsSync(VERSION_FILE)) {\n    // Try to detect version from package.json if installed via npm\n    try {\n      // Check if we can find the package in node_modules\n      const result = execSync('npm list -g @liangjie559567/ultrapower --json', {\n        encoding: 'utf-8',\n        timeout: 5000,\n        stdio: 'pipe'\n      });\n      const data = JSON.parse(result);\n      if (data.dependencies?.['@liangjie559567/ultrapower']?.version) {\n        return {\n          version: data.dependencies['@liangjie559567/ultrapower'].version,\n          installedAt: new Date().toISOString(),\n          installMethod: 'npm'\n        };\n      }\n    } catch {\n      // Not installed via npm or command failed\n    }\n    return null;\n  }\n\n  try {\n    const content = readFileSync(VERSION_FILE, 'utf-8');\n    return JSON.parse(content) as VersionMetadata;\n  } catch (error) {\n    console.error('Error reading version file:', error);\n    return null;\n  }\n}\n\n/**\n * Save version metadata after installation/update\n */\nexport function saveVersionMetadata(metadata: VersionMetadata): void {\n  const dir = dirname(VERSION_FILE);\n  if (!existsSync(dir)) {\n    mkdirSync(dir, { recursive: true });\n  }\n  writeFileSync(VERSION_FILE, JSON.stringify(metadata, null, 2));\n}\n\n/**\n * Update the last check timestamp\n */\nexport function updateLastCheckTime(): void {\n  const current = getInstalledVersion();\n  if (current) {\n    current.lastCheckAt = new Date().toISOString();\n    saveVersionMetadata(current);\n  }\n}\n\n/**\n * Fetch the latest release from GitHub\n */\nexport async function fetchLatestRelease(): Promise<ReleaseInfo> {\n  const response = await fetch(`${GITHUB_API_URL}/releases/latest`, {\n    headers: {\n      'Accept': 'application/vnd.github.v3+json',\n      'User-Agent': 'ultrapower-updater'\n    }\n  });\n\n  if (response.status === 404) {\n    // No releases found - try to get version from package.json in repo\n    const pkgResponse = await fetch(`${GITHUB_RAW_URL}/main/package.json`, {\n      headers: {\n        'User-Agent': 'ultrapower-updater'\n      }\n    });\n\n    if (pkgResponse.ok) {\n      const pkg = await pkgResponse.json() as { version: string };\n      return {\n        tag_name: `v${pkg.version}`,\n        name: `Version ${pkg.version}`,\n        published_at: new Date().toISOString(),\n        html_url: `https://github.com/${REPO_OWNER}/${REPO_NAME}`,\n        body: 'No release notes available (fetched from package.json)',\n        prerelease: false,\n        draft: false\n      };\n    }\n\n    throw new Error('No releases found and could not fetch package.json');\n  }\n\n  if (!response.ok) {\n    throw new Error(`Failed to fetch release info: ${response.status} ${response.statusText}`);\n  }\n\n  return await response.json() as ReleaseInfo;\n}\n\n/**\n * Compare semantic versions\n * Returns: -1 if a < b, 0 if a == b, 1 if a > b\n */\nexport function compareVersions(a: string, b: string): number {\n  // Remove 'v' prefix if present\n  const cleanA = a.replace(/^v/, '');\n  const cleanB = b.replace(/^v/, '');\n\n  const partsA = cleanA.split('.').map(n => parseInt(n, 10) || 0);\n  const partsB = cleanB.split('.').map(n => parseInt(n, 10) || 0);\n\n  const maxLength = Math.max(partsA.length, partsB.length);\n\n  for (let i = 0; i < maxLength; i++) {\n    const numA = partsA[i] || 0;\n    const numB = partsB[i] || 0;\n\n    if (numA < numB) return -1;\n    if (numA > numB) return 1;\n  }\n\n  return 0;\n}\n\n/**\n * Check for available updates\n */\nexport async function checkForUpdates(): Promise<UpdateCheckResult> {\n  const installed = getInstalledVersion();\n  const release = await fetchLatestRelease();\n\n  const currentVersion = installed?.version ?? null;\n  const latestVersion = release.tag_name.replace(/^v/, '');\n\n  const updateAvailable = currentVersion === null || compareVersions(currentVersion, latestVersion) < 0;\n\n  // Update last check time\n  updateLastCheckTime();\n\n  return {\n    currentVersion,\n    latestVersion,\n    updateAvailable,\n    releaseInfo: release,\n    releaseNotes: release.body || 'No release notes available.'\n  };\n}\n\n/**\n * Reconcile runtime state after update\n *\n * This is safe to run repeatedly and refreshes local runtime artifacts that may\n * lag behind an updated package or plugin cache.\n */\nexport function reconcileUpdateRuntime(options?: { verbose?: boolean }): UpdateReconcileResult {\n  const errors: string[] = [];\n\n  const projectScopedPlugin = isProjectScopedPlugin();\n  if (!projectScopedPlugin) {\n    try {\n      if (!existsSync(HOOKS_DIR)) {\n        mkdirSync(HOOKS_DIR, { recursive: true });\n      }\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      errors.push(`Failed to prepare hooks directory: ${message}`);\n    }\n  }\n\n  try {\n    const installResult = installSisyphus({\n      force: true,\n      verbose: options?.verbose ?? false,\n      skipClaudeCheck: true,\n      forceHooks: true,\n      refreshHooksInPlugin: !projectScopedPlugin,\n    });\n\n    if (!installResult.success) {\n      errors.push(...installResult.errors);\n    }\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    errors.push(`Failed to refresh installer artifacts: ${message}`);\n  }\n\n  if (errors.length > 0) {\n    return {\n      success: false,\n      message: 'Runtime reconciliation failed',\n      errors,\n    };\n  }\n\n  return {\n    success: true,\n    message: 'Runtime state reconciled successfully',\n  };\n}\n\n/**\n * Download and execute the install script to perform an update\n */\nexport async function performUpdate(options?: {\n  skipConfirmation?: boolean;\n  verbose?: boolean;\n  standalone?: boolean;\n}): Promise<UpdateResult> {\n  const installed = getInstalledVersion();\n  const previousVersion = installed?.version ?? null;\n\n  try {\n    // Check if running as plugin - prevent npm global update from corrupting plugin\n    if (isRunningAsPlugin() && !options?.standalone) {\n      return {\n        success: false,\n        previousVersion,\n        newVersion: 'unknown',\n        message: 'Running as a Claude Code plugin. Use \"/plugin install ultrapower\" to update, or pass --standalone to force npm update.',\n      };\n    }\n\n    // Fetch the latest release to get the version\n    const release = await fetchLatestRelease();\n    const newVersion = release.tag_name.replace(/^v/, '');\n\n    // Use npm for updates on all platforms (install.sh was removed)\n    try {\n      execSync('npm install -g @liangjie559567/ultrapower@latest', {\n        encoding: 'utf-8',\n        stdio: options?.verbose ? 'inherit' : 'pipe',\n        timeout: 120000, // 2 minute timeout for npm\n        ...(process.platform === 'win32' ? { windowsHide: true } : {})\n      });\n\n      // Sync Claude Code marketplace clone so plugin cache picks up new version (#506)\n      const marketplaceSync = syncMarketplaceClone(options?.verbose ?? false);\n      if (!marketplaceSync.ok && options?.verbose) {\n        console.warn(`[omc update] ${marketplaceSync.message}`);\n      }\n\n      // CRITICAL FIX: After npm updates the global package, the current process\n      // still has OLD code loaded in memory. We must re-exec to run reconciliation\n      // with the NEW code. Otherwise, installSisyphus() runs OLD logic against NEW files.\n      if (!process.env.OMC_UPDATE_RECONCILE) {\n        // Set flag to prevent infinite loop\n        process.env.OMC_UPDATE_RECONCILE = '1';\n\n        // Find the omc binary path\n        const omcPath = execSync('which omc 2>/dev/null || where omc 2>NUL', {\n          encoding: 'utf-8',\n          stdio: 'pipe',\n        }).trim().split('\\n')[0];\n\n        // Re-exec with reconcile subcommand\n        try {\n          execSync(`\"${omcPath}\" update-reconcile`, {\n            encoding: 'utf-8',\n            stdio: options?.verbose ? 'inherit' : 'pipe',\n            timeout: 60000,\n            env: { ...process.env, OMC_UPDATE_RECONCILE: '1' }\n          });\n        } catch (reconcileError) {\n          return {\n            success: false,\n            previousVersion,\n            newVersion,\n            message: `Updated to ${newVersion}, but runtime reconciliation failed`,\n            errors: [reconcileError instanceof Error ? reconcileError.message : String(reconcileError)],\n          };\n        }\n\n        // Update version metadata after reconciliation succeeds\n        saveVersionMetadata({\n          version: newVersion,\n          installedAt: new Date().toISOString(),\n          installMethod: 'npm',\n          lastCheckAt: new Date().toISOString()\n        });\n\n        return {\n          success: true,\n          previousVersion,\n          newVersion,\n          message: `Successfully updated from ${previousVersion ?? 'unknown'} to ${newVersion}`\n        };\n      } else {\n        // We're in the re-exec'd process - run reconciliation directly\n        const reconcileResult = reconcileUpdateRuntime({ verbose: options?.verbose });\n        if (!reconcileResult.success) {\n          return {\n            success: false,\n            previousVersion,\n            newVersion,\n            message: `Updated to ${newVersion}, but runtime reconciliation failed`,\n            errors: reconcileResult.errors?.map(e => `Reconciliation failed: ${e}`),\n          };\n        }\n        return {\n          success: true,\n          previousVersion,\n          newVersion,\n          message: 'Reconciliation completed successfully'\n        };\n      }\n    } catch (npmError) {\n      throw new Error(\n        'Auto-update via npm failed. Please run manually:\\n' +\n        '  npm install -g @liangjie559567/ultrapower@latest\\n' +\n        'Or use: /plugin install ultrapower\\n' +\n        `Error: ${npmError instanceof Error ? npmError.message : npmError}`\n      );\n    }\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    return {\n      success: false,\n      previousVersion,\n      newVersion: 'unknown',\n      message: `Update failed: ${errorMessage}`,\n      errors: [errorMessage]\n    };\n  }\n}\n\n/**\n * Get a formatted update notification message\n */\nexport function formatUpdateNotification(checkResult: UpdateCheckResult): string {\n  if (!checkResult.updateAvailable) {\n    return `ultrapower is up to date (v${checkResult.currentVersion ?? 'unknown'})`;\n  }\n\n  const lines = [\n    '',\n    '           ultrapower Update Available!              ',\n    '',\n    '',\n    `  Current version: ${checkResult.currentVersion ?? 'unknown'}`,\n    `  Latest version:  ${checkResult.latestVersion}`,\n    '',\n    '  To update, run: /update',\n    '  Or reinstall via: /plugin install ultrapower',\n    ''\n  ];\n\n  // Add truncated release notes if available\n  if (checkResult.releaseNotes && checkResult.releaseNotes !== 'No release notes available.') {\n    lines.push('  Release notes:');\n    const notes = checkResult.releaseNotes.split('\\n').slice(0, 5);\n    notes.forEach(line => lines.push(`    ${line}`));\n    if (checkResult.releaseNotes.split('\\n').length > 5) {\n      lines.push('    ...');\n    }\n    lines.push('');\n  }\n\n  return lines.join('\\n');\n}\n\n/**\n * Check if enough time has passed since the last update check\n */\nexport function shouldCheckForUpdates(intervalHours: number = 24): boolean {\n  const installed = getInstalledVersion();\n\n  if (!installed?.lastCheckAt) {\n    return true;\n  }\n\n  const lastCheck = new Date(installed.lastCheckAt).getTime();\n  const now = Date.now();\n  const hoursSinceLastCheck = (now - lastCheck) / (1000 * 60 * 60);\n\n  return hoursSinceLastCheck >= intervalHours;\n}\n\n/**\n * Perform a background update check (non-blocking)\n */\nexport function backgroundUpdateCheck(callback?: (result: UpdateCheckResult) => void): void {\n  if (!shouldCheckForUpdates()) {\n    return;\n  }\n\n  // Run the check asynchronously without blocking\n  checkForUpdates()\n    .then(result => {\n      if (callback) {\n        callback(result);\n      } else if (result.updateAvailable) {\n        // Default behavior: print notification to console\n        console.log('\\n' + formatUpdateNotification(result));\n      }\n    })\n    .catch(error => {\n      // Silently ignore errors in background checks\n      if (process.env.OMC_DEBUG) {\n        console.error('Background update check failed:', error);\n      }\n    });\n}\n\n/**\n * CLI helper: perform interactive update\n */\nexport async function interactiveUpdate(): Promise<void> {\n  console.log('Checking for updates...');\n\n  try {\n    const checkResult = await checkForUpdates();\n\n    if (!checkResult.updateAvailable) {\n      console.log(` You are running the latest version (${checkResult.currentVersion})`);\n      return;\n    }\n\n    console.log(formatUpdateNotification(checkResult));\n    console.log('Starting update...\\n');\n\n    const result = await performUpdate({ verbose: true });\n\n    if (result.success) {\n      console.log(`\\n ${result.message}`);\n      console.log('\\nPlease restart your Claude Code session to use the new version.');\n    } else {\n      console.error(`\\n ${result.message}`);\n      if (result.errors) {\n        result.errors.forEach(err => console.error(`  - ${err}`));\n      }\n      process.exit(1);\n    }\n  } catch (error) {\n    console.error('Update check failed:', error instanceof Error ? error.message : error);\n    process.exit(1);\n  }\n}\n\n/**\n * Silent auto-update configuration\n */\nexport interface SilentUpdateConfig {\n  /** Minimum hours between update checks (default: 24) */\n  checkIntervalHours?: number;\n  /** Whether to auto-apply updates without confirmation (default: true) */\n  autoApply?: boolean;\n  /** Log file path for silent update activity (optional) */\n  logFile?: string;\n  /** Maximum retries on failure (default: 3) */\n  maxRetries?: number;\n}\n\n/** State file for tracking silent update status */\nconst SILENT_UPDATE_STATE_FILE = join(CLAUDE_CONFIG_DIR, '.omc-silent-update.json');\n\ninterface SilentUpdateState {\n  lastAttempt?: string;\n  lastSuccess?: string;\n  consecutiveFailures: number;\n  pendingRestart: boolean;\n  lastVersion?: string;\n}\n\n/**\n * Read silent update state\n */\nfunction getSilentUpdateState(): SilentUpdateState {\n  if (!existsSync(SILENT_UPDATE_STATE_FILE)) {\n    return { consecutiveFailures: 0, pendingRestart: false };\n  }\n  try {\n    return JSON.parse(readFileSync(SILENT_UPDATE_STATE_FILE, 'utf-8'));\n  } catch {\n    return { consecutiveFailures: 0, pendingRestart: false };\n  }\n}\n\n/**\n * Save silent update state\n */\nfunction saveSilentUpdateState(state: SilentUpdateState): void {\n  const dir = dirname(SILENT_UPDATE_STATE_FILE);\n  if (!existsSync(dir)) {\n    mkdirSync(dir, { recursive: true });\n  }\n  writeFileSync(SILENT_UPDATE_STATE_FILE, JSON.stringify(state, null, 2));\n}\n\n/**\n * Log message to silent update log file (if configured)\n */\nfunction silentLog(message: string, logFile?: string): void {\n  const timestamp = new Date().toISOString();\n  const logMessage = `[${timestamp}] ${message}\\n`;\n\n  if (logFile) {\n    try {\n      const dir = dirname(logFile);\n      if (!existsSync(dir)) {\n        mkdirSync(dir, { recursive: true });\n      }\n      writeFileSync(logFile, logMessage, { flag: 'a' });\n    } catch {\n      // Silently ignore log errors\n    }\n  }\n}\n\n/**\n * Perform a completely silent update check and installation\n *\n * This function runs without any user interaction or console output.\n * It's designed to be called from hooks or startup scripts to keep\n * the system updated automatically without user awareness.\n *\n * Features:\n * - Rate-limited to prevent excessive checks\n * - Exponential backoff on failures\n * - Optional logging to file for debugging\n * - Tracks pending restart state\n *\n * @param config - Silent update configuration\n * @returns Promise resolving to update result or null if skipped\n */\nexport async function silentAutoUpdate(config: SilentUpdateConfig = {}): Promise<UpdateResult | null> {\n  const {\n    checkIntervalHours = 24,\n    autoApply = true,\n    logFile = join(CLAUDE_CONFIG_DIR, '.omc-update.log'),\n    maxRetries = 3\n  } = config;\n\n  // SECURITY: Check if silent auto-update is enabled in configuration\n  // Default is disabled - users must explicitly opt-in during installation\n  if (!isSilentAutoUpdateEnabled()) {\n    silentLog('Silent auto-update is disabled (run installer to enable, or use /update)', logFile);\n    return null;\n  }\n\n  const state = getSilentUpdateState();\n\n  // Check rate limiting\n  if (!shouldCheckForUpdates(checkIntervalHours)) {\n    return null;\n  }\n\n  // Check for consecutive failures and apply exponential backoff\n  if (state.consecutiveFailures >= maxRetries) {\n    const backoffHours = Math.min(24 * state.consecutiveFailures, 168); // Max 1 week\n    const lastAttempt = state.lastAttempt ? new Date(state.lastAttempt).getTime() : 0;\n    const hoursSinceLastAttempt = (Date.now() - lastAttempt) / (1000 * 60 * 60);\n\n    if (hoursSinceLastAttempt < backoffHours) {\n      silentLog(`Skipping update check (in backoff period: ${backoffHours}h)`, logFile);\n      return null;\n    }\n  }\n\n  silentLog('Starting silent update check...', logFile);\n  state.lastAttempt = new Date().toISOString();\n\n  try {\n    // Check for updates\n    const checkResult = await checkForUpdates();\n\n    if (!checkResult.updateAvailable) {\n      silentLog(`No update available (current: ${checkResult.currentVersion})`, logFile);\n      state.consecutiveFailures = 0;\n      state.pendingRestart = false;\n      saveSilentUpdateState(state);\n      return null;\n    }\n\n    silentLog(`Update available: ${checkResult.currentVersion} -> ${checkResult.latestVersion}`, logFile);\n\n    if (!autoApply) {\n      silentLog('Auto-apply disabled, skipping installation', logFile);\n      return null;\n    }\n\n    // Perform the update silently\n    const result = await performUpdate({\n      skipConfirmation: true,\n      verbose: false\n    });\n\n    if (result.success) {\n      silentLog(`Update successful: ${result.previousVersion} -> ${result.newVersion}`, logFile);\n      state.consecutiveFailures = 0;\n      state.pendingRestart = true;\n      state.lastSuccess = new Date().toISOString();\n      state.lastVersion = result.newVersion;\n      saveSilentUpdateState(state);\n      return result;\n    } else {\n      silentLog(`Update failed: ${result.message}`, logFile);\n      state.consecutiveFailures++;\n      saveSilentUpdateState(state);\n      return result;\n    }\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    silentLog(`Update check error: ${errorMessage}`, logFile);\n    state.consecutiveFailures++;\n    saveSilentUpdateState(state);\n    return {\n      success: false,\n      previousVersion: null,\n      newVersion: 'unknown',\n      message: `Silent update failed: ${errorMessage}`,\n      errors: [errorMessage]\n    };\n  }\n}\n\n/**\n * Check if there's a pending restart after a silent update\n */\nexport function hasPendingUpdateRestart(): boolean {\n  const state = getSilentUpdateState();\n  return state.pendingRestart;\n}\n\n/**\n * Clear the pending restart flag (call after notifying user or restart)\n */\nexport function clearPendingUpdateRestart(): void {\n  const state = getSilentUpdateState();\n  state.pendingRestart = false;\n  saveSilentUpdateState(state);\n}\n\n/**\n * Get the version that was silently updated to (if pending restart)\n */\nexport function getPendingUpdateVersion(): string | null {\n  const state = getSilentUpdateState();\n  return state.pendingRestart ? (state.lastVersion ?? null) : null;\n}\n\n/**\n * Initialize silent auto-update on startup\n *\n * This is the main entry point for the silent update system.\n * Call this function once when the application starts or from a hook.\n * It runs the update check completely in the background without blocking.\n *\n * @param config - Silent update configuration\n */\nexport function initSilentAutoUpdate(config: SilentUpdateConfig = {}): void {\n  // Run update check in background without blocking\n  silentAutoUpdate(config).catch(() => {\n    // Silently ignore any errors - they're already logged\n  });\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\background-agent\\concurrency.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\background-agent\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\background-agent\\manager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\background-agent\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\background-tasks.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\boulder-state\\constants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\boulder-state\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\boulder-state\\storage.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\boulder-state\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\builtin-skills\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\builtin-skills\\skills.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\builtin-skills\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\context-injector\\collector.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\context-injector\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\context-injector\\injector.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\context-injector\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\continuation-enforcement.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\delegation-categories\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\delegation-categories\\test-categories.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\delegation-categories\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\delegation-enforcer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\delegation-routing\\__tests__\\resolver.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\delegation-routing\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\delegation-routing\\resolver.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\delegation-routing\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\error-log\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\magic-keywords.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\model-routing\\__tests__\\external-model-policy.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\model-routing\\external-model-policy.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\model-routing\\index.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":1,"message":"A `require()` style import is forbidden.","line":103,"column":35,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":103,"endColumn":57,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-require-imports","severity":1,"message":"A `require()` style import is forbidden.","line":105,"column":34,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":105,"endColumn":63,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\model-routing\\prompts\\haiku.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\model-routing\\prompts\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\model-routing\\prompts\\opus.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\model-routing\\prompts\\sonnet.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\model-routing\\router.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\model-routing\\rules.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":24,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":24,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[593,596],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[593,596],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Routing Rules\n *\n * Defines the rules engine for model routing decisions.\n * Rules are evaluated in priority order, and the first matching rule wins.\n */\n\nimport type {\n  RoutingRule,\n  RoutingContext,\n  ComplexitySignals,\n  ComplexityTier,\n} from './types.js';\n\n/**\n * Default routing rules, ordered by priority (highest first)\n */\nexport const DEFAULT_ROUTING_RULES: RoutingRule[] = [\n  // ============ Override Rules (Highest Priority) ============\n\n  {\n    name: 'explicit-model-specified',\n    condition: (ctx) => ctx.explicitModel !== undefined,\n    action: { tier: 'EXPLICIT' as any, reason: 'User specified model explicitly' },\n    priority: 100,\n  },\n\n  // NOTE: ALL agents are now ADAPTIVE based on task complexity\n  // This includes: architect, planner, critic, analyst, explore, writer, etc.\n\n  // ============ Advisory Agent Adaptive Rules ============\n\n  // Architect: Simple lookups  LOW, tracing  MEDIUM, debugging/architecture  HIGH\n  // Higher priority (85) to override generic rules like short-local-change\n  {\n    name: 'architect-complex-debugging',\n    condition: (ctx, signals) =>\n      ctx.agentType === 'architect' &&\n      (signals.lexical.hasDebuggingKeywords ||\n       signals.lexical.hasArchitectureKeywords ||\n       signals.lexical.hasRiskKeywords),\n    action: { tier: 'HIGH', reason: 'Architect: Complex debugging/architecture decision' },\n    priority: 85,\n  },\n\n  {\n    name: 'architect-simple-lookup',\n    condition: (ctx, signals) =>\n      ctx.agentType === 'architect' &&\n      signals.lexical.hasSimpleKeywords &&\n      !signals.lexical.hasDebuggingKeywords &&\n      !signals.lexical.hasArchitectureKeywords &&\n      !signals.lexical.hasRiskKeywords,\n    action: { tier: 'LOW', reason: 'Architect: Simple lookup query' },\n    priority: 80,\n  },\n\n  // Planner: Simple breakdown  LOW, moderate planning  MEDIUM, cross-domain  HIGH\n  {\n    name: 'planner-simple-breakdown',\n    condition: (ctx, signals) =>\n      ctx.agentType === 'planner' &&\n      signals.structural.estimatedSubtasks <= 3 &&\n      !signals.lexical.hasRiskKeywords &&\n      signals.structural.impactScope === 'local',\n    action: { tier: 'LOW', reason: 'Planner: Simple task breakdown' },\n    priority: 75,\n  },\n\n  {\n    name: 'planner-strategic-planning',\n    condition: (ctx, signals) =>\n      ctx.agentType === 'planner' &&\n      (signals.structural.impactScope === 'system-wide' ||\n       signals.lexical.hasArchitectureKeywords ||\n       signals.structural.estimatedSubtasks > 10),\n    action: { tier: 'HIGH', reason: 'Planner: Cross-domain strategic planning' },\n    priority: 75,\n  },\n\n  // Critic: Checklist  LOW, gap analysis  MEDIUM, adversarial review  HIGH\n  {\n    name: 'critic-checklist-review',\n    condition: (ctx, signals) =>\n      ctx.agentType === 'critic' &&\n      signals.lexical.wordCount < 30 &&\n      !signals.lexical.hasRiskKeywords,\n    action: { tier: 'LOW', reason: 'Critic: Checklist verification' },\n    priority: 75,\n  },\n\n  {\n    name: 'critic-adversarial-review',\n    condition: (ctx, signals) =>\n      ctx.agentType === 'critic' &&\n      (signals.lexical.hasRiskKeywords || signals.structural.impactScope === 'system-wide'),\n    action: { tier: 'HIGH', reason: 'Critic: Adversarial review for critical system' },\n    priority: 75,\n  },\n\n  // Analyst: Simple impact  LOW, dependency mapping  MEDIUM, risk analysis  HIGH\n  {\n    name: 'analyst-simple-impact',\n    condition: (ctx, signals) =>\n      ctx.agentType === 'analyst' &&\n      signals.structural.impactScope === 'local' &&\n      !signals.lexical.hasRiskKeywords,\n    action: { tier: 'LOW', reason: 'Analyst: Simple impact analysis' },\n    priority: 75,\n  },\n\n  {\n    name: 'analyst-risk-analysis',\n    condition: (ctx, signals) =>\n      ctx.agentType === 'analyst' &&\n      (signals.lexical.hasRiskKeywords || signals.structural.impactScope === 'system-wide'),\n    action: { tier: 'HIGH', reason: 'Analyst: Risk analysis and unknown-unknowns detection' },\n    priority: 75,\n  },\n\n  // ============ Task-Based Rules ============\n\n  {\n    name: 'architecture-system-wide',\n    condition: (ctx, signals) =>\n      signals.lexical.hasArchitectureKeywords &&\n      signals.structural.impactScope === 'system-wide',\n    action: { tier: 'HIGH', reason: 'Architectural decisions with system-wide impact' },\n    priority: 70,\n  },\n\n  {\n    name: 'security-domain',\n    condition: (ctx, signals) =>\n      signals.structural.domainSpecificity === 'security',\n    action: { tier: 'HIGH', reason: 'Security-related tasks require careful reasoning' },\n    priority: 70,\n  },\n\n  {\n    name: 'difficult-reversibility-risk',\n    condition: (ctx, signals) =>\n      signals.structural.reversibility === 'difficult' &&\n      signals.lexical.hasRiskKeywords,\n    action: { tier: 'HIGH', reason: 'High-risk, difficult-to-reverse changes' },\n    priority: 70,\n  },\n\n  {\n    name: 'deep-debugging',\n    condition: (ctx, signals) =>\n      signals.lexical.hasDebuggingKeywords &&\n      signals.lexical.questionDepth === 'why',\n    action: { tier: 'HIGH', reason: 'Root cause analysis requires deep reasoning' },\n    priority: 65,\n  },\n\n  {\n    name: 'complex-multi-step',\n    condition: (ctx, signals) =>\n      signals.structural.estimatedSubtasks > 5 &&\n      signals.structural.crossFileDependencies,\n    action: { tier: 'HIGH', reason: 'Complex multi-step task with cross-file changes' },\n    priority: 60,\n  },\n\n  {\n    name: 'simple-search-query',\n    condition: (ctx, signals) =>\n      signals.lexical.hasSimpleKeywords &&\n      signals.structural.estimatedSubtasks <= 1 &&\n      signals.structural.impactScope === 'local' &&\n      !signals.lexical.hasArchitectureKeywords &&\n      !signals.lexical.hasDebuggingKeywords,\n    action: { tier: 'LOW', reason: 'Simple search or lookup task' },\n    priority: 60,\n  },\n\n  {\n    name: 'short-local-change',\n    condition: (ctx, signals) =>\n      signals.lexical.wordCount < 50 &&\n      signals.structural.impactScope === 'local' &&\n      signals.structural.reversibility === 'easy' &&\n      !signals.lexical.hasRiskKeywords,\n    action: { tier: 'LOW', reason: 'Short, local, easily reversible change' },\n    priority: 55,\n  },\n\n  {\n    name: 'moderate-complexity',\n    condition: (ctx, signals) =>\n      signals.structural.estimatedSubtasks > 1 &&\n      signals.structural.estimatedSubtasks <= 5,\n    action: { tier: 'MEDIUM', reason: 'Moderate complexity with multiple subtasks' },\n    priority: 50,\n  },\n\n  {\n    name: 'module-level-work',\n    condition: (ctx, signals) =>\n      signals.structural.impactScope === 'module',\n    action: { tier: 'MEDIUM', reason: 'Module-level changes' },\n    priority: 45,\n  },\n\n  // ============ Default Rule ============\n\n  {\n    name: 'default-medium',\n    condition: () => true,\n    action: { tier: 'MEDIUM', reason: 'Default tier for unclassified tasks' },\n    priority: 0,\n  },\n];\n\n/**\n * Evaluate routing rules and return the first matching rule's action\n */\nexport function evaluateRules(\n  context: RoutingContext,\n  signals: ComplexitySignals,\n  rules: RoutingRule[] = DEFAULT_ROUTING_RULES\n): { tier: ComplexityTier | 'EXPLICIT'; reason: string; ruleName: string } {\n  // Sort rules by priority (highest first)\n  const sortedRules = [...rules].sort((a, b) => b.priority - a.priority);\n\n  for (const rule of sortedRules) {\n    if (rule.condition(context, signals)) {\n      return {\n        tier: rule.action.tier,\n        reason: rule.action.reason,\n        ruleName: rule.name,\n      };\n    }\n  }\n\n  // Should never reach here due to default rule, but just in case\n  return {\n    tier: 'MEDIUM',\n    reason: 'Fallback to medium tier',\n    ruleName: 'fallback',\n  };\n}\n\n/**\n * Get all rules that would match for a given context (for debugging)\n */\nexport function getMatchingRules(\n  context: RoutingContext,\n  signals: ComplexitySignals,\n  rules: RoutingRule[] = DEFAULT_ROUTING_RULES\n): RoutingRule[] {\n  return rules.filter(rule => rule.condition(context, signals));\n}\n\n/**\n * Create a custom routing rule\n */\nexport function createRule(\n  name: string,\n  condition: (context: RoutingContext, signals: ComplexitySignals) => boolean,\n  tier: ComplexityTier,\n  reason: string,\n  priority: number\n): RoutingRule {\n  return {\n    name,\n    condition,\n    action: { tier, reason },\n    priority,\n  };\n}\n\n/**\n * Merge custom rules with default rules\n */\nexport function mergeRules(customRules: RoutingRule[]): RoutingRule[] {\n  // Custom rules override defaults with the same name\n  const customNames = new Set(customRules.map(r => r.name));\n  const filteredDefaults = DEFAULT_ROUTING_RULES.filter(\n    r => !customNames.has(r.name)\n  );\n  return [...customRules, ...filteredDefaults];\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\model-routing\\scorer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\model-routing\\signals.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\model-routing\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\notepad-wisdom\\extractor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\notepad-wisdom\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\notepad-wisdom\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\rate-limit-wait\\daemon.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\rate-limit-wait\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\rate-limit-wait\\rate-limit-monitor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\rate-limit-wait\\tmux-detector.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\rate-limit-wait\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\state-manager\\__tests__\\cache.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\state-manager\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\state-manager\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\task-decomposer\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\task-decomposer\\types.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":187,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":187,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3880,3883],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3880,3883],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Task Decomposer Types\n *\n * Types for analyzing tasks and decomposing them into parallelizable\n * components with file ownership management.\n */\n\nexport type TaskType =\n  | 'fullstack-app'\n  | 'refactoring'\n  | 'bug-fix'\n  | 'feature'\n  | 'testing'\n  | 'documentation'\n  | 'infrastructure'\n  | 'migration'\n  | 'optimization'\n  | 'unknown';\n\nexport type ComponentRole =\n  | 'frontend'\n  | 'backend'\n  | 'database'\n  | 'api'\n  | 'ui'\n  | 'shared'\n  | 'testing'\n  | 'docs'\n  | 'config'\n  | 'module';\n\nexport interface TaskAnalysis {\n  /** Original task description */\n  task: string;\n\n  /** Detected task type */\n  type: TaskType;\n\n  /** Task complexity score (0-1) */\n  complexity: number;\n\n  /** Whether task can be parallelized */\n  isParallelizable: boolean;\n\n  /** Estimated number of components */\n  estimatedComponents: number;\n\n  /** Key areas identified in the task */\n  areas: string[];\n\n  /** Technologies/frameworks mentioned */\n  technologies: string[];\n\n  /** File patterns mentioned or inferred */\n  filePatterns: string[];\n\n  /** Dependencies between areas */\n  dependencies: Array<{ from: string; to: string }>;\n}\n\nexport interface Component {\n  /** Unique component ID */\n  id: string;\n\n  /** Component name */\n  name: string;\n\n  /** Component role/type */\n  role: ComponentRole;\n\n  /** Description of what this component does */\n  description: string;\n\n  /** Whether this component can run in parallel */\n  canParallelize: boolean;\n\n  /** Components this depends on (must complete first) */\n  dependencies: string[];\n\n  /** Estimated effort/complexity (0-1) */\n  effort: number;\n\n  /** Technologies used by this component */\n  technologies: string[];\n}\n\nexport interface FileOwnership {\n  /** Component ID that owns these files */\n  componentId: string;\n\n  /** Glob patterns for files this component owns exclusively */\n  patterns: string[];\n\n  /** Specific files (non-glob) this component owns */\n  files: string[];\n\n  /** Files that might overlap with other components */\n  potentialConflicts: string[];\n}\n\nexport interface Subtask {\n  /** Unique subtask ID */\n  id: string;\n\n  /** Subtask name */\n  name: string;\n\n  /** Component this subtask implements */\n  component: Component;\n\n  /** Detailed prompt for worker agent */\n  prompt: string;\n\n  /** File ownership for this subtask */\n  ownership: FileOwnership;\n\n  /** Subtasks that must complete before this one */\n  blockedBy: string[];\n\n  /** Recommended agent type */\n  agentType: string;\n\n  /** Recommended model tier */\n  modelTier: 'low' | 'medium' | 'high';\n\n  /** Acceptance criteria */\n  acceptanceCriteria: string[];\n\n  /** Verification steps */\n  verification: string[];\n}\n\nexport interface SharedFile {\n  /** File path or glob pattern */\n  pattern: string;\n\n  /** Why this file is shared */\n  reason: string;\n\n  /** Components that need access to this file */\n  sharedBy: string[];\n\n  /** Whether orchestration is required for this file */\n  requiresOrchestration: boolean;\n}\n\nexport interface DecompositionResult {\n  /** Original task analysis */\n  analysis: TaskAnalysis;\n\n  /** Identified components */\n  components: Component[];\n\n  /** Generated subtasks with ownership */\n  subtasks: Subtask[];\n\n  /** Shared files requiring orchestration */\n  sharedFiles: SharedFile[];\n\n  /** Recommended execution order (by subtask ID) */\n  executionOrder: string[][];\n\n  /** Overall strategy description */\n  strategy: string;\n\n  /** Warnings or issues detected */\n  warnings: string[];\n}\n\nexport interface ProjectContext {\n  /** Project root directory */\n  rootDir: string;\n\n  /** Project type (detected) */\n  projectType?: string;\n\n  /** Technologies in use */\n  technologies?: string[];\n\n  /** Directory structure */\n  structure?: Record<string, string[]>;\n\n  /** Existing files that might be affected */\n  existingFiles?: string[];\n\n  /** Framework conventions */\n  conventions?: Record<string, any>;\n}\n\nexport interface DecompositionStrategy {\n  /** Strategy name */\n  name: string;\n\n  /** Task types this strategy applies to */\n  applicableTypes: TaskType[];\n\n  /** Function to decompose task */\n  decompose: (\n    analysis: TaskAnalysis,\n    context: ProjectContext\n  ) => {\n    components: Component[];\n    sharedFiles: SharedFile[];\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\verification\\example.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\verification\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\features\\verification\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\__tests__\\askuserquestion-lifecycle.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\__tests__\\background-process-guard.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\__tests__\\bridge-pkill.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\__tests__\\bridge-routing.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\__tests__\\bridge-security.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\__tests__\\bridge.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\__tests__\\compaction-concurrency.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\agent-usage-reminder\\constants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\agent-usage-reminder\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\agent-usage-reminder\\storage.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\agent-usage-reminder\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\auto-slash-command\\constants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\auto-slash-command\\detector.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\auto-slash-command\\executor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\auto-slash-command\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\auto-slash-command\\live-data.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\auto-slash-command\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\autopilot\\__tests__\\cancel.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\autopilot\\__tests__\\prompts.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\autopilot\\__tests__\\state.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\autopilot\\__tests__\\summary.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\autopilot\\__tests__\\transition.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\autopilot\\__tests__\\transitions.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\autopilot\\__tests__\\validation.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\autopilot\\cancel.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\autopilot\\enforcement.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\autopilot\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\autopilot\\prompts.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\autopilot\\state.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\autopilot\\transition-helper.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\autopilot\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\autopilot\\validation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\axiom-boot\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\axiom-boot\\storage.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\axiom-boot\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\axiom-guards\\constants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\axiom-guards\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\axiom-guards\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\background-notification\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\background-notification\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\beads-context\\__tests__\\index.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\beads-context\\constants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\beads-context\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\beads-context\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\bridge-normalize.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\bridge.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\comment-checker\\constants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\comment-checker\\filters.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\comment-checker\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\comment-checker\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\directory-readme-injector\\constants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\directory-readme-injector\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\directory-readme-injector\\storage.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\directory-readme-injector\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\empty-message-sanitizer\\__tests__\\index.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\empty-message-sanitizer\\constants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\empty-message-sanitizer\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\empty-message-sanitizer\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\guards\\post-tool.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\guards\\pre-tool.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\guards\\session-watchdog.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\guards\\status-dashboard.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\keyword-detector\\__tests__\\index.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\keyword-detector\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\learner\\auto-invoke.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\learner\\auto-learner.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\learner\\bridge.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\learner\\confidence.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\learner\\config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\learner\\constants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\learner\\detection-hook.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\learner\\detector.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\learner\\finder.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\learner\\harvester.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\learner\\index-manager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\learner\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\learner\\learning-queue.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\learner\\loader.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\learner\\matcher.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\learner\\metrics.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\learner\\orchestrator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\learner\\parser.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\learner\\pattern-detector.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\learner\\promotion.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\learner\\reflection.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\learner\\seed-knowledge.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\learner\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\learner\\validator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\learner\\writer.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":1,"message":"A `require()` style import is forbidden.","line":140,"column":29,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":140,"endColumn":51,"suppressions":[{"kind":"directive","justification":"avoid circular dependency with loader"}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\memory\\constants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\memory\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\memory\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\mode-registry\\__tests__\\session-isolation.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\mode-registry\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\mode-registry\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\non-interactive-env\\constants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\non-interactive-env\\detector.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\non-interactive-env\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\non-interactive-env\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\notepad\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\omc-orchestrator\\audit.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\omc-orchestrator\\constants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\omc-orchestrator\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\permission-handler\\__tests__\\index.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\permission-handler\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\persistent-mode\\__tests__\\error-handling.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\persistent-mode\\__tests__\\ralph-max-iteration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\persistent-mode\\__tests__\\tool-error.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\persistent-mode\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\persistent-mode\\session-isolation.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\plugin-patterns\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\pre-compact\\index.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":176,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":176,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5386,5389],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5386,5389],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":184,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":184,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5593,5596],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5593,5596],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":195,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":195,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5857,5860],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5857,5860],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":203,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":203,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6055,6058],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6055,6058],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":214,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":214,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6317,6320],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6317,6320],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":225,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":225,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6573,6576],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6573,6576],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":236,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":236,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6827,6830],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6827,6830],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":291,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":291,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8251,8254],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8251,8254],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":292,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":292,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8333,8336],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8333,8336],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":294,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":294,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8432,8435],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8432,8435],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * PreCompact Hook - State Preservation Before Context Compaction\n *\n * Creates checkpoints before compaction to preserve critical state including:\n * - Active mode states (autopilot, ralph, ultrawork, swarm)\n * - TODO summary\n * - Wisdom from notepads\n *\n * This ensures no critical information is lost during context window compaction.\n */\n\nimport {\n  existsSync,\n  readFileSync,\n  writeFileSync,\n  mkdirSync,\n  readdirSync,\n  statSync,\n} from \"fs\";\nimport { promises as fsPromises } from \"fs\";\nimport { join } from \"path\";\nimport { initJobDb, getActiveJobs, getRecentJobs, getJobStats, closeJobDb } from '../../mcp/job-state-db.js';\n\n// ============================================================================\n// Types\n// ============================================================================\n\nexport interface PreCompactInput {\n  session_id: string;\n  transcript_path: string;\n  cwd: string;\n  permission_mode: string;\n  hook_event_name: \"PreCompact\";\n  trigger: \"manual\" | \"auto\";\n  custom_instructions?: string;\n}\n\nexport interface CompactCheckpoint {\n  created_at: string;\n  trigger: \"manual\" | \"auto\";\n  active_modes: {\n    autopilot?: { phase: string; originalIdea: string };\n    ralph?: { iteration: number; prompt: string };\n    ultrawork?: { original_prompt: string };\n    swarm?: { session_id: string; task_count: number };\n    ultrapilot?: { session_id: string; worker_count: number };\n    pipeline?: { preset: string; current_stage: number };\n    ultraqa?: { cycle: number; prompt: string };\n  };\n  todo_summary: {\n    pending: number;\n    in_progress: number;\n    completed: number;\n  };\n  wisdom_exported: boolean;\n  background_jobs?: {\n    active: Array<{ jobId: string; provider: string; model: string; agentRole: string; spawnedAt: string }>;\n    recent: Array<{ jobId: string; provider: string; status: string; agentRole: string; completedAt?: string }>;\n    stats: { total: number; active: number; completed: number; failed: number } | null;\n  };\n}\n\nexport interface HookOutput {\n  continue: boolean;\n  /** System message for context injection (Claude Code compatible) */\n  systemMessage?: string;\n}\n\n// ============================================================================\n// Constants\n// ============================================================================\n\nconst CHECKPOINT_DIR = \"checkpoints\";\n\n// ============================================================================\n// Compaction Mutex - prevents concurrent compaction for the same directory\n// ============================================================================\n\n/**\n * Per-directory in-flight compaction promises.\n * When a compaction is already running for a directory, new callers\n * await the existing promise instead of running concurrently.\n * This prevents race conditions when multiple subagent results\n * arrive simultaneously (swarm/ultrawork).\n */\nconst inflightCompactions = new Map<string, Promise<HookOutput>>();\n\n/**\n * Queue depth counter per directory for diagnostics.\n * Tracks how many callers are waiting on an in-flight compaction.\n */\nconst compactionQueueDepth = new Map<string, number>();\n\n// ============================================================================\n// Helper Functions\n// ============================================================================\n\n/**\n * Get the checkpoint directory path\n */\nexport function getCheckpointPath(directory: string): string {\n  const checkpointDir = join(directory, \".omc\", \"state\", CHECKPOINT_DIR);\n  if (!existsSync(checkpointDir)) {\n    mkdirSync(checkpointDir, { recursive: true });\n  }\n  return checkpointDir;\n}\n\n/**\n * Export wisdom from notepads to checkpoint\n */\nexport async function exportWisdomToNotepad(\n  directory: string,\n): Promise<{ wisdom: string; exported: boolean }> {\n  const notepadsDir = join(directory, \".omc\", \"notepads\");\n\n  if (!existsSync(notepadsDir)) {\n    return { wisdom: \"\", exported: false };\n  }\n\n  const wisdomParts: string[] = [];\n  let hasWisdom = false;\n\n  try {\n    // Read all plan directories\n    const planDirs = readdirSync(notepadsDir).filter((name) => {\n      const path = join(notepadsDir, name);\n      return statSync(path).isDirectory();\n    });\n\n    for (const planDir of planDirs) {\n      const planPath = join(notepadsDir, planDir);\n      const wisdomFiles = [\n        \"learnings.md\",\n        \"decisions.md\",\n        \"issues.md\",\n        \"problems.md\",\n      ];\n\n      for (const wisdomFile of wisdomFiles) {\n        const wisdomPath = join(planPath, wisdomFile);\n        if (existsSync(wisdomPath)) {\n          const content = readFileSync(wisdomPath, \"utf-8\").trim();\n          if (content) {\n            wisdomParts.push(`### ${planDir}/${wisdomFile}\\n${content}`);\n            hasWisdom = true;\n          }\n        }\n      }\n    }\n  } catch (error) {\n    console.error(\"[PreCompact] Error reading wisdom files:\", error);\n  }\n\n  const wisdom =\n    wisdomParts.length > 0\n      ? `## Plan Wisdom\\n\\n${wisdomParts.join(\"\\n\\n\")}`\n      : \"\";\n\n  return { wisdom, exported: hasWisdom };\n}\n\n/**\n * Save summary of active modes\n */\nexport async function saveModeSummary(\n  directory: string,\n): Promise<Record<string, unknown>> {\n  const stateDir = join(directory, \".omc\", \"state\");\n  const modes: Record<string, unknown> = {};\n\n  const stateFiles = [\n    {\n      file: \"autopilot-state.json\",\n      key: \"autopilot\",\n      extract: (s: any) =>\n        s.active\n          ? { phase: s.phase || \"unknown\", originalIdea: s.originalIdea || \"\" }\n          : null,\n    },\n    {\n      file: \"ralph-state.json\",\n      key: \"ralph\",\n      extract: (s: any) =>\n        s.active\n          ? {\n              iteration: s.iteration || 0,\n              prompt: s.originalPrompt || s.prompt || \"\",\n            }\n          : null,\n    },\n    {\n      file: \"ultrawork-state.json\",\n      key: \"ultrawork\",\n      extract: (s: any) =>\n        s.active\n          ? { original_prompt: s.original_prompt || s.prompt || \"\" }\n          : null,\n    },\n    {\n      file: \"swarm-summary.json\",\n      key: \"swarm\",\n      extract: (s: any) =>\n        s.active\n          ? {\n              session_id: s.session_id || \"active\",\n              task_count: s.task_count || 0,\n            }\n          : null,\n    },\n    {\n      file: \"ultrapilot-state.json\",\n      key: \"ultrapilot\",\n      extract: (s: any) =>\n        s.active\n          ? {\n              session_id: s.session_id || \"\",\n              worker_count: s.worker_count || 0,\n            }\n          : null,\n    },\n    {\n      file: \"pipeline-state.json\",\n      key: \"pipeline\",\n      extract: (s: any) =>\n        s.active\n          ? {\n              preset: s.preset || \"custom\",\n              current_stage: s.current_stage || 0,\n            }\n          : null,\n    },\n    {\n      file: \"ultraqa-state.json\",\n      key: \"ultraqa\",\n      extract: (s: any) =>\n        s.active\n          ? { cycle: s.cycle || 0, prompt: s.original_prompt || s.prompt || \"\" }\n          : null,\n    },\n  ];\n\n  const reads = stateFiles.map(async (config) => {\n    const path = join(stateDir, config.file);\n    try {\n      const content = await fsPromises.readFile(path, \"utf-8\");\n      const state = JSON.parse(content);\n      const extracted = config.extract(state);\n      return extracted ? { key: config.key, value: extracted } : null;\n    } catch (error: unknown) {\n      if ((error as NodeJS.ErrnoException).code === \"ENOENT\") {\n        return null;\n      }\n      console.error(`[PreCompact] Error reading ${config.file}:`, error);\n      return null;\n    }\n  });\n\n  const results = await Promise.all(reads);\n\n  for (const result of results) {\n    if (result) {\n      modes[result.key] = result.value;\n    }\n  }\n\n  return modes;\n}\n\n/**\n * Read TODO counts from todos.json\n */\nfunction readTodoSummary(directory: string): {\n  pending: number;\n  in_progress: number;\n  completed: number;\n} {\n  const todoPaths = [\n    join(directory, \".claude\", \"todos.json\"),\n    join(directory, \".omc\", \"state\", \"todos.json\"),\n  ];\n\n  for (const todoPath of todoPaths) {\n    if (existsSync(todoPath)) {\n      try {\n        const content = readFileSync(todoPath, \"utf-8\");\n        const todos = JSON.parse(content);\n\n        if (Array.isArray(todos)) {\n          return {\n            pending: todos.filter((t: any) => t.status === \"pending\").length,\n            in_progress: todos.filter((t: any) => t.status === \"in_progress\")\n              .length,\n            completed: todos.filter((t: any) => t.status === \"completed\")\n              .length,\n          };\n        }\n      } catch {\n        // Continue to next path\n      }\n    }\n  }\n\n  return { pending: 0, in_progress: 0, completed: 0 };\n}\n\n/**\n * Get summary of active and recent background jobs from SQLite DB\n * Queries .omc/state/jobs.db for Codex/Gemini job statuses\n */\nasync function getActiveJobsSummary(directory: string): Promise<{\n  activeJobs: Array<{ jobId: string; provider: string; model: string; agentRole: string; spawnedAt: string }>;\n  recentJobs: Array<{ jobId: string; provider: string; status: string; agentRole: string; completedAt?: string }>;\n  stats: { total: number; active: number; completed: number; failed: number } | null;\n}> {\n  try {\n    const dbReady = await initJobDb(directory);\n    if (!dbReady) {\n      return { activeJobs: [], recentJobs: [], stats: null };\n    }\n\n    const active = getActiveJobs();\n    const recent = getRecentJobs(undefined, 5 * 60 * 1000); // Last 5 minutes\n\n    // Filter recent to only completed/failed (not active ones which are already listed)\n    const recentCompleted = recent.filter(j => j.status === 'completed' || j.status === 'failed');\n\n    const stats = getJobStats();\n\n    return {\n      activeJobs: active.map(j => ({\n        jobId: j.jobId,\n        provider: j.provider,\n        model: j.model,\n        agentRole: j.agentRole,\n        spawnedAt: j.spawnedAt,\n      })),\n      recentJobs: recentCompleted.slice(0, 10).map(j => ({\n        jobId: j.jobId,\n        provider: j.provider,\n        status: j.status,\n        agentRole: j.agentRole,\n        completedAt: j.completedAt,\n      })),\n      stats,\n    };\n  } catch (error) {\n    console.error('[PreCompact] Error reading job state DB:', error);\n    return { activeJobs: [], recentJobs: [], stats: null };\n  } finally {\n    closeJobDb(directory);\n  }\n}\n\n/**\n * Create a compact checkpoint\n */\nexport async function createCompactCheckpoint(\n  directory: string,\n  trigger: \"manual\" | \"auto\",\n): Promise<CompactCheckpoint> {\n  const activeModes = await saveModeSummary(directory);\n  const todoSummary = readTodoSummary(directory);\n  const jobsSummary = await getActiveJobsSummary(directory);\n\n  return {\n    created_at: new Date().toISOString(),\n    trigger,\n    active_modes: activeModes as CompactCheckpoint[\"active_modes\"],\n    todo_summary: todoSummary,\n    wisdom_exported: false,\n    background_jobs: {\n      active: jobsSummary.activeJobs,\n      recent: jobsSummary.recentJobs,\n      stats: jobsSummary.stats,\n    },\n  };\n}\n\n/**\n * Format checkpoint summary for context injection\n */\nexport function formatCompactSummary(checkpoint: CompactCheckpoint): string {\n  const lines: string[] = [\n    \"# PreCompact Checkpoint\",\n    \"\",\n    `Created: ${checkpoint.created_at}`,\n    `Trigger: ${checkpoint.trigger}`,\n    \"\",\n  ];\n\n  // Active modes\n  const modeCount = Object.keys(checkpoint.active_modes).length;\n  if (modeCount > 0) {\n    lines.push(\"## Active Modes\");\n    lines.push(\"\");\n\n    if (checkpoint.active_modes.autopilot) {\n      const ap = checkpoint.active_modes.autopilot;\n      lines.push(`- **Autopilot** (Phase: ${ap.phase})`);\n      lines.push(`  Original Idea: ${ap.originalIdea}`);\n    }\n\n    if (checkpoint.active_modes.ralph) {\n      const ralph = checkpoint.active_modes.ralph;\n      lines.push(`- **Ralph** (Iteration: ${ralph.iteration})`);\n      lines.push(`  Prompt: ${ralph.prompt}`);\n    }\n\n    if (checkpoint.active_modes.ultrawork) {\n      const uw = checkpoint.active_modes.ultrawork;\n      lines.push(`- **Ultrawork**`);\n      lines.push(`  Prompt: ${uw.original_prompt}`);\n    }\n\n    if (checkpoint.active_modes.swarm) {\n      const swarm = checkpoint.active_modes.swarm;\n      lines.push(\n        `- **Swarm** (Session: ${swarm.session_id}, Tasks: ${swarm.task_count})`,\n      );\n    }\n\n    if (checkpoint.active_modes.ultrapilot) {\n      const up = checkpoint.active_modes.ultrapilot;\n      lines.push(`- **Ultrapilot** (Workers: ${up.worker_count})`);\n    }\n\n    if (checkpoint.active_modes.pipeline) {\n      const pipe = checkpoint.active_modes.pipeline;\n      lines.push(\n        `- **Pipeline** (Preset: ${pipe.preset}, Stage: ${pipe.current_stage})`,\n      );\n    }\n\n    if (checkpoint.active_modes.ultraqa) {\n      const qa = checkpoint.active_modes.ultraqa;\n      lines.push(`- **UltraQA** (Cycle: ${qa.cycle})`);\n      lines.push(`  Prompt: ${qa.prompt}`);\n    }\n\n    lines.push(\"\");\n  }\n\n  // TODO summary\n  const total =\n    checkpoint.todo_summary.pending +\n    checkpoint.todo_summary.in_progress +\n    checkpoint.todo_summary.completed;\n\n  if (total > 0) {\n    lines.push(\"## TODO Summary\");\n    lines.push(\"\");\n    lines.push(`- Pending: ${checkpoint.todo_summary.pending}`);\n    lines.push(`- In Progress: ${checkpoint.todo_summary.in_progress}`);\n    lines.push(`- Completed: ${checkpoint.todo_summary.completed}`);\n    lines.push(\"\");\n  }\n\n  // Background jobs\n  const jobs = checkpoint.background_jobs;\n  if (jobs && (jobs.active.length > 0 || jobs.recent.length > 0)) {\n    lines.push(\"## Background Jobs (Codex/Gemini)\");\n    lines.push(\"\");\n\n    if (jobs.active.length > 0) {\n      lines.push(\"### Currently Running\");\n      for (const job of jobs.active) {\n        const age = Math.round((Date.now() - new Date(job.spawnedAt).getTime()) / 1000);\n        lines.push(`- **${job.jobId}** ${job.provider}/${job.model} (${job.agentRole}) - ${age}s ago`);\n      }\n      lines.push(\"\");\n    }\n\n    if (jobs.recent.length > 0) {\n      lines.push(\"### Recently Completed\");\n      for (const job of jobs.recent) {\n        const icon = job.status === 'completed' ? 'OK' : 'FAIL';\n        lines.push(`- **${job.jobId}** [${icon}] ${job.provider} (${job.agentRole})`);\n      }\n      lines.push(\"\");\n    }\n\n    if (jobs.stats) {\n      lines.push(`**Job Stats:** ${jobs.stats.active} active, ${jobs.stats.completed} completed, ${jobs.stats.failed} failed (${jobs.stats.total} total)`);\n      lines.push(\"\");\n    }\n  }\n\n  // Wisdom status\n  if (checkpoint.wisdom_exported) {\n    lines.push(\"## Wisdom\");\n    lines.push(\"\");\n    lines.push(\"Plan wisdom has been preserved in checkpoint.\");\n    lines.push(\"\");\n  }\n\n  lines.push(\"---\");\n  lines.push(\n    \"**Note:** This checkpoint preserves critical state before compaction.\",\n  );\n  lines.push(\"Review active modes to ensure continuity after compaction.\");\n\n  return lines.join(\"\\n\");\n}\n\n/**\n * Internal compaction logic (unserialized).\n * Callers must go through processPreCompact which enforces the mutex.\n */\nasync function doProcessPreCompact(\n  input: PreCompactInput,\n): Promise<HookOutput> {\n  const directory = input.cwd;\n\n  // Create checkpoint\n  const checkpoint = await createCompactCheckpoint(directory, input.trigger);\n\n  // Export wisdom\n  const { wisdom, exported } = await exportWisdomToNotepad(directory);\n  checkpoint.wisdom_exported = exported;\n\n  // Save checkpoint\n  const checkpointPath = getCheckpointPath(directory);\n  const timestamp = new Date().toISOString().replace(/[:.]/g, \"-\");\n  const checkpointFile = join(checkpointPath, `checkpoint-${timestamp}.json`);\n\n  try {\n    writeFileSync(checkpointFile, JSON.stringify(checkpoint, null, 2), \"utf-8\");\n  } catch (error) {\n    console.error(\"[PreCompact] Error saving checkpoint:\", error);\n  }\n\n  // Save wisdom separately if exported\n  if (exported && wisdom) {\n    const wisdomFile = join(checkpointPath, `wisdom-${timestamp}.md`);\n    try {\n      writeFileSync(wisdomFile, wisdom, \"utf-8\");\n    } catch (error) {\n      console.error(\"[PreCompact] Error saving wisdom:\", error);\n    }\n  }\n\n  // Format summary for context injection\n  const summary = formatCompactSummary(checkpoint);\n\n  // Note: hookSpecificOutput only supports PreToolUse, UserPromptSubmit, PostToolUse\n  // Use systemMessage for custom hook events like PreCompact\n  return {\n    continue: true,\n    systemMessage: summary,\n  };\n}\n\n/**\n * Main handler for PreCompact hook.\n *\n * Uses a per-directory mutex to prevent concurrent compaction.\n * When multiple subagent results arrive simultaneously (swarm/ultrawork),\n * only the first call runs the compaction; subsequent calls await\n * the in-flight result. This fixes issue #453.\n */\nexport async function processPreCompact(\n  input: PreCompactInput,\n): Promise<HookOutput> {\n  const directory = input.cwd;\n\n  // If compaction is already in progress for this directory, coalesce\n  const inflight = inflightCompactions.get(directory);\n  if (inflight) {\n    const depth = (compactionQueueDepth.get(directory) ?? 0) + 1;\n    compactionQueueDepth.set(directory, depth);\n    try {\n      // Await the existing compaction result\n      return await inflight;\n    } finally {\n      const current = compactionQueueDepth.get(directory) ?? 1;\n      if (current <= 1) {\n        compactionQueueDepth.delete(directory);\n      } else {\n        compactionQueueDepth.set(directory, current - 1);\n      }\n    }\n  }\n\n  // No in-flight compaction  run it and register the promise\n  const compactionPromise = doProcessPreCompact(input);\n  inflightCompactions.set(directory, compactionPromise);\n\n  try {\n    return await compactionPromise;\n  } finally {\n    inflightCompactions.delete(directory);\n  }\n}\n\n/**\n * Check if compaction is currently in progress for a directory.\n * Useful for diagnostics and testing.\n */\nexport function isCompactionInProgress(directory: string): boolean {\n  return inflightCompactions.has(directory);\n}\n\n/**\n * Get the number of callers queued behind an in-flight compaction.\n * Returns 0 if no compaction is in progress.\n */\nexport function getCompactionQueueDepth(directory: string): number {\n  return compactionQueueDepth.get(directory) ?? 0;\n}\n\n// ============================================================================\n// Exports\n// ============================================================================\n\nexport default processPreCompact;\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\preemptive-compaction\\constants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\preemptive-compaction\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\preemptive-compaction\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\project-memory\\__tests__\\detector.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\project-memory\\__tests__\\formatter.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\project-memory\\__tests__\\integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\project-memory\\__tests__\\learner.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\project-memory\\__tests__\\storage.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\project-memory\\constants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\project-memory\\detector.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\project-memory\\directive-detector.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\project-memory\\directory-mapper.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\project-memory\\formatter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\project-memory\\hot-path-tracker.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\project-memory\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\project-memory\\learner.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":23,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":23,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[819,822],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[819,822],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Project Memory Learner\n * Incrementally learns from PostToolUse events\n */\n\nimport { loadProjectMemory, saveProjectMemory } from './storage.js';\nimport { BUILD_COMMAND_PATTERNS, TEST_COMMAND_PATTERNS } from './constants.js';\nimport { CustomNote } from './types.js';\nimport { trackAccess } from './hot-path-tracker.js';\nimport { detectDirectivesFromMessage, addDirective } from './directive-detector.js';\n\n/**\n * Learn from tool output and update project memory\n *\n * @param toolName - Name of the tool that was executed\n * @param toolInput - Input parameters to the tool\n * @param toolOutput - Output from the tool\n * @param projectRoot - Project root directory\n * @param userMessage - Optional user message for directive detection\n */\nexport async function learnFromToolOutput(\n  toolName: string,\n  toolInput: any,\n  toolOutput: string,\n  projectRoot: string,\n  userMessage?: string\n): Promise<void> {\n  // Learn from multiple tool types\n  const memory = await loadProjectMemory(projectRoot);\n  if (!memory) {\n    return;\n  }\n\n  let updated = false;\n\n  // Track file accesses from Read/Edit/Write tools\n  if (toolName === 'Read' || toolName === 'Edit' || toolName === 'Write') {\n    const filePath = toolInput?.file_path || toolInput?.filePath;\n    if (filePath) {\n      memory.hotPaths = trackAccess(memory.hotPaths, filePath, projectRoot, 'file');\n      updated = true;\n    }\n  }\n\n  // Track directory accesses from Glob/Grep\n  if (toolName === 'Glob' || toolName === 'Grep') {\n    const dirPath = toolInput?.path;\n    if (dirPath) {\n      memory.hotPaths = trackAccess(memory.hotPaths, dirPath, projectRoot, 'directory');\n      updated = true;\n    }\n  }\n\n  // Detect directives from user messages\n  if (userMessage) {\n    const detectedDirectives = detectDirectivesFromMessage(userMessage);\n    for (const directive of detectedDirectives) {\n      memory.userDirectives = addDirective(memory.userDirectives, directive);\n      updated = true;\n    }\n  }\n\n  // Learn from Bash commands\n  if (toolName !== 'Bash') {\n    if (updated) {\n      await saveProjectMemory(projectRoot, memory);\n    }\n    return;\n  }\n\n  const command = toolInput?.command || '';\n  if (!command) {\n    return;\n  }\n\n  try {\n\n    // Detect and store build commands\n    if (isBuildCommand(command)) {\n      if (!memory.build.buildCommand || memory.build.buildCommand !== command) {\n        memory.build.buildCommand = command;\n        updated = true;\n      }\n    }\n\n    // Detect and store test commands\n    if (isTestCommand(command)) {\n      if (!memory.build.testCommand || memory.build.testCommand !== command) {\n        memory.build.testCommand = command;\n        updated = true;\n      }\n    }\n\n    // Extract environment hints from output\n    const hints = extractEnvironmentHints(toolOutput);\n    if (hints.length > 0) {\n      for (const hint of hints) {\n        // Only add if not already present\n        const exists = memory.customNotes.some(\n          n => n.category === hint.category && n.content === hint.content\n        );\n        if (!exists) {\n          memory.customNotes.push(hint);\n          updated = true;\n        }\n      }\n\n      // Limit custom notes to 20 entries\n      if (memory.customNotes.length > 20) {\n        memory.customNotes = memory.customNotes.slice(-20);\n      }\n    }\n\n    // Save if updated\n    if (updated) {\n      await saveProjectMemory(projectRoot, memory);\n    }\n  } catch (error) {\n    // Silently fail\n    console.error('Error learning from tool output:', error);\n  }\n}\n\n/**\n * Check if command is a build command\n */\nfunction isBuildCommand(command: string): boolean {\n  return BUILD_COMMAND_PATTERNS.some(pattern => pattern.test(command));\n}\n\n/**\n * Check if command is a test command\n */\nfunction isTestCommand(command: string): boolean {\n  return TEST_COMMAND_PATTERNS.some(pattern => pattern.test(command));\n}\n\n/**\n * Extract environment hints from tool output\n * Returns custom notes to add to project memory\n */\nfunction extractEnvironmentHints(output: string): CustomNote[] {\n  const hints: CustomNote[] = [];\n  const timestamp = Date.now();\n\n  // Detect Node.js version\n  const nodeMatch = output.match(/Node\\.js\\s+(v?\\d+\\.\\d+\\.\\d+)/i);\n  if (nodeMatch) {\n    hints.push({\n      timestamp,\n      source: 'learned',\n      category: 'runtime',\n      content: `Node.js ${nodeMatch[1]}`,\n    });\n  }\n\n  // Detect Python version\n  const pythonMatch = output.match(/Python\\s+(\\d+\\.\\d+\\.\\d+)/i);\n  if (pythonMatch) {\n    hints.push({\n      timestamp,\n      source: 'learned',\n      category: 'runtime',\n      content: `Python ${pythonMatch[1]}`,\n    });\n  }\n\n  // Detect Rust version\n  const rustMatch = output.match(/rustc\\s+(\\d+\\.\\d+\\.\\d+)/i);\n  if (rustMatch) {\n    hints.push({\n      timestamp,\n      source: 'learned',\n      category: 'runtime',\n      content: `Rust ${rustMatch[1]}`,\n    });\n  }\n\n  // Detect missing dependencies (common error patterns)\n  if (output.includes('Cannot find module') || output.includes('ModuleNotFoundError')) {\n    const moduleMatch = output.match(/Cannot find module ['\"]([^'\"]+)['\"]/);\n    if (moduleMatch) {\n      hints.push({\n        timestamp,\n        source: 'learned',\n        category: 'dependency',\n        content: `Missing dependency: ${moduleMatch[1]}`,\n      });\n    }\n  }\n\n  // Detect environment variable requirements\n  const envMatch = output.match(/(?:Missing|Required)\\s+(?:environment\\s+)?(?:variable|env):\\s*([A-Z_][A-Z0-9_]*)/i);\n  if (envMatch) {\n    hints.push({\n      timestamp,\n      source: 'learned',\n      category: 'env',\n      content: `Requires env var: ${envMatch[1]}`,\n    });\n  }\n\n  return hints;\n}\n\n/**\n * Manually add a custom note to project memory\n *\n * @param projectRoot - Project root directory\n * @param category - Note category (build, test, deploy, env, etc.)\n * @param content - Note content\n */\nexport async function addCustomNote(\n  projectRoot: string,\n  category: string,\n  content: string\n): Promise<void> {\n  try {\n    const memory = await loadProjectMemory(projectRoot);\n    if (!memory) {\n      return;\n    }\n\n    memory.customNotes.push({\n      timestamp: Date.now(),\n      source: 'manual',\n      category,\n      content,\n    });\n\n    // Limit to 20 entries\n    if (memory.customNotes.length > 20) {\n      memory.customNotes = memory.customNotes.slice(-20);\n    }\n\n    await saveProjectMemory(projectRoot, memory);\n  } catch (error) {\n    console.error('Error adding custom note:', error);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\project-memory\\pre-compact.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\project-memory\\storage.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\project-memory\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\ralph\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\ralph\\loop.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\ralph\\prd.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\ralph\\progress.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\ralph\\verifier.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\recovery\\constants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\recovery\\context-window.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\recovery\\edit-error.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\recovery\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\recovery\\session-recovery.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\recovery\\storage.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\recovery\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\rules-injector\\constants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\rules-injector\\finder.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\rules-injector\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\rules-injector\\matcher.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\rules-injector\\parser.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\rules-injector\\storage.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\rules-injector\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\session-end\\__tests__\\callbacks.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\session-end\\__tests__\\python-repl-cleanup.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\session-end\\__tests__\\session-duration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\session-end\\__tests__\\session-end-bridge-cleanup.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\session-end\\callbacks.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\session-end\\index.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":47,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":47,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1319,1322],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1319,1322],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as fs from 'fs';\nimport * as path from 'path';\nimport * as readline from 'readline';\nimport { triggerStopCallbacks } from './callbacks.js';\nimport { notify } from '../../notifications/index.js';\nimport { cleanupBridgeSessions } from '../../tools/python-repl/bridge-manager.js';\n\nexport interface SessionEndInput {\n  session_id: string;\n  transcript_path: string;\n  cwd: string;\n  permission_mode: string;\n  hook_event_name: 'SessionEnd';\n  reason: 'clear' | 'logout' | 'prompt_input_exit' | 'other';\n}\n\nexport interface SessionMetrics {\n  session_id: string;\n  started_at?: string;\n  ended_at: string;\n  reason: string;\n  duration_ms?: number;\n  agents_spawned: number;\n  agents_completed: number;\n  modes_used: string[];\n}\n\nexport interface HookOutput {\n  continue: boolean;\n}\n\n/**\n * Read agent tracking to get spawn/completion counts\n */\nfunction getAgentCounts(directory: string): { spawned: number; completed: number } {\n  const trackingPath = path.join(directory, '.omc', 'state', 'subagent-tracking.json');\n\n  if (!fs.existsSync(trackingPath)) {\n    return { spawned: 0, completed: 0 };\n  }\n\n  try {\n    const content = fs.readFileSync(trackingPath, 'utf-8');\n    const tracking = JSON.parse(content);\n\n    const spawned = tracking.agents?.length || 0;\n    const completed = tracking.agents?.filter((a: any) => a.status === 'completed').length || 0;\n\n    return { spawned, completed };\n  } catch (_error) {\n    return { spawned: 0, completed: 0 };\n  }\n}\n\n/**\n * Detect which modes were used during the session\n */\nfunction getModesUsed(directory: string): string[] {\n  const stateDir = path.join(directory, '.omc', 'state');\n  const modes: string[] = [];\n\n  if (!fs.existsSync(stateDir)) {\n    return modes;\n  }\n\n  const modeStateFiles = [\n    { file: 'autopilot-state.json', mode: 'autopilot' },\n    { file: 'ultrapilot-state.json', mode: 'ultrapilot' },\n    { file: 'ralph-state.json', mode: 'ralph' },\n    { file: 'ultrawork-state.json', mode: 'ultrawork' },\n    { file: 'swarm-state.json', mode: 'swarm' },\n    { file: 'pipeline-state.json', mode: 'pipeline' },\n  ];\n\n  for (const { file, mode } of modeStateFiles) {\n    const statePath = path.join(stateDir, file);\n    if (fs.existsSync(statePath)) {\n      modes.push(mode);\n    }\n  }\n\n  return modes;\n}\n\n/**\n * Get session start time from state files.\n *\n * When sessionId is provided, only state files whose session_id matches are\n * considered.  State files that carry a *different* session_id are treated as\n * stale leftovers and skipped  this is the fix for issue #573 where stale\n * state files caused grossly overreported session durations.\n *\n * Legacy state files (no session_id field) are used as a fallback so that\n * older state formats still work.\n *\n * When multiple files match, the earliest started_at is returned so that\n * duration reflects the full session span (e.g. autopilot started before\n * ultrawork).\n */\nexport function getSessionStartTime(directory: string, sessionId?: string): string | undefined {\n  const stateDir = path.join(directory, '.omc', 'state');\n\n  if (!fs.existsSync(stateDir)) {\n    return undefined;\n  }\n\n  const stateFiles = fs.readdirSync(stateDir).filter(f => f.endsWith('.json'));\n\n  let matchedStartTime: string | undefined;\n  let matchedEpoch = Infinity;\n  let legacyStartTime: string | undefined;\n  let legacyEpoch = Infinity;\n\n  for (const file of stateFiles) {\n    try {\n      const statePath = path.join(stateDir, file);\n      const content = fs.readFileSync(statePath, 'utf-8');\n      const state = JSON.parse(content);\n\n      if (!state.started_at) {\n        continue;\n      }\n\n      const ts = Date.parse(state.started_at);\n      if (!Number.isFinite(ts)) {\n        continue; // skip invalid / malformed timestamps\n      }\n\n      if (sessionId && state.session_id === sessionId) {\n        // State belongs to the current session  prefer earliest\n        if (ts < matchedEpoch) {\n          matchedEpoch = ts;\n          matchedStartTime = state.started_at;\n        }\n      } else if (!state.session_id) {\n        // Legacy state without session_id  fallback only\n        if (ts < legacyEpoch) {\n          legacyEpoch = ts;\n          legacyStartTime = state.started_at;\n        }\n      }\n      // else: state has a different session_id  stale, skip\n    } catch (_error) {\n      continue;\n    }\n  }\n\n  return matchedStartTime ?? legacyStartTime;\n}\n\n/**\n * Record session metrics\n */\nexport function recordSessionMetrics(directory: string, input: SessionEndInput): SessionMetrics {\n  const endedAt = new Date().toISOString();\n  const startedAt = getSessionStartTime(directory, input.session_id);\n  const { spawned, completed } = getAgentCounts(directory);\n  const modesUsed = getModesUsed(directory);\n\n  const metrics: SessionMetrics = {\n    session_id: input.session_id,\n    started_at: startedAt,\n    ended_at: endedAt,\n    reason: input.reason,\n    agents_spawned: spawned,\n    agents_completed: completed,\n    modes_used: modesUsed,\n  };\n\n  // Calculate duration if start time is available\n  if (startedAt) {\n    try {\n      const startTime = new Date(startedAt).getTime();\n      const endTime = new Date(endedAt).getTime();\n      metrics.duration_ms = endTime - startTime;\n    } catch (_error) {\n      // Invalid date, skip duration\n    }\n  }\n\n  return metrics;\n}\n\n/**\n * Clean up transient state files\n */\nexport function cleanupTransientState(directory: string): number {\n  let filesRemoved = 0;\n  const omcDir = path.join(directory, '.omc');\n\n  if (!fs.existsSync(omcDir)) {\n    return filesRemoved;\n  }\n\n  // Remove transient agent tracking\n  const trackingPath = path.join(omcDir, 'state', 'subagent-tracking.json');\n  if (fs.existsSync(trackingPath)) {\n    try {\n      fs.unlinkSync(trackingPath);\n      filesRemoved++;\n    } catch (_error) {\n      // Ignore removal errors\n    }\n  }\n\n  // Clean stale checkpoints (older than 24 hours)\n  const checkpointsDir = path.join(omcDir, 'checkpoints');\n  if (fs.existsSync(checkpointsDir)) {\n    const now = Date.now();\n    const oneDayAgo = now - 24 * 60 * 60 * 1000;\n\n    try {\n      const files = fs.readdirSync(checkpointsDir);\n      for (const file of files) {\n        const filePath = path.join(checkpointsDir, file);\n        const stats = fs.statSync(filePath);\n\n        if (stats.mtimeMs < oneDayAgo) {\n          fs.unlinkSync(filePath);\n          filesRemoved++;\n        }\n      }\n    } catch (_error) {\n      // Ignore cleanup errors\n    }\n  }\n\n  // Remove .tmp files in .omc/\n  const removeTmpFiles = (dir: string) => {\n    try {\n      const entries = fs.readdirSync(dir, { withFileTypes: true });\n\n      for (const entry of entries) {\n        const fullPath = path.join(dir, entry.name);\n\n        if (entry.isDirectory()) {\n          removeTmpFiles(fullPath);\n        } else if (entry.name.endsWith('.tmp')) {\n          fs.unlinkSync(fullPath);\n          filesRemoved++;\n        }\n      }\n    } catch (_error) {\n      // Ignore errors\n    }\n  };\n\n  removeTmpFiles(omcDir);\n\n  return filesRemoved;\n}\n\n/**\n * Mode state files that should be cleaned up on session end.\n * These files track active execution modes that should not persist across sessions.\n */\nconst MODE_STATE_FILES = [\n  { file: 'autopilot-state.json', mode: 'autopilot' },\n  { file: 'ultrapilot-state.json', mode: 'ultrapilot' },\n  { file: 'ralph-state.json', mode: 'ralph' },\n  { file: 'ultrawork-state.json', mode: 'ultrawork' },\n  { file: 'ultraqa-state.json', mode: 'ultraqa' },\n  { file: 'pipeline-state.json', mode: 'pipeline' },\n  // Swarm uses marker file + SQLite\n  { file: 'swarm-active.marker', mode: 'swarm' },\n  { file: 'swarm-summary.json', mode: 'swarm' },\n];\n\nconst PYTHON_REPL_TOOL_NAMES = new Set(['python_repl', 'mcp__t__python_repl']);\n\n/**\n * Extract python_repl research session IDs from transcript JSONL.\n * These sessions are terminated on SessionEnd to prevent bridge leaks.\n */\nexport async function extractPythonReplSessionIdsFromTranscript(transcriptPath: string): Promise<string[]> {\n  if (!transcriptPath || !fs.existsSync(transcriptPath)) {\n    return [];\n  }\n\n  const sessionIds = new Set<string>();\n  const stream = fs.createReadStream(transcriptPath, { encoding: 'utf-8' });\n  const rl = readline.createInterface({\n    input: stream,\n    crlfDelay: Infinity,\n  });\n\n  try {\n    for await (const line of rl) {\n      if (!line.trim()) {\n        continue;\n      }\n\n      let parsed: unknown;\n      try {\n        parsed = JSON.parse(line);\n      } catch {\n        continue;\n      }\n\n      const entry = parsed as { message?: { content?: unknown[] } };\n      const contentBlocks = entry.message?.content;\n      if (!Array.isArray(contentBlocks)) {\n        continue;\n      }\n\n      for (const block of contentBlocks) {\n        const toolUse = block as {\n          type?: string;\n          name?: string;\n          input?: { researchSessionID?: unknown };\n        };\n\n        if (toolUse.type !== 'tool_use' || !toolUse.name || !PYTHON_REPL_TOOL_NAMES.has(toolUse.name)) {\n          continue;\n        }\n\n        const sessionId = toolUse.input?.researchSessionID;\n        if (typeof sessionId === 'string' && sessionId.trim().length > 0) {\n          sessionIds.add(sessionId.trim());\n        }\n      }\n    }\n  } finally {\n    rl.close();\n    stream.destroy();\n  }\n\n  return [...sessionIds];\n}\n\n/**\n * Clean up mode state files on session end.\n *\n * This prevents stale state from causing the stop hook to malfunction\n * in subsequent sessions. When a session ends normally, all active modes\n * should be considered terminated.\n *\n * @param directory - The project directory\n * @param sessionId - Optional session ID to match. Only cleans states belonging to this session.\n * @returns Object with counts of files removed and modes cleaned\n */\nexport function cleanupModeStates(directory: string, sessionId?: string): { filesRemoved: number; modesCleaned: string[] } {\n  let filesRemoved = 0;\n  const modesCleaned: string[] = [];\n  const stateDir = path.join(directory, '.omc', 'state');\n\n  if (!fs.existsSync(stateDir)) {\n    return { filesRemoved, modesCleaned };\n  }\n\n  for (const { file, mode } of MODE_STATE_FILES) {\n    const localPath = path.join(stateDir, file);\n\n    // Check if local state exists and is active\n    if (fs.existsSync(localPath)) {\n      try {\n        // For JSON files, check if active before removing\n        if (file.endsWith('.json')) {\n          const content = fs.readFileSync(localPath, 'utf-8');\n          const state = JSON.parse(content);\n\n          // Only clean if marked as active AND belongs to this session\n          // (prevents removing other concurrent sessions' states)\n          if (state.active === true) {\n            // If sessionId is provided, only clean matching states\n            // If state has no session_id, it's legacy - clean it\n            // If state.session_id matches our sessionId, clean it\n            const stateSessionId = state.session_id as string | undefined;\n            if (!sessionId || !stateSessionId || stateSessionId === sessionId) {\n              fs.unlinkSync(localPath);\n              filesRemoved++;\n              if (!modesCleaned.includes(mode)) {\n                modesCleaned.push(mode);\n              }\n            }\n          }\n        } else {\n          // For marker files, always remove\n          fs.unlinkSync(localPath);\n          filesRemoved++;\n          if (!modesCleaned.includes(mode)) {\n            modesCleaned.push(mode);\n          }\n        }\n      } catch {\n        // Ignore errors, continue with other files\n      }\n    }\n  }\n\n  return { filesRemoved, modesCleaned };\n}\n\n/**\n * Export session summary to .omc/sessions/\n */\nexport function exportSessionSummary(directory: string, metrics: SessionMetrics): void {\n  const sessionsDir = path.join(directory, '.omc', 'sessions');\n\n  // Create sessions directory if it doesn't exist\n  if (!fs.existsSync(sessionsDir)) {\n    fs.mkdirSync(sessionsDir, { recursive: true });\n  }\n\n  // Write session summary\n  const sessionFile = path.join(sessionsDir, `${metrics.session_id}.json`);\n\n  try {\n    fs.writeFileSync(sessionFile, JSON.stringify(metrics, null, 2), 'utf-8');\n  } catch (_error) {\n    // Ignore write errors\n  }\n}\n\n/**\n * Process session end\n */\nexport async function processSessionEnd(input: SessionEndInput): Promise<HookOutput> {\n  // Record and export session metrics to disk\n  const metrics = recordSessionMetrics(input.cwd, input);\n  exportSessionSummary(input.cwd, metrics);\n\n  // Clean up transient state files\n  cleanupTransientState(input.cwd);\n\n  // Clean up mode state files to prevent stale state issues\n  // This ensures the stop hook won't malfunction in subsequent sessions\n  // Pass session_id to only clean up this session's states\n  cleanupModeStates(input.cwd, input.session_id);\n\n  // Clean up Python REPL bridge sessions used in this transcript (#641).\n  // Best-effort only: session end should not fail because cleanup fails.\n  try {\n    const pythonSessionIds = await extractPythonReplSessionIdsFromTranscript(input.transcript_path);\n    if (pythonSessionIds.length > 0) {\n      await cleanupBridgeSessions(pythonSessionIds);\n    }\n  } catch {\n    // Ignore cleanup errors\n  }\n\n  // Trigger stop hook callbacks (#395)\n  await triggerStopCallbacks(metrics, {\n    session_id: input.session_id,\n    cwd: input.cwd,\n  });\n\n  // Trigger new notification system (in addition to legacy callbacks)\n  try {\n    await notify('session-end', {\n      sessionId: input.session_id,\n      projectPath: input.cwd,\n      durationMs: metrics.duration_ms,\n      agentsSpawned: metrics.agents_spawned,\n      agentsCompleted: metrics.agents_completed,\n      modesUsed: metrics.modes_used,\n      reason: metrics.reason,\n      timestamp: metrics.ended_at,\n      profileName: process.env.OMC_NOTIFY_PROFILE,\n    });\n  } catch {\n    // Notification failures should never block session end\n  }\n\n  // Clean up reply session registry and stop daemon if no active sessions remain\n  try {\n    const { removeSession, loadAllMappings } = await import('../../notifications/session-registry.js');\n    const { stopReplyListener } = await import('../../notifications/reply-listener.js');\n\n    // Remove this session's message mappings\n    removeSession(input.session_id);\n\n    // Stop daemon if registry is now empty (no other active sessions)\n    const remainingMappings = loadAllMappings();\n    if (remainingMappings.length === 0) {\n      await stopReplyListener();\n    }\n  } catch {\n    // Reply listener cleanup failures should never block session end\n  }\n\n  // Return simple response - metrics are persisted to .omc/sessions/\n  return { continue: true };\n}\n\n/**\n * Main hook entry point\n */\nexport async function handleSessionEnd(input: SessionEndInput): Promise<HookOutput> {\n  return processSessionEnd(input);\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\setup\\__tests__\\prune.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\setup\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\setup\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\subagent-tracker\\__tests__\\flow-tracer.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\subagent-tracker\\__tests__\\flush-race.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\subagent-tracker\\__tests__\\index.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\subagent-tracker\\__tests__\\session-replay.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\subagent-tracker\\flow-tracer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\subagent-tracker\\index.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":302,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":302,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8836,8839],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8836,8839],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Subagent Tracker Hook Module\n *\n * Tracks SubagentStart and SubagentStop events for comprehensive agent monitoring.\n * Features:\n * - Track all spawned agents with parent mode context\n * - Detect stuck/stale agents (>5 min without progress)\n * - HUD integration for agent status display\n * - Automatic cleanup of orphaned agent state\n */\n\nimport {\n  existsSync,\n  readFileSync,\n  writeFileSync,\n  mkdirSync,\n  unlinkSync,\n  statSync,\n} from \"fs\";\nimport { join } from \"path\";\nimport { recordAgentStart, recordAgentStop } from './session-replay.js';\n\n// ============================================================================\n// Types\n// ============================================================================\n\nexport interface SubagentInfo {\n  agent_id: string;\n  agent_type: string;\n  started_at: string;\n  parent_mode: string; // 'autopilot' | 'ultrapilot' | 'ultrawork' | 'swarm' | 'none'\n  task_description?: string;\n  file_ownership?: string[];\n  status: \"running\" | \"completed\" | \"failed\";\n  completed_at?: string;\n  duration_ms?: number;\n  output_summary?: string;\n  tool_usage?: ToolUsageEntry[];\n  token_usage?: TokenUsage;\n  model?: string;\n}\n\nexport interface ToolUsageEntry {\n  tool_name: string;\n  timestamp: string;\n  duration_ms?: number;\n  success?: boolean;\n}\n\nexport interface ToolTimingStats {\n  count: number;\n  avg_ms: number;\n  max_ms: number;\n  total_ms: number;\n  failures: number;\n}\n\nexport interface AgentPerformance {\n  agent_id: string;\n  tool_timings: Record<string, ToolTimingStats>;\n  token_usage: TokenUsage;\n  bottleneck?: string;\n  parallel_efficiency?: number;\n}\n\nexport interface TokenUsage {\n  input_tokens: number;\n  output_tokens: number;\n  cache_read_tokens: number;\n  cost_usd: number;\n}\n\nexport interface SubagentTrackingState {\n  agents: SubagentInfo[];\n  total_spawned: number;\n  total_completed: number;\n  total_failed: number;\n  last_updated: string;\n}\n\nexport interface SubagentStartInput {\n  session_id: string;\n  transcript_path: string;\n  cwd: string;\n  permission_mode: string;\n  hook_event_name: \"SubagentStart\";\n  agent_id: string;\n  agent_type: string;\n  prompt?: string;\n  model?: string;\n}\n\nexport interface SubagentStopInput {\n  session_id: string;\n  transcript_path: string;\n  cwd: string;\n  permission_mode: string;\n  hook_event_name: \"SubagentStop\";\n  agent_id: string;\n  agent_type: string;\n  output?: string;\n  /** @deprecated The SDK does not provide a success field. Use inferred status instead. */\n  success?: boolean;\n}\n\nexport interface HookOutput {\n  continue: boolean;\n  hookSpecificOutput?: {\n    hookEventName: string;\n    additionalContext?: string;\n    agent_count?: number;\n    stale_agents?: string[];\n  };\n}\n\nexport interface AgentIntervention {\n  type: \"timeout\" | \"deadlock\" | \"excessive_cost\" | \"file_conflict\";\n  agent_id: string;\n  agent_type: string;\n  reason: string;\n  suggested_action: \"kill\" | \"restart\" | \"warn\" | \"skip\";\n  auto_execute: boolean;\n}\n\nexport const COST_LIMIT_USD = 1.0;\nexport const DEADLOCK_CHECK_THRESHOLD = 3;\n\n// ============================================================================\n// Constants\n// ============================================================================\n\nconst STATE_FILE = \"subagent-tracking.json\";\nconst STALE_THRESHOLD_MS = 5 * 60 * 1000;\nconst MAX_COMPLETED_AGENTS = 100;\nconst LOCK_TIMEOUT_MS = 5000;\nconst LOCK_RETRY_MS = 50;\nconst WRITE_DEBOUNCE_MS = 100;\nconst MAX_FLUSH_RETRIES = 3;\nconst FLUSH_RETRY_BASE_MS = 50;\n\n// Per-directory debounce state for batching writes (avoids race conditions)\nconst pendingWrites = new Map<\n  string,\n  { state: SubagentTrackingState; timeout: ReturnType<typeof setTimeout> }\n>();\n\n// Guard against duplicate concurrent flushes per directory\nconst flushInProgress = new Set<string>();\n\n/**\n * Check if a process is still alive\n * Signal 0 doesn't kill the process, just checks if it exists\n */\nfunction isProcessAlive(pid: number): boolean {\n  try {\n    process.kill(pid, 0);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Synchronous sleep using Atomics.wait\n * Avoids CPU-spinning busy-wait loops\n */\nfunction syncSleep(ms: number): void {\n  const buffer = new SharedArrayBuffer(4);\n  const view = new Int32Array(buffer);\n  Atomics.wait(view, 0, 0, ms);\n}\n\n// ============================================================================\n// Merge Logic\n// ============================================================================\n\n/**\n * Merge two tracker states with deterministic semantics.\n * Used by debounced flush to combine disk state with in-memory pending state.\n *\n * Merge rules:\n * - Counters (total_spawned, total_completed, total_failed): Math.max\n * - Agents: union by agent_id; if same ID exists in both, newer timestamp wins\n * - last_updated: Math.max of both timestamps\n */\nexport function mergeTrackerStates(\n  diskState: SubagentTrackingState,\n  pendingState: SubagentTrackingState,\n): SubagentTrackingState {\n  // Build agent map: start with disk agents, overlay with pending\n  const agentMap = new Map<string, SubagentInfo>();\n\n  for (const agent of diskState.agents) {\n    agentMap.set(agent.agent_id, agent);\n  }\n\n  for (const agent of pendingState.agents) {\n    const existing = agentMap.get(agent.agent_id);\n    if (!existing) {\n      // New agent from pending state\n      agentMap.set(agent.agent_id, agent);\n    } else {\n      // Same agent_id in both - pick the one with the newer relevant timestamp\n      const existingTime = existing.completed_at\n        ? new Date(existing.completed_at).getTime()\n        : new Date(existing.started_at).getTime();\n      const pendingTime = agent.completed_at\n        ? new Date(agent.completed_at).getTime()\n        : new Date(agent.started_at).getTime();\n\n      if (pendingTime >= existingTime) {\n        agentMap.set(agent.agent_id, agent);\n      }\n    }\n  }\n\n  // Counters: take max to avoid double-counting\n  const total_spawned = Math.max(diskState.total_spawned, pendingState.total_spawned);\n  const total_completed = Math.max(diskState.total_completed, pendingState.total_completed);\n  const total_failed = Math.max(diskState.total_failed, pendingState.total_failed);\n\n  // Timestamp: take the latest\n  const diskTime = new Date(diskState.last_updated).getTime();\n  const pendingTime = new Date(pendingState.last_updated).getTime();\n  const last_updated = diskTime > pendingTime ? diskState.last_updated : pendingState.last_updated;\n\n  return {\n    agents: Array.from(agentMap.values()),\n    total_spawned,\n    total_completed,\n    total_failed,\n    last_updated,\n  };\n}\n\n// ============================================================================\n// State Management\n// ============================================================================\n\n/**\n * Acquire file lock with timeout and stale lock detection\n */\nfunction acquireLock(directory: string): boolean {\n  const lockPath = join(directory, \".omc\", \"state\", \"subagent-tracker.lock\");\n  const lockDir = join(directory, \".omc\", \"state\");\n\n  if (!existsSync(lockDir)) {\n    mkdirSync(lockDir, { recursive: true });\n  }\n\n  const startTime = Date.now();\n\n  while (Date.now() - startTime < LOCK_TIMEOUT_MS) {\n    try {\n      // Check for stale lock (older than timeout or dead process)\n      if (existsSync(lockPath)) {\n        const lockContent = readFileSync(lockPath, \"utf-8\");\n        const lockParts = lockContent.split(\":\");\n        if (lockParts.length < 2) {\n          // Malformed lock content, treat as corrupted: best-effort remove and backoff\n          try {\n            unlinkSync(lockPath);\n          } catch {\n            /* ignore */\n          }\n          syncSleep(LOCK_RETRY_MS);\n          continue;\n        }\n        const [lockPidStr, lockTimeStr] = lockParts;\n        const lockPid = parseInt(lockPidStr, 10);\n        const lockTime = parseInt(lockTimeStr, 10);\n        // Non-integer PID or timestamp indicates corrupted lock; remove and retry with backoff\n        if (isNaN(lockPid) || isNaN(lockTime)) {\n          try {\n            unlinkSync(lockPath);\n          } catch {\n            /* ignore */\n          }\n          syncSleep(LOCK_RETRY_MS);\n          continue;\n        }\n        const isStale = Date.now() - lockTime > LOCK_TIMEOUT_MS;\n        const isDeadProcess = !isNaN(lockPid) && !isProcessAlive(lockPid);\n\n        if (isStale || isDeadProcess) {\n          // Stale lock or dead process, remove it\n          try {\n            unlinkSync(lockPath);\n          } catch {\n            /* ignore stale lock removal errors */\n          }\n        } else {\n          // Lock is held by a live process, wait and retry\n          syncSleep(LOCK_RETRY_MS);\n          continue;\n        }\n      }\n\n      // Try to create lock atomically with PID:timestamp\n      writeFileSync(lockPath, `${process.pid}:${Date.now()}`, { flag: \"wx\" });\n      return true;\n    } catch (e: any) {\n      if (e.code === \"EEXIST\") {\n        // Lock exists, retry\n        syncSleep(LOCK_RETRY_MS);\n        continue;\n      }\n      return false;\n    }\n  }\n\n  return false; // Timeout\n}\n\n/**\n * Release file lock\n */\nfunction releaseLock(directory: string): void {\n  const lockPath = join(directory, \".omc\", \"state\", \"subagent-tracker.lock\");\n  try {\n    unlinkSync(lockPath);\n  } catch {\n    // Ignore errors\n  }\n}\n\n/**\n * Get the state file path\n */\nexport function getStateFilePath(directory: string): string {\n  const stateDir = join(directory, \".omc\", \"state\");\n  if (!existsSync(stateDir)) {\n    mkdirSync(stateDir, { recursive: true });\n  }\n  return join(stateDir, STATE_FILE);\n}\n\n/**\n * Read tracking state directly from disk, bypassing the pending writes cache.\n * Used during flush to get the latest on-disk state for merging.\n */\nexport function readDiskState(directory: string): SubagentTrackingState {\n  const statePath = getStateFilePath(directory);\n\n  if (!existsSync(statePath)) {\n    return {\n      agents: [],\n      total_spawned: 0,\n      total_completed: 0,\n      total_failed: 0,\n      last_updated: new Date().toISOString(),\n    };\n  }\n\n  try {\n    const content = readFileSync(statePath, \"utf-8\");\n    return JSON.parse(content);\n  } catch (error) {\n    console.error(\"[SubagentTracker] Error reading disk state:\", error);\n    return {\n      agents: [],\n      total_spawned: 0,\n      total_completed: 0,\n      total_failed: 0,\n      last_updated: new Date().toISOString(),\n    };\n  }\n}\n\n/**\n * Read tracking state from file.\n * If there's a pending write for this directory, returns it instead of reading disk.\n */\nexport function readTrackingState(directory: string): SubagentTrackingState {\n  const pending = pendingWrites.get(directory);\n  if (pending) {\n    return pending.state;\n  }\n\n  return readDiskState(directory);\n}\n\n/**\n * Write tracking state to file immediately (bypasses debounce).\n */\nfunction writeTrackingStateImmediate(\n  directory: string,\n  state: SubagentTrackingState,\n): void {\n  const statePath = getStateFilePath(directory);\n  state.last_updated = new Date().toISOString();\n\n  try {\n    writeFileSync(statePath, JSON.stringify(state, null, 2), \"utf-8\");\n  } catch (error) {\n    console.error(\"[SubagentTracker] Error writing state:\", error);\n  }\n}\n\n/**\n * Execute the flush: lock -> re-read disk -> merge -> write -> unlock.\n * Returns true on success, false if lock could not be acquired.\n */\nexport function executeFlush(directory: string, pendingState: SubagentTrackingState): boolean {\n  if (!acquireLock(directory)) {\n    return false;\n  }\n\n  try {\n    // Re-read latest disk state to avoid overwriting concurrent changes\n    const diskState = readDiskState(directory);\n    const merged = mergeTrackerStates(diskState, pendingState);\n    writeTrackingStateImmediate(directory, merged);\n    return true;\n  } finally {\n    releaseLock(directory);\n  }\n}\n\n/**\n * Write tracking state with debouncing to reduce I/O.\n * The flush callback acquires the lock, re-reads disk state, merges with\n * the pending in-memory delta, and writes atomically.\n * If the lock cannot be acquired, retries with exponential backoff (max 3 retries).\n */\nexport function writeTrackingState(\n  directory: string,\n  state: SubagentTrackingState,\n): void {\n  const existing = pendingWrites.get(directory);\n  if (existing) {\n    clearTimeout(existing.timeout);\n  }\n\n  const timeout = setTimeout(() => {\n    const pending = pendingWrites.get(directory);\n    if (!pending) return;\n\n    pendingWrites.delete(directory);\n\n    // Guard against duplicate concurrent flushes for the same directory\n    if (flushInProgress.has(directory)) {\n      // Re-queue: put it back and let the next debounce cycle handle it\n      pendingWrites.set(directory, {\n        state: pending.state,\n        timeout: setTimeout(() => {\n          writeTrackingState(directory, pending.state);\n        }, WRITE_DEBOUNCE_MS),\n      });\n      return;\n    }\n\n    flushInProgress.add(directory);\n\n    try {\n      // Try flush with bounded retries on lock failure\n      let success = false;\n      for (let attempt = 0; attempt < MAX_FLUSH_RETRIES; attempt++) {\n        success = executeFlush(directory, pending.state);\n        if (success) break;\n        // Exponential backoff before retry\n        syncSleep(FLUSH_RETRY_BASE_MS * Math.pow(2, attempt));\n      }\n\n      if (!success) {\n        console.error(\n          `[SubagentTracker] Failed to flush after ${MAX_FLUSH_RETRIES} retries for ${directory}. Data retained in memory for next attempt.`,\n        );\n        // Put data back in pending so the next writeTrackingState call will retry\n        pendingWrites.set(directory, {\n          state: pending.state,\n          timeout: setTimeout(() => {\n            // No-op: data is just stored, will be picked up by next write or flushPendingWrites\n          }, 0),\n        });\n      }\n    } finally {\n      flushInProgress.delete(directory);\n    }\n  }, WRITE_DEBOUNCE_MS);\n\n  pendingWrites.set(directory, { state, timeout });\n}\n\n/**\n * Flush any pending debounced writes immediately using the merge-aware path.\n * Call this in tests before cleanup to ensure state is persisted.\n */\nexport function flushPendingWrites(): void {\n  for (const [directory, pending] of pendingWrites) {\n    clearTimeout(pending.timeout);\n    // Use executeFlush for merge-aware writes; fall back to direct write\n    // only if lock acquisition fails (test environments with no contention)\n    if (!executeFlush(directory, pending.state)) {\n      writeTrackingStateImmediate(directory, pending.state);\n    }\n  }\n  pendingWrites.clear();\n}\n\n// ============================================================================\n// Helper Functions\n// ============================================================================\n\n/**\n * Detect the current parent mode from state files\n */\nfunction detectParentMode(directory: string): string {\n  const stateDir = join(directory, \".omc\", \"state\");\n\n  if (!existsSync(stateDir)) {\n    return \"none\";\n  }\n\n  // Check in order of specificity\n  const modeFiles = [\n    { file: \"ultrapilot-state.json\", mode: \"ultrapilot\" },\n    { file: \"autopilot-state.json\", mode: \"autopilot\" },\n    { file: \"swarm.db\", mode: \"swarm\" },\n    { file: \"ultrawork-state.json\", mode: \"ultrawork\" },\n    { file: \"ralph-state.json\", mode: \"ralph\" },\n  ];\n\n  for (const { file, mode } of modeFiles) {\n    const filePath = join(stateDir, file);\n    if (existsSync(filePath)) {\n      // Special case for swarm.db - just check existence and size\n      if (file === 'swarm.db') {\n        try {\n          const stats = statSync(filePath);\n          if (stats.size > 0) {\n            return mode;\n          }\n        } catch {\n          continue;\n        }\n      } else {\n        // JSON file check (existing logic)\n        try {\n          const content = readFileSync(filePath, \"utf-8\");\n          const state = JSON.parse(content);\n          if (\n            state.active === true ||\n            state.status === \"running\" ||\n            state.status === \"active\"\n          ) {\n            return mode;\n          }\n        } catch {\n          continue;\n        }\n      }\n    }\n  }\n\n  return \"none\";\n}\n\n/**\n * Get list of stale agents (running for too long)\n */\nexport function getStaleAgents(state: SubagentTrackingState): SubagentInfo[] {\n  const now = Date.now();\n\n  return state.agents.filter((agent) => {\n    if (agent.status !== \"running\") {\n      return false;\n    }\n\n    const startTime = new Date(agent.started_at).getTime();\n    const elapsed = now - startTime;\n\n    return elapsed > STALE_THRESHOLD_MS;\n  });\n}\n\n// ============================================================================\n// Hook Processors\n// ============================================================================\n\n/**\n * Process SubagentStart event\n */\nexport function processSubagentStart(input: SubagentStartInput): HookOutput {\n  if (!acquireLock(input.cwd)) {\n    return { continue: true }; // Fail gracefully\n  }\n\n  try {\n    const state = readTrackingState(input.cwd);\n    const parentMode = detectParentMode(input.cwd);\n\n    // Create new agent entry\n    const agentInfo: SubagentInfo = {\n      agent_id: input.agent_id,\n      agent_type: input.agent_type,\n      started_at: new Date().toISOString(),\n      parent_mode: parentMode,\n      task_description: input.prompt?.substring(0, 200), // Truncate for storage\n      status: \"running\",\n      model: input.model,\n    };\n\n    // Add to state\n    state.agents.push(agentInfo);\n    state.total_spawned++;\n\n    // Write updated state\n    writeTrackingState(input.cwd, state);\n\n    // Record to session replay JSONL for /trace\n    try {\n      recordAgentStart(input.cwd, input.session_id, input.agent_id, input.agent_type, input.prompt, parentMode, input.model);\n    } catch { /* best-effort */ }\n\n    // Check for stale agents\n    const staleAgents = getStaleAgents(state);\n\n    return {\n      continue: true,\n      hookSpecificOutput: {\n        hookEventName: \"SubagentStart\",\n        additionalContext: `Agent ${input.agent_type} started (${input.agent_id})`,\n        agent_count: state.agents.filter((a) => a.status === \"running\").length,\n        stale_agents: staleAgents.map((a) => a.agent_id),\n      },\n    };\n  } finally {\n    releaseLock(input.cwd);\n  }\n}\n\n/**\n * Process SubagentStop event\n */\nexport function processSubagentStop(input: SubagentStopInput): HookOutput {\n  if (!acquireLock(input.cwd)) {\n    return { continue: true }; // Fail gracefully\n  }\n\n  try {\n    const state = readTrackingState(input.cwd);\n\n    // Find the agent\n    const agentIndex = state.agents.findIndex(\n      (a) => a.agent_id === input.agent_id,\n    );\n\n    // SDK does not provide `success` field, so default to 'completed' when undefined (Bug #1 fix)\n    const succeeded = input.success !== false;\n\n    if (agentIndex !== -1) {\n      const agent = state.agents[agentIndex];\n      agent.status = succeeded ? \"completed\" : \"failed\";\n      agent.completed_at = new Date().toISOString();\n\n      // Calculate duration\n      const startTime = new Date(agent.started_at).getTime();\n      const endTime = new Date(agent.completed_at).getTime();\n      agent.duration_ms = endTime - startTime;\n\n      // Store output summary (truncated)\n      if (input.output) {\n        agent.output_summary = input.output.substring(0, 500);\n      }\n\n      // Update counters\n      if (succeeded) {\n        state.total_completed++;\n      } else {\n        state.total_failed++;\n      }\n    }\n\n    // Evict oldest completed agents if over limit\n    const completedAgents = state.agents.filter(\n      (a) => a.status === \"completed\" || a.status === \"failed\",\n    );\n    if (completedAgents.length > MAX_COMPLETED_AGENTS) {\n      // Sort by completed_at and keep only the most recent\n      completedAgents.sort((a, b) => {\n        const timeA = a.completed_at ? new Date(a.completed_at).getTime() : 0;\n        const timeB = b.completed_at ? new Date(b.completed_at).getTime() : 0;\n        return timeB - timeA; // Newest first\n      });\n\n      const toRemove = new Set(\n        completedAgents.slice(MAX_COMPLETED_AGENTS).map((a) => a.agent_id),\n      );\n      state.agents = state.agents.filter((a) => !toRemove.has(a.agent_id));\n    }\n\n    // Write updated state\n    writeTrackingState(input.cwd, state);\n\n    // Record to session replay JSONL for /trace\n    // Fix: SDK doesn't populate agent_type in SubagentStop, so use tracked state\n    try {\n      const trackedAgent = agentIndex !== -1 ? state.agents[agentIndex] : undefined;\n      const agentType = trackedAgent?.agent_type || input.agent_type || 'unknown';\n      recordAgentStop(input.cwd, input.session_id, input.agent_id, agentType, succeeded, trackedAgent?.duration_ms);\n    } catch { /* best-effort */ }\n\n    const runningCount = state.agents.filter(\n      (a) => a.status === \"running\",\n    ).length;\n\n    return {\n      continue: true,\n      hookSpecificOutput: {\n        hookEventName: \"SubagentStop\",\n        additionalContext: `Agent ${input.agent_type} ${succeeded ? \"completed\" : \"failed\"} (${input.agent_id})`,\n        agent_count: runningCount,\n      },\n    };\n  } finally {\n    releaseLock(input.cwd);\n  }\n}\n\n// ============================================================================\n// Cleanup Functions\n// ============================================================================\n\n/**\n * Cleanup stale agents (mark as failed)\n */\nexport function cleanupStaleAgents(directory: string): number {\n  if (!acquireLock(directory)) {\n    return 0; // Could not acquire lock\n  }\n\n  try {\n    const state = readTrackingState(directory);\n    const staleAgents = getStaleAgents(state);\n\n    if (staleAgents.length === 0) {\n      return 0;\n    }\n\n    for (const stale of staleAgents) {\n      const agentIndex = state.agents.findIndex(\n        (a) => a.agent_id === stale.agent_id,\n      );\n      if (agentIndex !== -1) {\n        state.agents[agentIndex].status = \"failed\";\n        state.agents[agentIndex].completed_at = new Date().toISOString();\n        state.agents[agentIndex].output_summary =\n          \"Marked as stale - exceeded timeout\";\n        state.total_failed++;\n      }\n    }\n\n    writeTrackingState(directory, state);\n\n    return staleAgents.length;\n  } finally {\n    releaseLock(directory);\n  }\n}\n\n// ============================================================================\n// Query Functions\n// ============================================================================\n\n/**\n * Get count of active (running) agents\n */\nexport function getActiveAgentCount(directory: string): number {\n  const state = readTrackingState(directory);\n  return state.agents.filter((a) => a.status === \"running\").length;\n}\n\n/**\n * Get agents by type\n */\nexport function getAgentsByType(\n  directory: string,\n  agentType: string,\n): SubagentInfo[] {\n  const state = readTrackingState(directory);\n  return state.agents.filter((a) => a.agent_type === agentType);\n}\n\n/**\n * Get all running agents\n */\nexport function getRunningAgents(directory: string): SubagentInfo[] {\n  const state = readTrackingState(directory);\n  return state.agents.filter((a) => a.status === \"running\");\n}\n\n/**\n * Get tracking stats\n */\nexport function getTrackingStats(directory: string): {\n  running: number;\n  completed: number;\n  failed: number;\n  total: number;\n} {\n  const state = readTrackingState(directory);\n  return {\n    running: state.agents.filter((a) => a.status === \"running\").length,\n    completed: state.total_completed,\n    failed: state.total_failed,\n    total: state.total_spawned,\n  };\n}\n\n/**\n * Record a tool usage event for a specific agent\n * Called from PreToolUse/PostToolUse hooks to track which agent uses which tool\n */\nexport function recordToolUsage(\n  directory: string,\n  agentId: string,\n  toolName: string,\n  success?: boolean,\n): void {\n  if (!acquireLock(directory)) return;\n\n  try {\n    const state = readTrackingState(directory);\n    const agent = state.agents.find(\n      (a) => a.agent_id === agentId && a.status === \"running\",\n    );\n\n    if (agent) {\n      if (!agent.tool_usage) agent.tool_usage = [];\n      // Keep last 50 tool usages per agent to prevent unbounded growth\n      if (agent.tool_usage.length >= 50) {\n        agent.tool_usage = agent.tool_usage.slice(-49);\n      }\n      agent.tool_usage.push({\n        tool_name: toolName,\n        timestamp: new Date().toISOString(),\n        success,\n      });\n      writeTrackingState(directory, state);\n    }\n  } finally {\n    releaseLock(directory);\n  }\n}\n\n/**\n * Record tool usage with timing data\n * Called from PostToolUse hook with duration information\n */\nexport function recordToolUsageWithTiming(\n  directory: string,\n  agentId: string,\n  toolName: string,\n  durationMs: number,\n  success: boolean,\n): void {\n  if (!acquireLock(directory)) return;\n\n  try {\n    const state = readTrackingState(directory);\n    const agent = state.agents.find(\n      (a) => a.agent_id === agentId && a.status === \"running\",\n    );\n\n    if (agent) {\n      if (!agent.tool_usage) agent.tool_usage = [];\n      if (agent.tool_usage.length >= 50) {\n        agent.tool_usage = agent.tool_usage.slice(-49);\n      }\n      agent.tool_usage.push({\n        tool_name: toolName,\n        timestamp: new Date().toISOString(),\n        duration_ms: durationMs,\n        success,\n      });\n      writeTrackingState(directory, state);\n    }\n  } finally {\n    releaseLock(directory);\n  }\n}\n\n/**\n * Generate a formatted dashboard of all running agents\n * Used for debugging parallel agent execution in ultrawork mode\n */\nexport function getAgentDashboard(directory: string): string {\n  const state = readTrackingState(directory);\n  const running = state.agents.filter((a) => a.status === \"running\");\n\n  if (running.length === 0) return \"\";\n\n  const now = Date.now();\n  const lines: string[] = [`Agent Dashboard (${running.length} active):`];\n\n  for (const agent of running) {\n    const elapsed = Math.round(\n      (now - new Date(agent.started_at).getTime()) / 1000,\n    );\n    const shortType = agent.agent_type.replace(\"ultrapower:\", \"\");\n    const toolCount = agent.tool_usage?.length || 0;\n    const lastTool =\n      agent.tool_usage?.[agent.tool_usage.length - 1]?.tool_name || \"-\";\n    const desc = agent.task_description\n      ? ` \"${agent.task_description.substring(0, 60)}\"`\n      : \"\";\n\n    lines.push(\n      `  [${agent.agent_id.substring(0, 7)}] ${shortType} (${elapsed}s) tools:${toolCount} last:${lastTool}${desc}`,\n    );\n  }\n\n  const stale = getStaleAgents(state);\n  if (stale.length > 0) {\n    lines.push(`   ${stale.length} stale agent(s) detected`);\n  }\n\n  return lines.join(\"\\n\");\n}\n\n/**\n * Generate a rich observatory view of all running agents\n * Includes: performance metrics, token usage, file ownership, bottlenecks\n * For HUD integration and debugging parallel agent execution\n */\nexport function getAgentObservatory(directory: string): {\n  header: string;\n  lines: string[];\n  summary: {\n    total_agents: number;\n    total_cost_usd: number;\n    efficiency: number;\n    interventions: number;\n  };\n} {\n  const state = readTrackingState(directory);\n  const running = state.agents.filter((a) => a.status === \"running\");\n  const efficiency = calculateParallelEfficiency(directory);\n  const interventions = suggestInterventions(directory);\n\n  const now = Date.now();\n  const lines: string[] = [];\n  let totalCost = 0;\n\n  for (const agent of running) {\n    const elapsed = Math.round(\n      (now - new Date(agent.started_at).getTime()) / 1000,\n    );\n    const shortType = agent.agent_type.replace(\"ultrapower:\", \"\");\n    const toolCount = agent.tool_usage?.length || 0;\n\n    // Token and cost info\n    const cost = agent.token_usage?.cost_usd || 0;\n    totalCost += cost;\n    const tokens = agent.token_usage\n      ? `${Math.round((agent.token_usage.input_tokens + agent.token_usage.output_tokens) / 1000)}k`\n      : \"-\";\n\n    // Status indicator\n    const stale = getStaleAgents(state).some(\n      (s) => s.agent_id === agent.agent_id,\n    );\n    const hasIntervention = interventions.some(\n      (i) => i.agent_id === agent.agent_id,\n    );\n    const status = stale ? \"\" : hasIntervention ? \"\" : \"\";\n\n    // Bottleneck detection\n    const perf = getAgentPerformance(directory, agent.agent_id);\n    const bottleneck = perf?.bottleneck || \"\";\n\n    // File ownership\n    const files = agent.file_ownership?.length || 0;\n\n    // Build line\n    let line = `${status} [${agent.agent_id.substring(0, 7)}] ${shortType} ${elapsed}s`;\n    line += ` tools:${toolCount} tokens:${tokens}`;\n    if (cost > 0) line += ` $${cost.toFixed(2)}`;\n    if (files > 0) line += ` files:${files}`;\n    if (bottleneck) line += `\\n    bottleneck: ${bottleneck}`;\n\n    lines.push(line);\n  }\n\n  // Add intervention warnings at the end\n  for (const intervention of interventions.slice(0, 3)) {\n    const shortType = intervention.agent_type.replace(\"ultrapower:\", \"\");\n    lines.push(` ${shortType}: ${intervention.reason}`);\n  }\n\n  const header = `Agent Observatory (${running.length} active, ${efficiency.score}% efficiency)`;\n\n  return {\n    header,\n    lines,\n    summary: {\n      total_agents: running.length,\n      total_cost_usd: totalCost,\n      efficiency: efficiency.score,\n      interventions: interventions.length,\n    },\n  };\n}\n\n// ============================================================================\n// Intervention Functions\n// ============================================================================\n\n/**\n * Suggest interventions for problematic agents\n * Checks for: stale agents, cost limit exceeded, file conflicts\n */\nexport function suggestInterventions(directory: string): AgentIntervention[] {\n  const state = readTrackingState(directory);\n  const interventions: AgentIntervention[] = [];\n  const running = state.agents.filter((a) => a.status === \"running\");\n\n  // 1. Stale agent detection\n  const stale = getStaleAgents(state);\n  for (const agent of stale) {\n    const elapsed = Math.round(\n      (Date.now() - new Date(agent.started_at).getTime()) / 1000 / 60,\n    );\n    interventions.push({\n      type: \"timeout\",\n      agent_id: agent.agent_id,\n      agent_type: agent.agent_type,\n      reason: `Agent running for ${elapsed}m (threshold: 5m)`,\n      suggested_action: \"kill\",\n      auto_execute: elapsed > 10, // Auto-kill after 10 minutes\n    });\n  }\n\n  // 2. Cost limit detection\n  for (const agent of running) {\n    if (agent.token_usage && agent.token_usage.cost_usd > COST_LIMIT_USD) {\n      interventions.push({\n        type: \"excessive_cost\",\n        agent_id: agent.agent_id,\n        agent_type: agent.agent_type,\n        reason: `Cost $${agent.token_usage.cost_usd.toFixed(2)} exceeds limit $${COST_LIMIT_USD.toFixed(2)}`,\n        suggested_action: \"warn\",\n        auto_execute: false,\n      });\n    }\n  }\n\n  // 3. File conflict detection\n  const fileToAgents = new Map<string, Array<{ id: string; type: string }>>();\n  for (const agent of running) {\n    for (const file of agent.file_ownership || []) {\n      if (!fileToAgents.has(file)) {\n        fileToAgents.set(file, []);\n      }\n      fileToAgents\n        .get(file)!\n        .push({ id: agent.agent_id, type: agent.agent_type });\n    }\n  }\n\n  for (const [file, agents] of fileToAgents) {\n    if (agents.length > 1) {\n      // Warn all but first agent (first one \"owns\" the file)\n      for (let i = 1; i < agents.length; i++) {\n        interventions.push({\n          type: \"file_conflict\",\n          agent_id: agents[i].id,\n          agent_type: agents[i].type,\n          reason: `File conflict on ${file} with ${agents[0].type.replace(\"ultrapower:\", \"\")}`,\n          suggested_action: \"warn\",\n          auto_execute: false,\n        });\n      }\n    }\n  }\n\n  return interventions;\n}\n\n/**\n * Calculate parallel efficiency score (0-100)\n * 100 = all agents actively running, 0 = all stale/waiting\n */\nexport function calculateParallelEfficiency(directory: string): {\n  score: number;\n  active: number;\n  stale: number;\n  total: number;\n} {\n  const state = readTrackingState(directory);\n  const running = state.agents.filter((a) => a.status === \"running\");\n  const stale = getStaleAgents(state);\n\n  if (running.length === 0)\n    return { score: 100, active: 0, stale: 0, total: 0 };\n\n  const active = running.length - stale.length;\n  const score = Math.round((active / running.length) * 100);\n\n  return { score, active, stale: stale.length, total: running.length };\n}\n\n// ============================================================================\n// File Ownership Functions\n// ============================================================================\n\n/**\n * Record file ownership when an agent modifies a file\n * Called from PreToolUse hook when Edit/Write tools are used\n */\nexport function recordFileOwnership(\n  directory: string,\n  agentId: string,\n  filePath: string,\n): void {\n  if (!acquireLock(directory)) return;\n\n  try {\n    const state = readTrackingState(directory);\n    const agent = state.agents.find(\n      (a) => a.agent_id === agentId && a.status === \"running\",\n    );\n\n    if (agent) {\n      if (!agent.file_ownership) agent.file_ownership = [];\n      // Normalize and deduplicate\n      const normalized = filePath.replace(directory, \"\").replace(/^\\//, \"\");\n      if (!agent.file_ownership.includes(normalized)) {\n        agent.file_ownership.push(normalized);\n        // Cap at 100 files per agent\n        if (agent.file_ownership.length > 100) {\n          agent.file_ownership = agent.file_ownership.slice(-100);\n        }\n        writeTrackingState(directory, state);\n      }\n    }\n  } finally {\n    releaseLock(directory);\n  }\n}\n\n/**\n * Check for file conflicts between running agents\n * Returns files being modified by more than one agent\n */\nexport function detectFileConflicts(directory: string): Array<{\n  file: string;\n  agents: string[];\n}> {\n  const state = readTrackingState(directory);\n  const running = state.agents.filter((a) => a.status === \"running\");\n\n  const fileToAgents = new Map<string, string[]>();\n\n  for (const agent of running) {\n    for (const file of agent.file_ownership || []) {\n      if (!fileToAgents.has(file)) {\n        fileToAgents.set(file, []);\n      }\n      fileToAgents\n        .get(file)!\n        .push(agent.agent_type.replace(\"ultrapower:\", \"\"));\n    }\n  }\n\n  const conflicts: Array<{ file: string; agents: string[] }> = [];\n  for (const [file, agents] of fileToAgents) {\n    if (agents.length > 1) {\n      conflicts.push({ file, agents });\n    }\n  }\n\n  return conflicts;\n}\n\n/**\n * Get all file ownership for running agents\n */\nexport function getFileOwnershipMap(directory: string): Map<string, string> {\n  const state = readTrackingState(directory);\n  const running = state.agents.filter((a) => a.status === \"running\");\n  const map = new Map<string, string>();\n\n  for (const agent of running) {\n    const shortType = agent.agent_type.replace(\"ultrapower:\", \"\");\n    for (const file of agent.file_ownership || []) {\n      map.set(file, shortType);\n    }\n  }\n\n  return map;\n}\n\n// ============================================================================\n// Performance Query Functions\n// ============================================================================\n\n/**\n * Get performance metrics for a specific agent\n */\nexport function getAgentPerformance(\n  directory: string,\n  agentId: string,\n): AgentPerformance | null {\n  const state = readTrackingState(directory);\n  const agent = state.agents.find((a) => a.agent_id === agentId);\n  if (!agent) return null;\n\n  const toolTimings: Record<string, ToolTimingStats> = {};\n\n  for (const entry of agent.tool_usage || []) {\n    if (!toolTimings[entry.tool_name]) {\n      toolTimings[entry.tool_name] = {\n        count: 0,\n        avg_ms: 0,\n        max_ms: 0,\n        total_ms: 0,\n        failures: 0,\n      };\n    }\n    const stats = toolTimings[entry.tool_name];\n    stats.count++;\n    if (entry.duration_ms !== undefined) {\n      stats.total_ms += entry.duration_ms;\n      stats.max_ms = Math.max(stats.max_ms, entry.duration_ms);\n      stats.avg_ms = Math.round(stats.total_ms / stats.count);\n    }\n    if (entry.success === false) stats.failures++;\n  }\n\n  // Find bottleneck (tool with highest avg_ms that has been called 2+ times)\n  let bottleneck: string | undefined;\n  let maxAvg = 0;\n  for (const [tool, stats] of Object.entries(toolTimings)) {\n    if (stats.count >= 2 && stats.avg_ms > maxAvg) {\n      maxAvg = stats.avg_ms;\n      bottleneck = `${tool} (${(stats.avg_ms / 1000).toFixed(1)}s avg)`;\n    }\n  }\n\n  return {\n    agent_id: agentId,\n    tool_timings: toolTimings,\n    token_usage: agent.token_usage || {\n      input_tokens: 0,\n      output_tokens: 0,\n      cache_read_tokens: 0,\n      cost_usd: 0,\n    },\n    bottleneck,\n  };\n}\n\n/**\n * Get performance for all running agents\n */\nexport function getAllAgentPerformance(directory: string): AgentPerformance[] {\n  const state = readTrackingState(directory);\n  return state.agents\n    .filter((a) => a.status === \"running\")\n    .map((a) => getAgentPerformance(directory, a.agent_id))\n    .filter((p): p is AgentPerformance => p !== null);\n}\n\n/**\n * Update token usage for an agent (called from SubagentStop)\n */\nexport function updateTokenUsage(\n  directory: string,\n  agentId: string,\n  tokens: Partial<TokenUsage>,\n): void {\n  if (!acquireLock(directory)) return;\n\n  try {\n    const state = readTrackingState(directory);\n    const agent = state.agents.find((a) => a.agent_id === agentId);\n\n    if (agent) {\n      if (!agent.token_usage) {\n        agent.token_usage = {\n          input_tokens: 0,\n          output_tokens: 0,\n          cache_read_tokens: 0,\n          cost_usd: 0,\n        };\n      }\n      if (tokens.input_tokens !== undefined)\n        agent.token_usage.input_tokens += tokens.input_tokens;\n      if (tokens.output_tokens !== undefined)\n        agent.token_usage.output_tokens += tokens.output_tokens;\n      if (tokens.cache_read_tokens !== undefined)\n        agent.token_usage.cache_read_tokens += tokens.cache_read_tokens;\n      if (tokens.cost_usd !== undefined) agent.token_usage.cost_usd += tokens.cost_usd;\n      writeTrackingState(directory, state);\n    }\n  } finally {\n    releaseLock(directory);\n  }\n}\n\n// ============================================================================\n// Main Entry Points\n// ============================================================================\n\n/**\n * Handle SubagentStart hook\n */\nexport async function handleSubagentStart(\n  input: SubagentStartInput,\n): Promise<HookOutput> {\n  return processSubagentStart(input);\n}\n\n/**\n * Handle SubagentStop hook\n */\nexport async function handleSubagentStop(\n  input: SubagentStopInput,\n): Promise<HookOutput> {\n  return processSubagentStop(input);\n}\n\n/**\n * Clear all tracking state (for testing or cleanup)\n */\nexport function clearTrackingState(directory: string): void {\n  const statePath = getStateFilePath(directory);\n  if (existsSync(statePath)) {\n    try {\n      unlinkSync(statePath);\n    } catch (error) {\n      console.error(\"[SubagentTracker] Error clearing state:\", error);\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\subagent-tracker\\session-replay.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\team-pipeline\\__tests__\\transitions.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\team-pipeline\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\team-pipeline\\state.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\team-pipeline\\transitions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\team-pipeline\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\think-mode\\__tests__\\index.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\think-mode\\detector.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\think-mode\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\think-mode\\switcher.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\think-mode\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\thinking-block-validator\\constants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\thinking-block-validator\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\thinking-block-validator\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\todo-continuation\\__tests__\\isUserAbort.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\todo-continuation\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\ultrapilot\\decomposer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\ultrapilot\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\ultrapilot\\state.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\ultrapilot\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\ultraqa\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\ultrawork\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hooks\\ultrawork\\session-isolation.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hud\\analytics-display.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hud\\background-cleanup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hud\\background-tasks.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hud\\colors.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hud\\elements\\agents.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hud\\elements\\autopilot.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hud\\elements\\axiom.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hud\\elements\\background.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hud\\elements\\call-counts.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hud\\elements\\context-warning.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hud\\elements\\context.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hud\\elements\\cwd.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hud\\elements\\git.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hud\\elements\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hud\\elements\\limits.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hud\\elements\\model.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hud\\elements\\permission.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hud\\elements\\prd.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hud\\elements\\ralph.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hud\\elements\\session.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hud\\elements\\skills.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hud\\elements\\suggestions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hud\\elements\\thinking.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hud\\elements\\todos.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hud\\index.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":55,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":55,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1654,1657],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1654,1657],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":56,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":56,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1677,1680],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1677,1680],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":72,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":72,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2104,2107],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2104,2107],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\n/**\n * OMC HUD - Main Entry Point\n *\n * Statusline command that visualizes ultrapower state.\n * Receives stdin JSON from Claude Code and outputs formatted statusline.\n */\n\nimport { readStdin, getContextPercent, getModelName } from \"./stdin.js\";\nimport { parseTranscript } from \"./transcript.js\";\nimport {\n  readHudState,\n  readHudConfig,\n  getRunningTasks,\n  writeHudState,\n  initializeHUDState,\n} from \"./state.js\";\nimport {\n  readRalphStateForHud,\n  readUltraworkStateForHud,\n  readPrdStateForHud,\n  readAutopilotStateForHud,\n} from \"./omc-state.js\";\nimport { readAxiomStateForHud } from \"./elements/axiom.js\";\nimport { generateSuggestions } from \"./elements/suggestions.js\";\nimport { getUsage } from \"./usage-api.js\";\nimport { render } from \"./render.js\";\nimport { sanitizeOutput } from \"./sanitize.js\";\nimport type {\n  HudRenderContext,\n  SessionHealth,\n  StatuslineStdin,\n} from \"./types.js\";\nimport {\n  extractTokens,\n  createSnapshot,\n  type TokenSnapshot,\n} from \"../analytics/token-extractor.js\";\nimport { extractSessionId } from \"../analytics/output-estimator.js\";\nimport { getTokenTracker } from \"../analytics/token-tracker.js\";\nimport { getRuntimePackageVersion } from \"../lib/version.js\";\nimport { compareVersions } from \"../features/auto-update.js\";\nimport { existsSync, readFileSync, _writeFileSync } from \"fs\";\nimport { join } from \"path\";\nimport { homedir } from \"os\";\n\n// Persistent token snapshot for delta calculations\nlet previousSnapshot: TokenSnapshot | null = null;\n\n/**\n * Record token usage to analytics tracker.\n * Silent failure - doesn't break HUD rendering.\n */\nasync function recordTokenUsage(\n  stdin: any,\n  transcriptData: any,\n): Promise<void> {\n  try {\n    // Debug: Log stdin.context_window data\n    if (process.env.OMC_DEBUG) {\n      console.error(\n        \"[TokenRecording] stdin.context_window:\",\n        JSON.stringify(stdin.context_window),\n      );\n    }\n\n    // Get model name from stdin\n    const modelName = getModelName(stdin);\n\n    // Get running agents from transcript\n    const runningAgents =\n      transcriptData.agents?.filter((a: any) => a.status === \"running\") ?? [];\n    const agentName =\n      runningAgents.length > 0 ? runningAgents[0].name : undefined;\n\n    if (process.env.OMC_DEBUG) {\n      console.error(\"[TokenRecording] agentName determined:\", agentName);\n    }\n\n    // Extract tokens (delta from previous)\n    const extracted = extractTokens(\n      stdin,\n      previousSnapshot,\n      modelName,\n      agentName,\n    );\n\n    if (process.env.OMC_DEBUG) {\n      console.error(\"[TokenRecording] extracted tokens:\", {\n        inputTokens: extracted.inputTokens,\n        outputTokens: extracted.outputTokens,\n        cacheCreationTokens: extracted.cacheCreationTokens,\n        cacheReadTokens: extracted.cacheReadTokens,\n        agentName: extracted.agentName,\n        modelName: extracted.modelName,\n      });\n    }\n\n    // Only record if there's actual token usage\n    if (extracted.inputTokens > 0 || extracted.cacheCreationTokens > 0) {\n      if (process.env.OMC_DEBUG) {\n        console.error(\n          \"[TokenRecording] Recording condition PASSED - recording usage\",\n        );\n      }\n\n      // Get session ID\n      const sessionId = extractSessionId(stdin.transcript_path);\n\n      // Get tracker and record\n      const tracker = getTokenTracker(sessionId);\n      await tracker.recordTokenUsage({\n        agentName: extracted.agentName,\n        modelName: extracted.modelName,\n        inputTokens: extracted.inputTokens,\n        outputTokens: extracted.outputTokens,\n        cacheCreationTokens: extracted.cacheCreationTokens,\n        cacheReadTokens: extracted.cacheReadTokens,\n      });\n\n      if (process.env.OMC_DEBUG) {\n        console.error(\n          \"[TokenRecording] Successfully recorded usage for agent:\",\n          extracted.agentName,\n        );\n      }\n    } else {\n      if (process.env.OMC_DEBUG) {\n        console.error(\n          \"[TokenRecording] Recording condition FAILED - no token delta detected\",\n        );\n      }\n    }\n\n    // Update snapshot for next render\n    previousSnapshot = createSnapshot(stdin);\n  } catch (error) {\n    // Silent failure - don't break HUD rendering\n    if (process.env.OMC_DEBUG) {\n      console.error(\"[Analytics] Token recording failed:\", error);\n    }\n  }\n}\n\n/**\n * Fallback: compute session analytics from in-memory TokenTracker stats.\n * Used when loadAnalyticsFast() returns null or throws.\n *\n * NOTE: This works because recordTokenUsage() is called BEFORE calculateSessionHealth()\n * in main() (line 167 before line 203). The first call to getTokenTracker(sessionId)\n * creates the singleton with the correct sessionId and populates it. Subsequent calls\n * get the same instance regardless of the sessionId parameter (see token-tracker.ts:274-278).\n * DO NOT reorder recordTokenUsage/calculateSessionHealth in main().\n *\n * @returns Analytics fields or null if no token data available\n */\nasync function _getTokenTrackerFallback(\n  sessionId: string,\n  durationMs: number,\n): Promise<{\n  sessionCost: number;\n  totalTokens: number;\n  cacheHitRate: number;\n  costPerHour: number;\n} | null> {\n  const tracker = getTokenTracker(sessionId);\n  const stats = tracker.getSessionStats();\n\n  if (stats.totalInputTokens === 0 && stats.totalCacheCreation === 0) {\n    return null;\n  }\n\n  const { calculateCost } = await import(\"../analytics/cost-estimator.js\");\n\n  let cost = 0;\n  for (const [model, usages] of Object.entries(stats.byModel)) {\n    for (const usage of usages) {\n      const c = calculateCost({\n        modelName: model,\n        inputTokens: usage.inputTokens,\n        outputTokens: usage.outputTokens,\n        cacheCreationTokens: usage.cacheCreationTokens,\n        cacheReadTokens: usage.cacheReadTokens,\n      });\n      cost += c.totalCost;\n    }\n  }\n\n  const totalTokens = stats.totalInputTokens + stats.totalOutputTokens;\n  const totalInput = stats.totalInputTokens + stats.totalCacheCreation + stats.totalCacheRead;\n  const cacheHitRate =\n    totalInput > 0 ? (stats.totalCacheRead / totalInput) * 100 : 0;\n  const hours = durationMs / (1000 * 60 * 60);\n  const costPerHour = hours > 0 ? cost / hours : 0;\n\n  return { sessionCost: cost, totalTokens, cacheHitRate, costPerHour };\n}\n\n/**\n * Calculate session health from session start time and LIVE stdin data.\n * Uses stdin's current_usage for real-time token display.\n */\nasync function calculateSessionHealth(\n  sessionStart: Date | undefined,\n  contextPercent: number,\n  stdin: StatuslineStdin,\n  thresholds?: { budgetWarning: number; budgetCritical: number },\n): Promise<SessionHealth | null> {\n  // Calculate duration (use 0 if no session start)\n  const durationMs = sessionStart ? Date.now() - sessionStart.getTime() : 0;\n  const durationMinutes = Math.floor(durationMs / 60_000);\n\n  let health: SessionHealth[\"health\"] = \"healthy\";\n  if (durationMinutes > 120 || contextPercent > 85) {\n    health = \"critical\";\n  } else if (durationMinutes > 60 || contextPercent > 70) {\n    health = \"warning\";\n  }\n\n  // Get LIVE token data from stdin (not from analytics files)\n  const usage = stdin.context_window?.current_usage;\n  const inputTokens = usage?.input_tokens ?? 0;\n  const cacheCreationTokens = usage?.cache_creation_input_tokens ?? 0;\n  const cacheReadTokens = usage?.cache_read_input_tokens ?? 0;\n\n  // Debug: log token data if OMC_DEBUG is set\n  if (process.env.OMC_DEBUG) {\n    console.error(\"[HUD DEBUG] current_usage:\", JSON.stringify(usage));\n    console.error(\"[HUD DEBUG] tokens:\", {\n      inputTokens,\n      cacheCreationTokens,\n      cacheReadTokens,\n    });\n  }\n\n  // Calculate totals from live data\n  const totalTokens = inputTokens + cacheCreationTokens + cacheReadTokens;\n  const totalInputForCache = inputTokens + cacheCreationTokens;\n  const cacheHitRate =\n    totalInputForCache > 0\n      ? (cacheReadTokens / (totalInputForCache + cacheReadTokens)) * 100\n      : 0;\n\n  // Estimate output tokens and cost\n  let sessionCost = 0;\n  let costPerHour = 0;\n  const isEstimated = true;\n\n  try {\n    const { calculateCost } = await import(\"../analytics/cost-estimator.js\");\n    const { estimateOutputTokens } =\n      await import(\"../analytics/output-estimator.js\");\n\n    const modelName =\n      stdin.model?.id ?? stdin.model?.display_name ?? \"claude-sonnet-4.6\";\n    const estimatedOutput = estimateOutputTokens(inputTokens, modelName);\n\n    const costResult = calculateCost({\n      modelName,\n      inputTokens,\n      outputTokens: estimatedOutput,\n      cacheCreationTokens,\n      cacheReadTokens,\n    });\n\n    sessionCost = costResult.totalCost;\n\n    // Calculate cost per hour\n    const hours = durationMs / (1000 * 60 * 60);\n    costPerHour = hours > 0 ? sessionCost / hours : 0;\n\n    // Adjust health based on cost (Budget warnings)\n    const budgetCritical = thresholds?.budgetCritical ?? 5.0;\n    const budgetWarning = thresholds?.budgetWarning ?? 2.0;\n    if (sessionCost > budgetCritical) {\n      health = \"critical\";\n    } else if (sessionCost > budgetWarning && health !== \"critical\") {\n      health = \"warning\";\n    }\n  } catch (error) {\n    if (process.env.OMC_DEBUG) {\n      console.error(\"[HUD] Cost calculation failed:\", error);\n    }\n    // Cost calculation failed - continue with zeros\n  }\n\n  // Get top agents from tracker\n  let topAgents: Array<{ agent: string; cost: number }> = [];\n  try {\n    const sessionId = extractSessionId(stdin.transcript_path);\n    if (sessionId) {\n      const tracker = getTokenTracker(sessionId);\n      const agents = await tracker.getTopAgents(3);\n      topAgents = agents.map((a) => ({ agent: a.agent, cost: a.cost }));\n    }\n  } catch (error) {\n    if (process.env.OMC_DEBUG) {\n      console.error(\"[HUD] Top agents fetch failed:\", error);\n    }\n    // Top agents fetch failed - continue with empty\n  }\n\n  return {\n    durationMinutes,\n    messageCount: 0,\n    health,\n    sessionCost,\n    totalTokens,\n    cacheHitRate,\n    topAgents,\n    costPerHour,\n    isEstimated,\n  };\n}\n\n/**\n * Main HUD entry point\n */\nasync function main(): Promise<void> {\n  try {\n    // Initialize HUD state (cleanup stale/orphaned tasks)\n    await initializeHUDState();\n\n    // Read stdin from Claude Code\n    const stdin = await readStdin();\n\n    if (!stdin) {\n      // No stdin - suggest setup\n      console.log(\"[OMC] run /omc-setup to install properly\");\n      return;\n    }\n\n    const cwd = stdin.cwd || process.cwd();\n\n    // Read configuration (before transcript parsing so we can use staleTaskThresholdMinutes)\n    const config = readHudConfig();\n\n    // Parse transcript for agents and todos\n    const transcriptData = await parseTranscript(stdin.transcript_path, {\n      staleTaskThresholdMinutes: config.staleTaskThresholdMinutes,\n    });\n\n    // Record token usage (auto-tracking)\n    await recordTokenUsage(stdin, transcriptData);\n\n    // Read OMC state files\n    const ralph = readRalphStateForHud(cwd);\n    const ultrawork = readUltraworkStateForHud(cwd);\n    const prd = readPrdStateForHud(cwd);\n    const autopilot = readAutopilotStateForHud(cwd);\n    const axiom = readAxiomStateForHud(cwd);\n\n    // Read HUD state for background tasks\n    const hudState = readHudState(cwd);\n    const _backgroundTasks = hudState?.backgroundTasks || [];\n\n    // Persist session start time to survive tail-parsing resets (#528)\n    // When tail parsing kicks in for large transcripts, sessionStart comes from\n    // the first entry in the tail chunk rather than the actual session start.\n    // We persist the real start time in HUD state on first observation.\n    // Scoped per session ID so a new session in the same cwd resets the timestamp.\n    let sessionStart = transcriptData.sessionStart;\n    const currentSessionId = extractSessionId(stdin.transcript_path);\n    const sameSession = hudState?.sessionId === currentSessionId;\n    if (sameSession && hudState?.sessionStartTimestamp) {\n      // Use persisted value (the real session start) - but validate first\n      const persisted = new Date(hudState.sessionStartTimestamp);\n      if (!isNaN(persisted.getTime())) {\n        sessionStart = persisted;\n      }\n      // If invalid, fall through to transcript-derived sessionStart\n    } else if (sessionStart) {\n      // First time seeing session start (or new session) - persist it\n      const stateToWrite = hudState || { timestamp: new Date().toISOString(), backgroundTasks: [] };\n      stateToWrite.sessionStartTimestamp = sessionStart.toISOString();\n      stateToWrite.sessionId = currentSessionId;\n      stateToWrite.timestamp = new Date().toISOString();\n      writeHudState(stateToWrite, cwd);\n    }\n\n    // Fetch rate limits from OAuth API (if available)\n    const rateLimits =\n      config.elements.rateLimits !== false ? await getUsage() : null;\n\n    // Read OMC version and update check cache\n    let omcVersion: string | null = null;\n    let updateAvailable: string | null = null;\n    try {\n      omcVersion = getRuntimePackageVersion();\n      if (omcVersion === 'unknown') omcVersion = null;\n    } catch {\n      // Ignore version detection errors\n    }\n    try {\n      const updateCacheFile = join(homedir(), '.omc', 'update-check.json');\n      if (existsSync(updateCacheFile)) {\n        const cached = JSON.parse(readFileSync(updateCacheFile, 'utf-8'));\n        if (cached?.latestVersion && omcVersion && compareVersions(omcVersion, cached.latestVersion) < 0) {\n          updateAvailable = cached.latestVersion;\n        }\n      }\n    } catch {\n      // Ignore update cache read errors\n    }\n\n    // Build render context\n    const sessionHealth = await calculateSessionHealth(\n      sessionStart,\n      getContextPercent(stdin),\n      stdin,\n      config.thresholds,\n    );\n    const activeAgents = transcriptData.agents.filter((a) => a.status === \"running\");\n\n    // Generate smart suggestions based on current state\n    const smartSuggestions = generateSuggestions({\n      contextPercent: getContextPercent(stdin),\n      axiom,\n      sessionHealth,\n      activeAgentCount: activeAgents.length,\n      contextWarningThreshold: config.contextLimitWarning.threshold,\n    });\n\n    const context: HudRenderContext = {\n      contextPercent: getContextPercent(stdin),\n      modelName: getModelName(stdin),\n      ralph,\n      ultrawork,\n      prd,\n      autopilot,\n      activeAgents,\n      todos: transcriptData.todos,\n      backgroundTasks: getRunningTasks(hudState),\n      cwd,\n      lastSkill: transcriptData.lastActivatedSkill || null,\n      rateLimits,\n      pendingPermission: transcriptData.pendingPermission || null,\n      thinkingState: transcriptData.thinkingState || null,\n      sessionHealth,\n      omcVersion,\n      updateAvailable,\n      toolCallCount: transcriptData.toolCallCount,\n      agentCallCount: transcriptData.agentCallCount,\n      skillCallCount: transcriptData.skillCallCount,\n      axiom,\n      smartSuggestions,\n    };\n\n    // Debug: log data if OMC_DEBUG is set\n    if (process.env.OMC_DEBUG) {\n      console.error(\n        \"[HUD DEBUG] stdin.context_window:\",\n        JSON.stringify(stdin.context_window),\n      );\n      console.error(\n        \"[HUD DEBUG] sessionHealth:\",\n        JSON.stringify(context.sessionHealth),\n      );\n    }\n\n    // Context monitoring only  autoCompact and compact suggestions disabled.\n    // Claude Code handles compaction automatically.\n\n    // Render and output\n    let output = await render(context, config);\n\n    // Apply safe mode sanitization if enabled (Issue #346)\n    // This strips ANSI codes and uses ASCII-only output to prevent\n    // terminal rendering corruption during concurrent updates\n    // On Windows, always use safe mode to prevent terminal rendering issues\n    // with non-breaking spaces and ANSI escape sequences\n    const useSafeMode = config.elements.safeMode || process.platform === 'win32';\n\n    if (useSafeMode) {\n      output = sanitizeOutput(output);\n      // In safe mode, use regular spaces (don't convert to non-breaking)\n      console.log(output);\n    } else {\n      // Replace spaces with non-breaking spaces for terminal alignment\n      const formattedOutput = output.replace(/ /g, \"\\u00A0\");\n      console.log(formattedOutput);\n    }\n  } catch (error) {\n    // Distinguish installation errors from runtime errors\n    const isInstallError =\n      error instanceof Error &&\n      (error.message.includes(\"ENOENT\") ||\n        error.message.includes(\"MODULE_NOT_FOUND\") ||\n        error.message.includes(\"Cannot find module\"));\n\n    if (isInstallError) {\n      console.log(\"[OMC] run /omc-setup to install properly\");\n    } else {\n      // Output fallback message to stdout for status line visibility\n      console.log(\"[OMC] HUD error - check stderr\");\n      // Log actual runtime errors to stderr for debugging\n      console.error(\n        \"[OMC HUD Error]\",\n        error instanceof Error ? error.message : error,\n      );\n    }\n  }\n}\n\n// Run main\nmain();\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hud\\omc-state.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hud\\render.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hud\\sanitize.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hud\\state.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hud\\stdin.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hud\\transcript.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hud\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\hud\\usage-api.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\index.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":365,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":365,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10497,10500],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10497,10500],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":366,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":366,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10535,10538],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10535,10538],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":367,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":367,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10574,10577],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10574,10577],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Oh-My-Claude-Sisyphus\n *\n * A multi-agent orchestration system for the Claude Agent SDK.\n * Inspired by oh-my-opencode, reimagined for Claude Code.\n *\n * Main features:\n * - Sisyphus: Primary orchestrator that delegates to specialized subagents\n * - Parallel execution: Background agents run concurrently\n * - LSP/AST tools: IDE-like capabilities for agents\n * - Context management: Auto-injection from AGENTS.md/CLAUDE.md\n * - Continuation enforcement: Ensures tasks complete before stopping\n * - Magic keywords: Special triggers for enhanced behaviors\n */\n\nimport { loadConfig, findContextFiles, loadContextFromFiles } from './config/loader.js';\nimport { getAgentDefinitions, omcSystemPrompt } from './agents/definitions.js';\nimport { getDefaultMcpServers, toSdkMcpFormat } from './mcp/servers.js';\nimport { omcToolsServer, getOmcToolNames } from './mcp/omc-tools-server.js';\nimport { codexMcpServer } from './mcp/codex-server.js';\nimport { geminiMcpServer } from './mcp/gemini-server.js';\nimport { createMagicKeywordProcessor, detectMagicKeywords } from './features/magic-keywords.js';\nimport { continuationSystemPromptAddition } from './features/continuation-enforcement.js';\nimport {\n  createBackgroundTaskManager,\n  shouldRunInBackground as shouldRunInBackgroundFn,\n  type BackgroundTaskManager,\n  type TaskExecutionDecision\n} from './features/background-tasks.js';\nimport type { PluginConfig, SessionState } from './shared/types.js';\n\nexport { loadConfig, getAgentDefinitions, omcSystemPrompt };\nexport { getDefaultMcpServers, toSdkMcpFormat } from './mcp/servers.js';\nexport { lspTools, astTools, allCustomTools } from './tools/index.js';\nexport { omcToolsServer, omcToolNames, getOmcToolNames } from './mcp/omc-tools-server.js';\nexport { createMagicKeywordProcessor, detectMagicKeywords } from './features/magic-keywords.js';\nexport {\n  createBackgroundTaskManager,\n  shouldRunInBackground,\n  getBackgroundTaskGuidance,\n  DEFAULT_MAX_BACKGROUND_TASKS,\n  LONG_RUNNING_PATTERNS,\n  BLOCKING_PATTERNS,\n  type BackgroundTaskManager,\n  type TaskExecutionDecision\n} from './features/background-tasks.js';\nexport {\n  // Auto-update types\n  type VersionMetadata,\n  type ReleaseInfo,\n  type UpdateCheckResult,\n  type UpdateResult,\n  // Auto-update constants\n  REPO_OWNER,\n  REPO_NAME,\n  GITHUB_API_URL,\n  CLAUDE_CONFIG_DIR,\n  VERSION_FILE,\n  // Auto-update functions\n  getInstalledVersion,\n  saveVersionMetadata,\n  checkForUpdates,\n  performUpdate,\n  formatUpdateNotification,\n  shouldCheckForUpdates,\n  backgroundUpdateCheck,\n  compareVersions\n} from './features/auto-update.js';\nexport * from './shared/types.js';\n\n// Hooks module exports\nexport * from './hooks/index.js';\n\n// Features module exports (boulder-state, context-injector)\nexport {\n  // Boulder State\n  type BoulderState,\n  type PlanProgress,\n  type PlanSummary,\n  BOULDER_DIR,\n  BOULDER_FILE,\n  BOULDER_STATE_PATH,\n  NOTEPAD_DIR,\n  NOTEPAD_BASE_PATH,\n  PLANNER_PLANS_DIR,\n  PLAN_EXTENSION,\n  getBoulderFilePath,\n  readBoulderState,\n  writeBoulderState,\n  appendSessionId,\n  clearBoulderState,\n  findPlannerPlans,\n  getPlanProgress,\n  getPlanName,\n  createBoulderState,\n  getPlanSummaries,\n  hasBoulder,\n  getActivePlanPath,\n  // Context Injector\n  ContextCollector,\n  contextCollector,\n  injectPendingContext,\n  injectContextIntoText,\n  createContextInjectorHook,\n  type ContextSourceType,\n  type ContextPriority,\n  type ContextEntry,\n  type RegisterContextOptions,\n  type PendingContext,\n  type MessageContext,\n  type OutputPart,\n  type InjectionStrategy,\n  type InjectionResult\n} from './features/index.js';\n\n// Agent module exports (modular agent system)\nexport {\n  // Types\n  type ModelType,\n  type AgentCost,\n  type AgentCategory,\n  type DelegationTrigger,\n  type AgentPromptMetadata,\n  type AgentConfig,\n  type FullAgentConfig,\n  type AgentOverrideConfig,\n  type AgentOverrides,\n  type AgentFactory,\n  type AvailableAgent,\n  isGptModel,\n  isClaudeModel,\n  getDefaultModelForCategory,\n  // Utilities\n  createAgentToolRestrictions,\n  mergeAgentConfig,\n  buildDelegationTable,\n  buildUseAvoidSection,\n  createEnvContext,\n  getAvailableAgents,\n  buildKeyTriggersSection,\n  validateAgentConfig,\n  deepMerge,\n  loadAgentPrompt,\n  // Individual agents with metadata (rebranded intuitive names)\n  architectAgent,\n  ARCHITECT_PROMPT_METADATA,\n  exploreAgent,\n  EXPLORE_PROMPT_METADATA,\n  researcherAgent,\n  DOCUMENT_SPECIALIST_PROMPT_METADATA,\n  executorAgent,\n  SISYPHUS_JUNIOR_PROMPT_METADATA,\n  designerAgent,\n  FRONTEND_ENGINEER_PROMPT_METADATA,\n  writerAgent,\n  DOCUMENT_WRITER_PROMPT_METADATA,\n  visionAgent,\n  MULTIMODAL_LOOKER_PROMPT_METADATA,\n  criticAgent,\n  CRITIC_PROMPT_METADATA,\n  analystAgent,\n  ANALYST_PROMPT_METADATA,\n  plannerAgent,\n  PLANNER_PROMPT_METADATA,\n  // Deprecated (backward compat - will be removed in v4.0.0)\n  coordinatorAgent,\n  ORCHESTRATOR_SISYPHUS_PROMPT_METADATA\n} from './agents/index.js';\n\n// Command expansion utilities for SDK integration\nexport {\n  expandCommand,\n  expandCommandPrompt,\n  getCommand,\n  getAllCommands,\n  listCommands,\n  commandExists,\n  expandCommands,\n  getCommandsDir,\n  type CommandInfo,\n  type ExpandedCommand\n} from './commands/index.js';\n\n// Installer exports\nexport {\n  install,\n  isInstalled,\n  getInstallInfo,\n  isClaudeInstalled,\n  CLAUDE_CONFIG_DIR as INSTALLER_CLAUDE_CONFIG_DIR,\n  AGENTS_DIR,\n  COMMANDS_DIR,\n  VERSION as INSTALLER_VERSION,\n  type InstallResult,\n  type InstallOptions\n} from './installer/index.js';\n\n/**\n * Options for creating a Sisyphus session\n */\nexport interface SisyphusOptions {\n  /** Custom configuration (merged with loaded config) */\n  config?: Partial<PluginConfig>;\n  /** Working directory (default: process.cwd()) */\n  workingDirectory?: string;\n  /** Skip loading config files */\n  skipConfigLoad?: boolean;\n  /** Skip context file injection */\n  skipContextInjection?: boolean;\n  /** Custom system prompt addition */\n  customSystemPrompt?: string;\n  /** API key (default: from ANTHROPIC_API_KEY env) */\n  apiKey?: string;\n}\n\n/**\n * Result of creating a Sisyphus session\n */\nexport interface SisyphusSession {\n  /** The query options to pass to Claude Agent SDK */\n  queryOptions: {\n    options: {\n      systemPrompt: string;\n      agents: Record<string, { description: string; prompt: string; tools?: string[]; model?: string }>;\n      mcpServers: Record<string, { command: string; args: string[] }>;\n      allowedTools: string[];\n      permissionMode: string;\n    };\n  };\n  /** Session state */\n  state: SessionState;\n  /** Loaded configuration */\n  config: PluginConfig;\n  /** Process a prompt (applies magic keywords) */\n  processPrompt: (prompt: string) => string;\n  /** Get detected magic keywords in a prompt */\n  detectKeywords: (prompt: string) => string[];\n  /** Background task manager for controlling async execution */\n  backgroundTasks: BackgroundTaskManager;\n  /** Check if a command should run in background (convenience method) */\n  shouldRunInBackground: (command: string) => TaskExecutionDecision;\n}\n\n/**\n * Create a Sisyphus orchestration session\n *\n * This prepares all the configuration and options needed\n * to run a query with the Claude Agent SDK.\n *\n * @example\n * ```typescript\n * import { createOmcSession } from 'ultrapower';\n * import { query } from '@anthropic-ai/claude-agent-sdk';\n *\n * const session = createSisyphusSession();\n *\n * // Use with Claude Agent SDK\n * for await (const message of query({\n *   prompt: session.processPrompt(\"ultrawork refactor the authentication module\"),\n *   ...session.queryOptions\n * })) {\n *   console.log(message);\n * }\n * ```\n */\nexport function createSisyphusSession(options?: SisyphusOptions): SisyphusSession {\n  // Load configuration\n  const loadedConfig = options?.skipConfigLoad ? {} : loadConfig();\n  const config: PluginConfig = {\n    ...loadedConfig,\n    ...options?.config\n  };\n\n  // Find and load context files\n  let contextAddition = '';\n  if (!options?.skipContextInjection && config.features?.autoContextInjection !== false) {\n    const contextFiles = findContextFiles(options?.workingDirectory);\n    if (contextFiles.length > 0) {\n      contextAddition = `\\n\\n## Project Context\\n\\n${loadContextFromFiles(contextFiles)}`;\n    }\n  }\n\n  // Build system prompt\n  let systemPrompt = omcSystemPrompt;\n\n  // Add continuation enforcement\n  if (config.features?.continuationEnforcement !== false) {\n    systemPrompt += continuationSystemPromptAddition;\n  }\n\n  // Add custom system prompt\n  if (options?.customSystemPrompt) {\n    systemPrompt += `\\n\\n## Custom Instructions\\n\\n${options.customSystemPrompt}`;\n  }\n\n  // Add context from files\n  if (contextAddition) {\n    systemPrompt += contextAddition;\n  }\n\n  // Get agent definitions\n  const agents = getAgentDefinitions();\n\n  // Build MCP servers configuration\n  const externalMcpServers = getDefaultMcpServers({\n    exaApiKey: config.mcpServers?.exa?.apiKey,\n    enableExa: config.mcpServers?.exa?.enabled,\n    enableContext7: config.mcpServers?.context7?.enabled\n  });\n\n  // Build allowed tools list\n  const allowedTools: string[] = [\n    'Read', 'Glob', 'Grep', 'WebSearch', 'WebFetch', 'Task', 'TodoWrite'\n  ];\n\n  if (config.permissions?.allowBash !== false) {\n    allowedTools.push('Bash');\n  }\n\n  if (config.permissions?.allowEdit !== false) {\n    allowedTools.push('Edit');\n  }\n\n  if (config.permissions?.allowWrite !== false) {\n    allowedTools.push('Write');\n  }\n\n  // Add MCP tool names\n  for (const serverName of Object.keys(externalMcpServers)) {\n    allowedTools.push(`mcp__${serverName}__*`);\n  }\n\n  // Add OMC custom tools in MCP format (LSP, AST, python_repl)\n  const omcTools = getOmcToolNames({\n    includeLsp: config.features?.lspTools !== false,\n    includeAst: config.features?.astTools !== false,\n    includePython: true\n  });\n  allowedTools.push(...omcTools);\n\n  // Add Codex and Gemini MCP tool patterns\n  allowedTools.push('mcp__x__*');\n  allowedTools.push('mcp__g__*');\n\n  // Create magic keyword processor\n  const processPrompt = createMagicKeywordProcessor(config.magicKeywords);\n\n  // Initialize session state\n  const state: SessionState = {\n    activeAgents: new Map(),\n    backgroundTasks: [],\n    contextFiles: findContextFiles(options?.workingDirectory)\n  };\n\n  // Create background task manager\n  const backgroundTaskManager = createBackgroundTaskManager(state, config);\n\n  return {\n    queryOptions: {\n      options: {\n        systemPrompt,\n        agents,\n        mcpServers: {\n          ...toSdkMcpFormat(externalMcpServers),\n          't': omcToolsServer as any,\n          'x': codexMcpServer as any,\n          'g': geminiMcpServer as any\n        },\n        allowedTools,\n        permissionMode: 'acceptEdits'\n      }\n    },\n    state,\n    config,\n    processPrompt,\n    detectKeywords: (prompt: string) => detectMagicKeywords(prompt, config.magicKeywords),\n    backgroundTasks: backgroundTaskManager,\n    shouldRunInBackground: (command: string) => shouldRunInBackgroundFn(\n      command,\n      backgroundTaskManager.getRunningCount(),\n      backgroundTaskManager.getMaxTasks()\n    )\n  };\n}\n\n/**\n * Quick helper to process a prompt with Sisyphus enhancements\n */\nexport function enhancePrompt(prompt: string, config?: PluginConfig): string {\n  const processor = createMagicKeywordProcessor(config?.magicKeywords);\n  return processor(prompt);\n}\n\n/**\n * Get the system prompt for the orchestrator (for direct use)\n */\nexport function getOmcSystemPrompt(options?: {\n  includeContinuation?: boolean;\n  customAddition?: string;\n}): string {\n  let prompt = omcSystemPrompt;\n\n  if (options?.includeContinuation !== false) {\n    prompt += continuationSystemPromptAddition;\n  }\n\n  if (options?.customAddition) {\n    prompt += `\\n\\n${options.customAddition}`;\n  }\n\n  return prompt;\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\installer\\__tests__\\claude-md-merge.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\installer\\__tests__\\safe-installer.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\installer\\hooks.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\installer\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\interop\\mcp-bridge.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":606,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":606,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21727,21730],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21727,21730],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * MCP Bridge for Cross-Tool Interoperability\n *\n * Provides MCP tool definitions for communication between OMC and OMX.\n * Tools allow sending tasks and messages between the two systems.\n */\n\nimport { z } from 'zod';\nimport { ToolDefinition } from '../tools/types.js';\nimport {\n  addSharedTask,\n  readSharedTasks,\n  _updateSharedTask,\n  addSharedMessage,\n  readSharedMessages,\n  markMessageAsRead,\n  SharedTask,\n  _SharedMessage,\n} from './shared-state.js';\nimport {\n  listOmxTeams,\n  readOmxTeamConfig,\n  listOmxMailboxMessages,\n  sendOmxDirectMessage,\n  broadcastOmxMessage,\n  listOmxTasks,\n} from './omx-team-state.js';\n\n// ============================================================================\n// interop_send_task - Send a task to the other tool\n// ============================================================================\n\nexport const interopSendTaskTool: ToolDefinition<{\n  target: z.ZodEnum<['omc', 'omx']>;\n  type: z.ZodEnum<['analyze', 'implement', 'review', 'test', 'custom']>;\n  description: z.ZodString;\n  context: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnknown>>;\n  files: z.ZodOptional<z.ZodArray<z.ZodString>>;\n  workingDirectory: z.ZodOptional<z.ZodString>;\n}> = {\n  name: 'interop_send_task',\n  description: 'Send a task to the other tool (OMC -> OMX or OMX -> OMC) for execution. The task will be queued in shared state for the target tool to pick up.',\n  schema: {\n    target: z.enum(['omc', 'omx']).describe('Target tool to send the task to'),\n    type: z.enum(['analyze', 'implement', 'review', 'test', 'custom']).describe('Type of task'),\n    description: z.string().describe('Task description'),\n    context: z.record(z.string(), z.unknown()).optional().describe('Additional context data'),\n    files: z.array(z.string()).optional().describe('List of relevant file paths'),\n    workingDirectory: z.string().optional().describe('Working directory (defaults to cwd)'),\n  },\n  handler: async (args) => {\n    const { target, type, description, context, files, workingDirectory } = args;\n\n    try {\n      const cwd = workingDirectory || process.cwd();\n\n      // Determine source (opposite of target)\n      const source = target === 'omc' ? 'omx' : 'omc';\n\n      const task = addSharedTask(cwd, {\n        source,\n        target,\n        type,\n        description,\n        context,\n        files,\n      });\n\n      return {\n        content: [{\n          type: 'text' as const,\n          text: `## Task Sent to ${target.toUpperCase()}\\n\\n` +\n            `**Task ID:** ${task.id}\\n` +\n            `**Type:** ${task.type}\\n` +\n            `**Description:** ${task.description}\\n` +\n            `**Status:** ${task.status}\\n` +\n            `**Created:** ${task.createdAt}\\n\\n` +\n            (task.files ? `**Files:** ${task.files.join(', ')}\\n\\n` : '') +\n            `The task has been queued for ${target.toUpperCase()} to pick up.`\n        }]\n      };\n    } catch (error) {\n      return {\n        content: [{\n          type: 'text' as const,\n          text: `Error sending task: ${error instanceof Error ? error.message : String(error)}`\n        }],\n        isError: true\n      };\n    }\n  }\n};\n\n// ============================================================================\n// interop_read_results - Read task results from the other tool\n// ============================================================================\n\nexport const interopReadResultsTool: ToolDefinition<{\n  source: z.ZodOptional<z.ZodEnum<['omc', 'omx']>>;\n  status: z.ZodOptional<z.ZodEnum<['pending', 'in_progress', 'completed', 'failed']>>;\n  limit: z.ZodOptional<z.ZodNumber>;\n  workingDirectory: z.ZodOptional<z.ZodString>;\n}> = {\n  name: 'interop_read_results',\n  description: 'Read task results from the shared interop state. Can filter by source tool and status.',\n  schema: {\n    source: z.enum(['omc', 'omx']).optional().describe('Filter by source tool'),\n    status: z.enum(['pending', 'in_progress', 'completed', 'failed']).optional().describe('Filter by task status'),\n    limit: z.number().optional().describe('Maximum number of tasks to return (default: 10)'),\n    workingDirectory: z.string().optional().describe('Working directory (defaults to cwd)'),\n  },\n  handler: async (args) => {\n    const { source, status, limit = 10, workingDirectory } = args;\n\n    try {\n      const cwd = workingDirectory || process.cwd();\n\n      const tasks = readSharedTasks(cwd, {\n        source: source as 'omc' | 'omx' | undefined,\n        status: status as SharedTask['status'] | undefined,\n      });\n\n      const limitedTasks = tasks.slice(0, limit);\n\n      if (limitedTasks.length === 0) {\n        return {\n          content: [{\n            type: 'text' as const,\n            text: '## No Tasks Found\\n\\nNo tasks match the specified filters.'\n          }]\n        };\n      }\n\n      const lines: string[] = [\n        `## Tasks (${limitedTasks.length}${tasks.length > limit ? ` of ${tasks.length}` : ''})\\n`\n      ];\n\n      for (const task of limitedTasks) {\n        const statusIcon = task.status === 'completed' ? '' :\n                          task.status === 'failed' ? '' :\n                          task.status === 'in_progress' ? '' : '';\n\n        lines.push(`### ${statusIcon} ${task.id}`);\n        lines.push(`- **Type:** ${task.type}`);\n        lines.push(`- **Source:** ${task.source.toUpperCase()}  **Target:** ${task.target.toUpperCase()}`);\n        lines.push(`- **Status:** ${task.status}`);\n        lines.push(`- **Description:** ${task.description}`);\n        lines.push(`- **Created:** ${task.createdAt}`);\n\n        if (task.files && task.files.length > 0) {\n          lines.push(`- **Files:** ${task.files.join(', ')}`);\n        }\n\n        if (task.result) {\n          lines.push(`- **Result:** ${task.result.slice(0, 200)}${task.result.length > 200 ? '...' : ''}`);\n        }\n\n        if (task.error) {\n          lines.push(`- **Error:** ${task.error}`);\n        }\n\n        if (task.completedAt) {\n          lines.push(`- **Completed:** ${task.completedAt}`);\n        }\n\n        lines.push('');\n      }\n\n      return {\n        content: [{\n          type: 'text' as const,\n          text: lines.join('\\n')\n        }]\n      };\n    } catch (error) {\n      return {\n        content: [{\n          type: 'text' as const,\n          text: `Error reading tasks: ${error instanceof Error ? error.message : String(error)}`\n        }],\n        isError: true\n      };\n    }\n  }\n};\n\n// ============================================================================\n// interop_send_message - Send a message to the other tool\n// ============================================================================\n\nexport const interopSendMessageTool: ToolDefinition<{\n  target: z.ZodEnum<['omc', 'omx']>;\n  content: z.ZodString;\n  metadata: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnknown>>;\n  workingDirectory: z.ZodOptional<z.ZodString>;\n}> = {\n  name: 'interop_send_message',\n  description: 'Send a message to the other tool for informational purposes or coordination.',\n  schema: {\n    target: z.enum(['omc', 'omx']).describe('Target tool to send the message to'),\n    content: z.string().describe('Message content'),\n    metadata: z.record(z.string(), z.unknown()).optional().describe('Additional metadata'),\n    workingDirectory: z.string().optional().describe('Working directory (defaults to cwd)'),\n  },\n  handler: async (args) => {\n    const { target, content, metadata, workingDirectory } = args;\n\n    try {\n      const cwd = workingDirectory || process.cwd();\n\n      // Determine source (opposite of target)\n      const source = target === 'omc' ? 'omx' : 'omc';\n\n      const message = addSharedMessage(cwd, {\n        source,\n        target,\n        content,\n        metadata,\n      });\n\n      return {\n        content: [{\n          type: 'text' as const,\n          text: `## Message Sent to ${target.toUpperCase()}\\n\\n` +\n            `**Message ID:** ${message.id}\\n` +\n            `**Content:** ${message.content}\\n` +\n            `**Timestamp:** ${message.timestamp}\\n\\n` +\n            `The message has been queued for ${target.toUpperCase()}.`\n        }]\n      };\n    } catch (error) {\n      return {\n        content: [{\n          type: 'text' as const,\n          text: `Error sending message: ${error instanceof Error ? error.message : String(error)}`\n        }],\n        isError: true\n      };\n    }\n  }\n};\n\n// ============================================================================\n// interop_read_messages - Read messages from the other tool\n// ============================================================================\n\nexport const interopReadMessagesTool: ToolDefinition<{\n  source: z.ZodOptional<z.ZodEnum<['omc', 'omx']>>;\n  unreadOnly: z.ZodOptional<z.ZodBoolean>;\n  limit: z.ZodOptional<z.ZodNumber>;\n  markAsRead: z.ZodOptional<z.ZodBoolean>;\n  workingDirectory: z.ZodOptional<z.ZodString>;\n}> = {\n  name: 'interop_read_messages',\n  description: 'Read messages from the shared interop state. Can filter by source tool and read status.',\n  schema: {\n    source: z.enum(['omc', 'omx']).optional().describe('Filter by source tool'),\n    unreadOnly: z.boolean().optional().describe('Show only unread messages (default: false)'),\n    limit: z.number().optional().describe('Maximum number of messages to return (default: 10)'),\n    markAsRead: z.boolean().optional().describe('Mark retrieved messages as read (default: false)'),\n    workingDirectory: z.string().optional().describe('Working directory (defaults to cwd)'),\n  },\n  handler: async (args) => {\n    const { source, unreadOnly = false, limit = 10, markAsRead = false, workingDirectory } = args;\n\n    try {\n      const cwd = workingDirectory || process.cwd();\n\n      const messages = readSharedMessages(cwd, {\n        source: source as 'omc' | 'omx' | undefined,\n        unreadOnly,\n      });\n\n      const limitedMessages = messages.slice(0, limit);\n\n      if (limitedMessages.length === 0) {\n        return {\n          content: [{\n            type: 'text' as const,\n            text: '## No Messages Found\\n\\nNo messages match the specified filters.'\n          }]\n        };\n      }\n\n      // Mark messages as read if requested\n      if (markAsRead) {\n        for (const message of limitedMessages) {\n          markMessageAsRead(cwd, message.id);\n        }\n      }\n\n      const lines: string[] = [\n        `## Messages (${limitedMessages.length}${messages.length > limit ? ` of ${messages.length}` : ''})\\n`\n      ];\n\n      for (const message of limitedMessages) {\n        const readIcon = message.read ? '' : '';\n\n        lines.push(`### ${readIcon} ${message.id}`);\n        lines.push(`- **From:** ${message.source.toUpperCase()}  **To:** ${message.target.toUpperCase()}`);\n        lines.push(`- **Content:** ${message.content}`);\n        lines.push(`- **Timestamp:** ${message.timestamp}`);\n        lines.push(`- **Read:** ${message.read ? 'Yes' : 'No'}`);\n\n        if (message.metadata) {\n          lines.push(`- **Metadata:** ${JSON.stringify(message.metadata)}`);\n        }\n\n        lines.push('');\n      }\n\n      if (markAsRead) {\n        lines.push(`\\n*${limitedMessages.length} message(s) marked as read*`);\n      }\n\n      return {\n        content: [{\n          type: 'text' as const,\n          text: lines.join('\\n')\n        }]\n      };\n    } catch (error) {\n      return {\n        content: [{\n          type: 'text' as const,\n          text: `Error reading messages: ${error instanceof Error ? error.message : String(error)}`\n        }],\n        isError: true\n      };\n    }\n  }\n};\n\n// ============================================================================\n// interop_list_omx_teams - List active omx teams\n// ============================================================================\n\nexport const interopListOmxTeamsTool: ToolDefinition<{\n  workingDirectory: z.ZodOptional<z.ZodString>;\n}> = {\n  name: 'interop_list_omx_teams',\n  description: 'List active OMX (oh-my-codex) teams from .omx/state/team/. Shows team names and basic configuration.',\n  schema: {\n    workingDirectory: z.string().optional().describe('Working directory (defaults to cwd)'),\n  },\n  handler: async (args) => {\n    try {\n      const cwd = args.workingDirectory || process.cwd();\n      const teamNames = await listOmxTeams(cwd);\n\n      if (teamNames.length === 0) {\n        return {\n          content: [{\n            type: 'text' as const,\n            text: '## No OMX Teams Found\\n\\nNo active OMX teams detected in .omx/state/team/.'\n          }]\n        };\n      }\n\n      const lines: string[] = [`## OMX Teams (${teamNames.length})\\n`];\n\n      for (const name of teamNames) {\n        const config = await readOmxTeamConfig(name, cwd);\n        if (config) {\n          lines.push(`### ${name}`);\n          lines.push(`- **Task:** ${config.task}`);\n          lines.push(`- **Workers:** ${config.worker_count} (${config.agent_type})`);\n          lines.push(`- **Created:** ${config.created_at}`);\n          lines.push(`- **Workers:** ${config.workers.map((w) => w.name).join(', ')}`);\n          lines.push('');\n        } else {\n          lines.push(`### ${name} (config not readable)\\n`);\n        }\n      }\n\n      return {\n        content: [{\n          type: 'text' as const,\n          text: lines.join('\\n')\n        }]\n      };\n    } catch (error) {\n      return {\n        content: [{\n          type: 'text' as const,\n          text: `Error listing OMX teams: ${error instanceof Error ? error.message : String(error)}`\n        }],\n        isError: true\n      };\n    }\n  }\n};\n\n// ============================================================================\n// interop_send_omx_message - Send message to omx team mailbox\n// ============================================================================\n\nexport const interopSendOmxMessageTool: ToolDefinition<{\n  teamName: z.ZodString;\n  fromWorker: z.ZodString;\n  toWorker: z.ZodString;\n  body: z.ZodString;\n  broadcast: z.ZodOptional<z.ZodBoolean>;\n  workingDirectory: z.ZodOptional<z.ZodString>;\n}> = {\n  name: 'interop_send_omx_message',\n  description: 'Send a message to an OMX team worker mailbox using the native omx format. Supports direct messages and broadcasts.',\n  schema: {\n    teamName: z.string().describe('OMX team name'),\n    fromWorker: z.string().describe('Sender worker name (e.g., \"omc-bridge\")'),\n    toWorker: z.string().describe('Target worker name (ignored if broadcast=true)'),\n    body: z.string().describe('Message body'),\n    broadcast: z.boolean().optional().describe('Broadcast to all workers (default: false)'),\n    workingDirectory: z.string().optional().describe('Working directory (defaults to cwd)'),\n  },\n  handler: async (args) => {\n    try {\n      const cwd = args.workingDirectory || process.cwd();\n\n      if (args.broadcast) {\n        const messages = await broadcastOmxMessage(args.teamName, args.fromWorker, args.body, cwd);\n        return {\n          content: [{\n            type: 'text' as const,\n            text: `## Broadcast Sent to OMX Team: ${args.teamName}\\n\\n` +\n              `**From:** ${args.fromWorker}\\n` +\n              `**Recipients:** ${messages.length}\\n` +\n              `**Message IDs:** ${messages.map((m) => m.message_id).join(', ')}\\n\\n` +\n              `Message delivered to ${messages.length} worker mailbox(es).`\n          }]\n        };\n      }\n\n      const msg = await sendOmxDirectMessage(args.teamName, args.fromWorker, args.toWorker, args.body, cwd);\n      return {\n        content: [{\n          type: 'text' as const,\n          text: `## Message Sent to OMX Worker\\n\\n` +\n            `**Team:** ${args.teamName}\\n` +\n            `**From:** ${msg.from_worker}\\n` +\n            `**To:** ${msg.to_worker}\\n` +\n            `**Message ID:** ${msg.message_id}\\n` +\n            `**Created:** ${msg.created_at}\\n\\n` +\n            `Message delivered to ${msg.to_worker}'s mailbox.`\n        }]\n      };\n    } catch (error) {\n      return {\n        content: [{\n          type: 'text' as const,\n          text: `Error sending OMX message: ${error instanceof Error ? error.message : String(error)}`\n        }],\n        isError: true\n      };\n    }\n  }\n};\n\n// ============================================================================\n// interop_read_omx_messages - Read messages from omx team mailbox\n// ============================================================================\n\nexport const interopReadOmxMessagesTool: ToolDefinition<{\n  teamName: z.ZodString;\n  workerName: z.ZodString;\n  limit: z.ZodOptional<z.ZodNumber>;\n  workingDirectory: z.ZodOptional<z.ZodString>;\n}> = {\n  name: 'interop_read_omx_messages',\n  description: 'Read messages from an OMX team worker mailbox.',\n  schema: {\n    teamName: z.string().describe('OMX team name'),\n    workerName: z.string().describe('Worker name whose mailbox to read'),\n    limit: z.number().optional().describe('Maximum number of messages to return (default: 20)'),\n    workingDirectory: z.string().optional().describe('Working directory (defaults to cwd)'),\n  },\n  handler: async (args) => {\n    try {\n      const cwd = args.workingDirectory || process.cwd();\n      const limit = args.limit ?? 20;\n      const messages = await listOmxMailboxMessages(args.teamName, args.workerName, cwd);\n\n      if (messages.length === 0) {\n        return {\n          content: [{\n            type: 'text' as const,\n            text: `## No Messages\\n\\nNo messages in ${args.workerName}'s mailbox for team ${args.teamName}.`\n          }]\n        };\n      }\n\n      const limited = messages.slice(-limit); // most recent N messages\n      const lines: string[] = [\n        `## OMX Mailbox: ${args.workerName} @ ${args.teamName} (${limited.length}${messages.length > limit ? ` of ${messages.length}` : ''})\\n`\n      ];\n\n      for (const msg of limited) {\n        const deliveredIcon = msg.delivered_at ? '' : '';\n        lines.push(`### ${deliveredIcon} ${msg.message_id}`);\n        lines.push(`- **From:** ${msg.from_worker}`);\n        lines.push(`- **To:** ${msg.to_worker}`);\n        lines.push(`- **Body:** ${msg.body.slice(0, 300)}${msg.body.length > 300 ? '...' : ''}`);\n        lines.push(`- **Created:** ${msg.created_at}`);\n        if (msg.delivered_at) lines.push(`- **Delivered:** ${msg.delivered_at}`);\n        lines.push('');\n      }\n\n      return {\n        content: [{\n          type: 'text' as const,\n          text: lines.join('\\n')\n        }]\n      };\n    } catch (error) {\n      return {\n        content: [{\n          type: 'text' as const,\n          text: `Error reading OMX messages: ${error instanceof Error ? error.message : String(error)}`\n        }],\n        isError: true\n      };\n    }\n  }\n};\n\n// ============================================================================\n// interop_read_omx_tasks - Read omx team tasks\n// ============================================================================\n\nexport const interopReadOmxTasksTool: ToolDefinition<{\n  teamName: z.ZodString;\n  status: z.ZodOptional<z.ZodEnum<['pending', 'blocked', 'in_progress', 'completed', 'failed']>>;\n  limit: z.ZodOptional<z.ZodNumber>;\n  workingDirectory: z.ZodOptional<z.ZodString>;\n}> = {\n  name: 'interop_read_omx_tasks',\n  description: 'Read tasks from an OMX team. Can filter by status.',\n  schema: {\n    teamName: z.string().describe('OMX team name'),\n    status: z.enum(['pending', 'blocked', 'in_progress', 'completed', 'failed']).optional().describe('Filter by task status'),\n    limit: z.number().optional().describe('Maximum number of tasks to return (default: 20)'),\n    workingDirectory: z.string().optional().describe('Working directory (defaults to cwd)'),\n  },\n  handler: async (args) => {\n    try {\n      const cwd = args.workingDirectory || process.cwd();\n      const limit = args.limit ?? 20;\n      let tasks = await listOmxTasks(args.teamName, cwd);\n\n      if (args.status) {\n        tasks = tasks.filter((t) => t.status === args.status);\n      }\n\n      if (tasks.length === 0) {\n        return {\n          content: [{\n            type: 'text' as const,\n            text: `## No Tasks\\n\\nNo tasks found for OMX team ${args.teamName}${args.status ? ` with status \"${args.status}\"` : ''}.`\n          }]\n        };\n      }\n\n      const limited = tasks.slice(0, limit);\n      const lines: string[] = [\n        `## OMX Tasks: ${args.teamName} (${limited.length}${tasks.length > limit ? ` of ${tasks.length}` : ''})\\n`\n      ];\n\n      for (const task of limited) {\n        const statusIcon = task.status === 'completed' ? '' :\n                          task.status === 'failed' ? '' :\n                          task.status === 'in_progress' ? '' :\n                          task.status === 'blocked' ? '' : '';\n\n        lines.push(`### ${statusIcon} Task ${task.id}: ${task.subject}`);\n        lines.push(`- **Status:** ${task.status}`);\n        if (task.owner) lines.push(`- **Owner:** ${task.owner}`);\n        lines.push(`- **Description:** ${task.description.slice(0, 200)}${task.description.length > 200 ? '...' : ''}`);\n        lines.push(`- **Created:** ${task.created_at}`);\n        if (task.result) lines.push(`- **Result:** ${task.result.slice(0, 200)}${task.result.length > 200 ? '...' : ''}`);\n        if (task.error) lines.push(`- **Error:** ${task.error}`);\n        if (task.completed_at) lines.push(`- **Completed:** ${task.completed_at}`);\n        lines.push('');\n      }\n\n      return {\n        content: [{\n          type: 'text' as const,\n          text: lines.join('\\n')\n        }]\n      };\n    } catch (error) {\n      return {\n        content: [{\n          type: 'text' as const,\n          text: `Error reading OMX tasks: ${error instanceof Error ? error.message : String(error)}`\n        }],\n        isError: true\n      };\n    }\n  }\n};\n\n/**\n * Get all interop MCP tools for registration\n */\nexport function getInteropTools(): ToolDefinition<any>[] {\n  return [\n    interopSendTaskTool,\n    interopReadResultsTool,\n    interopSendMessageTool,\n    interopReadMessagesTool,\n    interopListOmxTeamsTool,\n    interopSendOmxMessageTool,\n    interopReadOmxMessagesTool,\n    interopReadOmxTasksTool,\n  ];\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\interop\\omx-team-state.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\interop\\shared-state.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\lib\\__tests__\\worktree-paths.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\lib\\atomic-write.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\lib\\version.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\lib\\worktree-paths.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\mcp\\__tests__\\codex-reasoning-effort.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\mcp\\__tests__\\job-state-db-deprecation.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\mcp\\__tests__\\shared-exec.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\mcp\\cli-detection.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\mcp\\codex-core.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\mcp\\codex-server.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":29,"column":8,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":29,"endColumn":11,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3100,3103],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3100,3103],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":30,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3120,3123],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3120,3123],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":52,"column":8,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":52,"endColumn":11,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4144,4147],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4144,4147],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":53,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4164,4167],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4164,4167],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":64,"column":8,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":64,"endColumn":11,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4621,4624],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4621,4624],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":65,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":65,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4641,4644],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4641,4644],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":77,"column":8,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":77,"endColumn":11,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5106,5109],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5106,5109],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":78,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":78,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5126,5129],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5126,5129],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":90,"column":8,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":90,"endColumn":11,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5658,5661],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5658,5661],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":91,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":91,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5678,5681],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5678,5681],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Codex MCP Server - In-process MCP server for OpenAI Codex CLI integration\n *\n * Exposes `ask_codex` tool via the Claude Agent SDK's createSdkMcpServer helper.\n * Tools will be available as mcp__x__ask_codex\n *\n * Note: The standalone version (codex-standalone-server.ts) is used for the\n * external-process .mcp.json registration with proper stdio transport.\n */\n\nimport { createSdkMcpServer, tool } from \"@anthropic-ai/claude-agent-sdk\";\nimport { handleAskCodex, CODEX_DEFAULT_MODEL, CODEX_RECOMMENDED_ROLES } from './codex-core.js';\nimport { handleWaitForJob, handleCheckJobStatus, handleKillJob, handleListJobs } from './job-management.js';\n\n// Define the ask_codex tool using the SDK tool() helper\nconst askCodexTool = tool(\n  \"ask_codex\",\n  `Send a prompt to OpenAI Codex CLI for analytical/planning tasks. Codex excels at architecture review, planning validation, critical analysis, and code/security review validation. Requires agent_role to specify the perspective. Recommended roles: ${CODEX_RECOMMENDED_ROLES.join(', ')}. Any valid OMC agent role is accepted. Requires Codex CLI (npm install -g @openai/codex).`,\n  {\n    agent_role: { type: \"string\", description: `Required. Agent perspective for Codex. Recommended: ${CODEX_RECOMMENDED_ROLES.join(', ')}. Any valid OMC agent role is accepted.` },\n    prompt: { type: \"string\", description: \"Inline prompt text. Alternative to prompt_file -- the tool auto-persists to a file for audit trail. Use for simpler invocations where file management is unnecessary. If both prompt and prompt_file are provided, prompt_file takes precedence.\" },\n    prompt_file: { type: \"string\", description: \"Path to file containing the prompt. Required unless 'prompt' is provided inline. A defined (non-undefined) `prompt_file` value selects file mode; `prompt_file` must be a non-empty string when used. Passing null or non-string values triggers file-mode validation (not inline fallback).\" },\n    output_file: { type: \"string\", description: \"Required for file-based mode (prompt_file). Auto-generated in inline mode (prompt). Response content is returned inline only when using prompt parameter.\" },\n    context_files: { type: \"array\", items: { type: \"string\" }, description: \"File paths to include as context (contents will be prepended to prompt)\" },\n    model: { type: \"string\", description: `Codex model to use (default: ${CODEX_DEFAULT_MODEL}). Set OMC_CODEX_DEFAULT_MODEL env var to change default.` },\n    reasoning_effort: { type: \"string\", description: \"Codex reasoning effort level: 'minimal', 'low', 'medium' (Codex CLI default), 'high', or 'xhigh' (model-dependent). Maps to Codex CLI -c model_reasoning_effort. If omitted, uses Codex CLI default from ~/.codex/config.toml.\" },\n    background: { type: \"boolean\", description: \"Run in background (non-blocking). Returns immediately with job metadata and file paths. Check response file for completion. Not available with inline prompt.\" },\n    working_directory: { type: \"string\", description: \"Working directory for path resolution and CLI execution. Defaults to process.cwd().\" },\n  } as any,\n  async (args: any) => {\n    const { prompt, prompt_file, output_file, agent_role, model, reasoning_effort, context_files, background, working_directory } = args as {\n      prompt?: string;\n      prompt_file?: string;\n      output_file?: string;\n      agent_role: string;\n      model?: string;\n      reasoning_effort?: string;\n      context_files?: string[];\n      background?: boolean;\n      working_directory?: string;\n    };\n    return handleAskCodex({ prompt, prompt_file, output_file, agent_role, model, reasoning_effort, context_files, background, working_directory });\n  }\n);\n\nconst waitForJobTool = tool(\n  \"wait_for_job\",\n  \"Block (poll) until a background job reaches a terminal state (completed, failed, or timeout). Uses exponential backoff. Returns the response preview on success.\",\n  {\n    job_id: { type: \"string\", description: \"The job ID returned when the background job was dispatched.\" },\n    timeout_ms: { type: \"number\", description: \"Maximum time to wait in milliseconds (default: 3600000, max: 3600000).\" },\n  } as any,\n  async (args: any) => {\n    const { job_id, timeout_ms } = args as { job_id: string; timeout_ms?: number };\n    return handleWaitForJob('codex', job_id, timeout_ms);\n  }\n);\n\nconst checkJobStatusTool = tool(\n  \"check_job_status\",\n  \"Non-blocking status check for a background job. Returns current status, metadata, and error information if available.\",\n  {\n    job_id: { type: \"string\", description: \"The job ID returned when the background job was dispatched.\" },\n  } as any,\n  async (args: any) => {\n    const { job_id } = args as { job_id: string };\n    return handleCheckJobStatus('codex', job_id);\n  }\n);\n\nconst killJobTool = tool(\n  \"kill_job\",\n  \"Send a signal to a running background job. Marks the job as failed. Only works on jobs in spawned or running state.\",\n  {\n    job_id: { type: \"string\", description: \"The job ID of the running job to kill.\" },\n    signal: { type: \"string\", description: \"The signal to send (default: SIGTERM).\" },\n  } as any,\n  async (args: any) => {\n    const { job_id, signal } = args as { job_id: string; signal?: string };\n    return handleKillJob('codex', job_id, (signal as NodeJS.Signals) || undefined);\n  }\n);\n\nconst listJobsTool = tool(\n  \"list_jobs\",\n  \"List background jobs for this provider. Filter by status and limit results. Results sorted newest first.\",\n  {\n    status_filter: { type: \"string\", description: \"Filter jobs by status (default: active).\" },\n    limit: { type: \"number\", description: \"Maximum number of jobs to return (default: 50).\" },\n  } as any,\n  async (args: any) => {\n    const { status_filter, limit } = args as { status_filter?: string; limit?: number };\n    return handleListJobs('codex', (status_filter as 'active' | 'completed' | 'failed' | 'all') || undefined, limit);\n  }\n);\n\n/**\n * In-process MCP server exposing Codex CLI integration\n *\n * Tools will be available as mcp__x__ask_codex\n */\nexport const codexMcpServer = createSdkMcpServer({\n  name: \"x\",\n  version: \"1.0.0\",\n  tools: [askCodexTool, waitForJobTool, checkJobStatusTool, killJobTool, listJobsTool]\n});\n\n/**\n * Tool names for allowedTools configuration\n */\nexport const codexToolNames = ['ask_codex', 'wait_for_job', 'check_job_status', 'kill_job', 'list_jobs'];\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\mcp\\codex-standalone-server.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\mcp\\gemini-core.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\mcp\\gemini-server.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":33,"column":8,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":33,"endColumn":11,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2998,3001],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2998,3001],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":34,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":34,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3018,3021],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3018,3021],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":55,"column":8,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":55,"endColumn":11,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3950,3953],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3950,3953],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":56,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":56,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3970,3973],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3970,3973],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":67,"column":8,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":67,"endColumn":11,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4428,4431],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4428,4431],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":68,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":68,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4448,4451],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4448,4451],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":80,"column":8,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":80,"endColumn":11,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4914,4917],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4914,4917],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":81,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":81,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4934,4937],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4934,4937],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":93,"column":8,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":93,"endColumn":11,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5467,5470],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5467,5470],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":94,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":94,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5487,5490],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5487,5490],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Gemini MCP Server - In-process MCP server for Google Gemini CLI integration\n *\n * Exposes `ask_gemini` tool via the Claude Agent SDK's createSdkMcpServer helper.\n * Tools will be available as mcp__g__ask_gemini\n *\n * Note: The standalone version (gemini-standalone-server.ts) is used for the\n * external-process .mcp.json registration with proper stdio transport.\n */\n\nimport { createSdkMcpServer, tool } from \"@anthropic-ai/claude-agent-sdk\";\nimport {\n  GEMINI_DEFAULT_MODEL,\n  GEMINI_RECOMMENDED_ROLES,\n  handleAskGemini\n} from './gemini-core.js';\nimport { GEMINI_MODEL_FALLBACKS } from '../features/model-routing/external-model-policy.js';\nimport { handleWaitForJob, handleCheckJobStatus, handleKillJob, handleListJobs } from './job-management.js';\n\n// Define the ask_gemini tool using the SDK tool() helper\nconst askGeminiTool = tool(\n  \"ask_gemini\",\n  `Send a prompt to Google Gemini CLI for design/implementation tasks. Gemini excels at frontend design review and implementation with its 1M token context window. Recommended roles: ${GEMINI_RECOMMENDED_ROLES.join(', ')}. Any valid OMC agent role is accepted. Fallback chain: ${GEMINI_MODEL_FALLBACKS.join('  ')}. Requires Gemini CLI (npm install -g @google/gemini-cli).`,\n  {\n    agent_role: { type: \"string\", description: `Required. Agent perspective for Gemini. Recommended: ${GEMINI_RECOMMENDED_ROLES.join(', ')}. Any valid OMC agent role is accepted.` },\n    prompt: { type: \"string\", description: \"Inline prompt string. Alternative to prompt_file -- the prompt is auto-persisted to a file for audit trail. When used, output_file is optional (auto-generated if omitted) and the response is returned inline in the MCP result. If both prompt and prompt_file are provided, prompt_file takes precedence.\" },\n    prompt_file: { type: \"string\", description: \"Path to file containing the prompt. A defined (non-undefined) `prompt_file` value selects file mode; `prompt_file` must be a non-empty string when used. Passing null or non-string values triggers file-mode validation (not inline fallback).\" },\n    output_file: { type: \"string\", description: \"Required for file-based mode (prompt_file). Auto-generated in inline mode (prompt). Response content is returned inline only when using prompt parameter.\" },\n    files: { type: \"array\", items: { type: \"string\" }, description: \"File paths to include as context (contents will be prepended to prompt)\" },\n    model: { type: \"string\", description: `Gemini model to use (default: ${GEMINI_DEFAULT_MODEL}). Set OMC_GEMINI_DEFAULT_MODEL env var to change default. Auto-fallback chain: ${GEMINI_MODEL_FALLBACKS.join('  ')}.` },\n    background: { type: \"boolean\", description: \"Run in background (non-blocking). Returns immediately with job metadata and file paths. Check response file for completion. Not available with inline prompt.\" },\n    working_directory: { type: \"string\", description: \"Working directory for path resolution and CLI execution. Defaults to process.cwd().\" },\n  } as any,\n  async (args: any) => {\n    const { prompt, prompt_file, output_file, agent_role, model, files, background, working_directory } = args as {\n      prompt?: string;\n      prompt_file?: string;\n      output_file?: string;\n      agent_role: string;\n      model?: string;\n      files?: string[];\n      background?: boolean;\n      working_directory?: string;\n    };\n    return handleAskGemini({ prompt, prompt_file, output_file, agent_role, model, files, background, working_directory });\n  }\n);\n\nconst waitForJobTool = tool(\n  \"wait_for_job\",\n  \"Block (poll) until a background job reaches a terminal state (completed, failed, or timeout). Uses exponential backoff. Returns the response preview on success.\",\n  {\n    job_id: { type: \"string\", description: \"The job ID returned when the background job was dispatched.\" },\n    timeout_ms: { type: \"number\", description: \"Maximum time to wait in milliseconds (default: 3600000, max: 3600000).\" },\n  } as any,\n  async (args: any) => {\n    const { job_id, timeout_ms } = args as { job_id: string; timeout_ms?: number };\n    return handleWaitForJob('gemini', job_id, timeout_ms);\n  }\n);\n\nconst checkJobStatusTool = tool(\n  \"check_job_status\",\n  \"Non-blocking status check for a background job. Returns current status, metadata, and error information if available.\",\n  {\n    job_id: { type: \"string\", description: \"The job ID returned when the background job was dispatched.\" },\n  } as any,\n  async (args: any) => {\n    const { job_id } = args as { job_id: string };\n    return handleCheckJobStatus('gemini', job_id);\n  }\n);\n\nconst killJobTool = tool(\n  \"kill_job\",\n  \"Send a signal to a running background job. Marks the job as failed. Only works on jobs in spawned or running state.\",\n  {\n    job_id: { type: \"string\", description: \"The job ID of the running job to kill.\" },\n    signal: { type: \"string\", description: \"The signal to send (default: SIGTERM).\" },\n  } as any,\n  async (args: any) => {\n    const { job_id, signal } = args as { job_id: string; signal?: string };\n    return handleKillJob('gemini', job_id, (signal as NodeJS.Signals) || undefined);\n  }\n);\n\nconst listJobsTool = tool(\n  \"list_jobs\",\n  \"List background jobs for this provider. Filter by status and limit results. Results sorted newest first.\",\n  {\n    status_filter: { type: \"string\", description: \"Filter jobs by status (default: active).\" },\n    limit: { type: \"number\", description: \"Maximum number of jobs to return (default: 50).\" },\n  } as any,\n  async (args: any) => {\n    const { status_filter, limit } = args as { status_filter?: string; limit?: number };\n    return handleListJobs('gemini', (status_filter as 'active' | 'completed' | 'failed' | 'all') || undefined, limit);\n  }\n);\n\n/**\n * In-process MCP server exposing Gemini CLI integration\n *\n * Tools will be available as mcp__g__ask_gemini\n */\nexport const geminiMcpServer = createSdkMcpServer({\n  name: \"g\",\n  version: \"1.0.0\",\n  tools: [askGeminiTool, waitForJobTool, checkJobStatusTool, killJobTool, listJobsTool]\n});\n\n/**\n * Tool names for allowedTools configuration\n */\nexport const geminiToolNames = ['ask_gemini', 'wait_for_job', 'check_job_status', 'kill_job', 'list_jobs'];\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\mcp\\gemini-standalone-server.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\mcp\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\mcp\\job-management.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\mcp\\job-state-db.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\mcp\\mcp-config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\mcp\\omc-tools-server.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\mcp\\prompt-injection.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\mcp\\prompt-persistence.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\mcp\\servers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\mcp\\shared-exec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\mcp\\standalone-server.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\notifications\\__tests__\\config-merge.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\notifications\\__tests__\\config.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\notifications\\__tests__\\dispatcher.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\notifications\\__tests__\\formatter.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\notifications\\__tests__\\notify-registry-integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\notifications\\__tests__\\profiles.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\notifications\\__tests__\\reply-config.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\notifications\\__tests__\\reply-listener.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\notifications\\__tests__\\session-registry.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\notifications\\__tests__\\tmux.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\notifications\\config.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":573,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":573,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17415,17418],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17415,17418],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Notification Configuration Reader\n *\n * Reads notification config from .omc-config.json and provides\n * backward compatibility with the old stopHookCallbacks format.\n */\n\nimport { readFileSync, existsSync } from \"fs\";\nimport { join } from \"path\";\nimport { getClaudeConfigDir } from \"../utils/paths.js\";\nimport type {\n  NotificationConfig,\n  NotificationEvent,\n  NotificationPlatform,\n  EventNotificationConfig,\n  DiscordNotificationConfig,\n  DiscordBotNotificationConfig,\n  TelegramNotificationConfig,\n} from \"./types.js\";\n\nconst CONFIG_FILE = join(getClaudeConfigDir(), \".omc-config.json\");\n\n/**\n * Read raw config from .omc-config.json\n */\nfunction readRawConfig(): Record<string, unknown> | null {\n  if (!existsSync(CONFIG_FILE)) return null;\n  try {\n    return JSON.parse(readFileSync(CONFIG_FILE, \"utf-8\"));\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Migrate old stopHookCallbacks config to new notification format.\n * This provides backward compatibility for existing users.\n */\nfunction migrateStopHookCallbacks(\n  raw: Record<string, unknown>,\n): NotificationConfig | null {\n  const callbacks = raw.stopHookCallbacks as\n    | Record<string, unknown>\n    | undefined;\n  if (!callbacks) return null;\n\n  const config: NotificationConfig = {\n    enabled: true,\n    events: {\n      \"session-end\": { enabled: true },\n    },\n  };\n\n  // Migrate Telegram config\n  const telegram = callbacks.telegram as Record<string, unknown> | undefined;\n  if (telegram?.enabled) {\n    const telegramConfig: TelegramNotificationConfig = {\n      enabled: true,\n      botToken: (telegram.botToken as string) || \"\",\n      chatId: (telegram.chatId as string) || \"\",\n    };\n    config.telegram = telegramConfig;\n  }\n\n  // Migrate Discord config\n  const discord = callbacks.discord as Record<string, unknown> | undefined;\n  if (discord?.enabled) {\n    const discordConfig: DiscordNotificationConfig = {\n      enabled: true,\n      webhookUrl: (discord.webhookUrl as string) || \"\",\n    };\n    config.discord = discordConfig;\n  }\n\n  return config;\n}\n\n/**\n * Normalize an optional string: trim whitespace, return undefined if empty.\n */\nfunction normalizeOptional(value: string | undefined): string | undefined {\n  const trimmed = value?.trim();\n  return trimmed || undefined;\n}\n\n/**\n * Validate Discord mention format: <@USER_ID> or <@&ROLE_ID>.\n * Returns the mention string if valid, undefined otherwise.\n */\nexport function validateMention(raw: string | undefined): string | undefined {\n  const mention = normalizeOptional(raw);\n  if (!mention) return undefined;\n  // Match <@123456789012345678> (user) or <@&123456789012345678> (role)\n  if (/^<@!?\\d{17,20}>$/.test(mention) || /^<@&\\d{17,20}>$/.test(mention)) {\n    return mention;\n  }\n  return undefined;\n}\n\n/**\n * Parse a validated mention into allowed_mentions structure for Discord API.\n */\nexport function parseMentionAllowedMentions(\n  mention: string | undefined,\n): { users?: string[]; roles?: string[] } {\n  if (!mention) return {};\n  const userMatch = mention.match(/^<@!?(\\d{17,20})>$/);\n  if (userMatch) return { users: [userMatch[1]] };\n  const roleMatch = mention.match(/^<@&(\\d{17,20})>$/);\n  if (roleMatch) return { roles: [roleMatch[1]] };\n  return {};\n}\n\n/**\n * Build notification config from environment variables.\n * This enables zero-config notification setup - just set env vars in .zshrc.\n */\nexport function buildConfigFromEnv(): NotificationConfig | null {\n  const config: NotificationConfig = { enabled: false };\n  let hasAnyPlatform = false;\n\n  const discordMention = validateMention(process.env.OMC_DISCORD_MENTION);\n\n  // Discord Bot (token + channel)\n  const discordBotToken = process.env.OMC_DISCORD_NOTIFIER_BOT_TOKEN;\n  const discordChannel = process.env.OMC_DISCORD_NOTIFIER_CHANNEL;\n  if (discordBotToken && discordChannel) {\n    config[\"discord-bot\"] = {\n      enabled: true,\n      botToken: discordBotToken,\n      channelId: discordChannel,\n      mention: discordMention,\n    };\n    hasAnyPlatform = true;\n  }\n\n  // Discord Webhook\n  const discordWebhook = process.env.OMC_DISCORD_WEBHOOK_URL;\n  if (discordWebhook) {\n    config.discord = {\n      enabled: true,\n      webhookUrl: discordWebhook,\n      mention: discordMention,\n    };\n    hasAnyPlatform = true;\n  }\n\n  // Telegram (support both OMC_TELEGRAM_BOT_TOKEN and OMC_TELEGRAM_NOTIFIER_BOT_TOKEN)\n  const telegramToken =\n    process.env.OMC_TELEGRAM_BOT_TOKEN ||\n    process.env.OMC_TELEGRAM_NOTIFIER_BOT_TOKEN;\n  const telegramChatId =\n    process.env.OMC_TELEGRAM_CHAT_ID ||\n    process.env.OMC_TELEGRAM_NOTIFIER_CHAT_ID ||\n    process.env.OMC_TELEGRAM_NOTIFIER_UID;\n  if (telegramToken && telegramChatId) {\n    config.telegram = {\n      enabled: true,\n      botToken: telegramToken,\n      chatId: telegramChatId,\n    };\n    hasAnyPlatform = true;\n  }\n\n  // Slack\n  const slackWebhook = process.env.OMC_SLACK_WEBHOOK_URL;\n  if (slackWebhook) {\n    config.slack = {\n      enabled: true,\n      webhookUrl: slackWebhook,\n    };\n    hasAnyPlatform = true;\n  }\n\n  if (!hasAnyPlatform) return null;\n\n  config.enabled = true;\n  return config;\n}\n\n/**\n * Deep-merge env-derived platforms into file config.\n * Env fills missing platform blocks only; file config fields take precedence.\n * Mention values from env are applied to file-based Discord configs that lack one.\n */\nfunction mergeEnvIntoFileConfig(\n  fileConfig: NotificationConfig,\n  envConfig: NotificationConfig,\n): NotificationConfig {\n  const merged = { ...fileConfig };\n\n  // Merge discord-bot: if file doesn't have it but env does, add it\n  if (!merged[\"discord-bot\"] && envConfig[\"discord-bot\"]) {\n    merged[\"discord-bot\"] = envConfig[\"discord-bot\"];\n  } else if (merged[\"discord-bot\"] && envConfig[\"discord-bot\"]) {\n    // Fill missing fields from env (e.g., mention from env when file lacks it)\n    merged[\"discord-bot\"] = {\n      ...merged[\"discord-bot\"],\n      botToken: merged[\"discord-bot\"].botToken || envConfig[\"discord-bot\"].botToken,\n      channelId: merged[\"discord-bot\"].channelId || envConfig[\"discord-bot\"].channelId,\n      mention:\n        merged[\"discord-bot\"].mention !== undefined\n          ? validateMention(merged[\"discord-bot\"].mention)\n          : envConfig[\"discord-bot\"].mention,\n    };\n  } else if (merged[\"discord-bot\"]) {\n    // Validate mention in existing file config\n    merged[\"discord-bot\"] = {\n      ...merged[\"discord-bot\"],\n      mention: validateMention(merged[\"discord-bot\"].mention),\n    };\n  }\n\n  // Merge discord webhook: if file doesn't have it but env does, add it\n  if (!merged.discord && envConfig.discord) {\n    merged.discord = envConfig.discord;\n  } else if (merged.discord && envConfig.discord) {\n    merged.discord = {\n      ...merged.discord,\n      webhookUrl: merged.discord.webhookUrl || envConfig.discord.webhookUrl,\n      mention:\n        merged.discord.mention !== undefined\n          ? validateMention(merged.discord.mention)\n          : envConfig.discord.mention,\n    };\n  } else if (merged.discord) {\n    // Validate mention in existing file config\n    merged.discord = {\n      ...merged.discord,\n      mention: validateMention(merged.discord.mention),\n    };\n  }\n\n  // Merge telegram\n  if (!merged.telegram && envConfig.telegram) {\n    merged.telegram = envConfig.telegram;\n  }\n\n  // Merge slack\n  if (!merged.slack && envConfig.slack) {\n    merged.slack = envConfig.slack;\n  }\n\n  return merged;\n}\n\n/**\n * Apply env-var mention patching and platform merge to a notification config.\n * Shared logic used by both profile and default config resolution paths.\n */\nfunction applyEnvMerge(config: NotificationConfig): NotificationConfig {\n  // Deep-merge: env platforms fill missing blocks in file config\n  const envConfig = buildConfigFromEnv();\n  let merged = envConfig ? mergeEnvIntoFileConfig(config, envConfig) : config;\n\n  // Apply env mention to any Discord config that still lacks one.\n  // This must run after mergeEnvIntoFileConfig so that file-only discord\n  // platforms (not present in env) also receive the env mention.\n  const envMention = validateMention(process.env.OMC_DISCORD_MENTION);\n  if (envMention) {\n    if (merged[\"discord-bot\"] && merged[\"discord-bot\"].mention === undefined) {\n      merged = { ...merged, \"discord-bot\": { ...merged[\"discord-bot\"], mention: envMention } };\n    }\n    if (merged.discord && merged.discord.mention === undefined) {\n      merged = { ...merged, discord: { ...merged.discord, mention: envMention } };\n    }\n  }\n\n  return merged;\n}\n\n/**\n * Get the notification configuration.\n *\n * When a profile name is provided (or set via OMC_NOTIFY_PROFILE env var),\n * the corresponding named profile from `notificationProfiles` is used.\n * Falls back to the default `notifications` config if the profile is not found.\n *\n * Reads from .omc-config.json, looking for the `notifications` key.\n * When file config exists, env-derived platforms are merged in to fill\n * missing platform blocks (file fields take precedence).\n * Falls back to migrating old `stopHookCallbacks` if present.\n * Returns null if no notification config is found.\n *\n * @param profileName - Optional profile name (overrides OMC_NOTIFY_PROFILE env var)\n */\nexport function getNotificationConfig(profileName?: string): NotificationConfig | null {\n  const raw = readRawConfig();\n  const effectiveProfile = profileName || process.env.OMC_NOTIFY_PROFILE;\n\n  // Priority 0: Named profile from notificationProfiles\n  if (effectiveProfile && raw) {\n    const profiles = raw.notificationProfiles as Record<string, NotificationConfig> | undefined;\n    if (profiles && profiles[effectiveProfile]) {\n      const profileConfig = profiles[effectiveProfile];\n      if (typeof profileConfig.enabled !== \"boolean\") {\n        return null;\n      }\n      return applyEnvMerge(profileConfig);\n    }\n    // Profile requested but not found  warn and fall through to default\n    console.warn(\n      `[notifications] Profile \"${effectiveProfile}\" not found, using default`,\n    );\n  }\n\n  // Priority 1: Explicit notifications config in .omc-config.json\n  if (raw) {\n    const notifications = raw.notifications as NotificationConfig | undefined;\n    if (notifications) {\n      if (typeof notifications.enabled !== \"boolean\") {\n        return null;\n      }\n      return applyEnvMerge(notifications);\n    }\n  }\n\n  // Priority 2: Environment variables (zero-config)\n  const envConfig = buildConfigFromEnv();\n  if (envConfig) return envConfig;\n\n  // Priority 3: Legacy stopHookCallbacks migration\n  if (raw) {\n    return migrateStopHookCallbacks(raw);\n  }\n\n  return null;\n}\n\n/**\n * Check if a specific event has any enabled platform.\n */\nexport function isEventEnabled(\n  config: NotificationConfig,\n  event: NotificationEvent,\n): boolean {\n  if (!config.enabled) return false;\n\n  const eventConfig = config.events?.[event];\n\n  // If event is explicitly disabled\n  if (eventConfig && eventConfig.enabled === false) return false;\n\n  // If event has no specific config, check if any top-level platform is enabled\n  if (!eventConfig) {\n    return !!(\n      config.discord?.enabled ||\n      config[\"discord-bot\"]?.enabled ||\n      config.telegram?.enabled ||\n      config.slack?.enabled ||\n      config.webhook?.enabled\n    );\n  }\n\n  // Check event-specific platform overrides\n  if (\n    eventConfig.discord?.enabled ||\n    eventConfig[\"discord-bot\"]?.enabled ||\n    eventConfig.telegram?.enabled ||\n    eventConfig.slack?.enabled ||\n    eventConfig.webhook?.enabled\n  ) {\n    return true;\n  }\n\n  // Fall back to top-level platforms\n  return !!(\n    config.discord?.enabled ||\n    config[\"discord-bot\"]?.enabled ||\n    config.telegram?.enabled ||\n    config.slack?.enabled ||\n    config.webhook?.enabled\n  );\n}\n\n/**\n * Get list of enabled platforms for an event.\n */\nexport function getEnabledPlatforms(\n  config: NotificationConfig,\n  event: NotificationEvent,\n): NotificationPlatform[] {\n  if (!config.enabled) return [];\n\n  const platforms: NotificationPlatform[] = [];\n  const eventConfig = config.events?.[event];\n\n  // If event is explicitly disabled\n  if (eventConfig && eventConfig.enabled === false) return [];\n\n  const checkPlatform = (platform: NotificationPlatform) => {\n    const eventPlatform =\n      eventConfig?.[platform as keyof EventNotificationConfig];\n    if (\n      eventPlatform &&\n      typeof eventPlatform === \"object\" &&\n      \"enabled\" in eventPlatform\n    ) {\n      if ((eventPlatform as { enabled: boolean }).enabled) {\n        platforms.push(platform);\n      }\n      return; // Event-level config overrides top-level\n    }\n\n    // Top-level default\n    const topLevel = config[platform as keyof NotificationConfig];\n    if (\n      topLevel &&\n      typeof topLevel === \"object\" &&\n      \"enabled\" in topLevel &&\n      (topLevel as { enabled: boolean }).enabled\n    ) {\n      platforms.push(platform);\n    }\n  };\n\n  checkPlatform(\"discord\");\n  checkPlatform(\"discord-bot\");\n  checkPlatform(\"telegram\");\n  checkPlatform(\"slack\");\n  checkPlatform(\"webhook\");\n\n  return platforms;\n}\n\n/**\n * Events checked when resolving reply-capable platform config.\n * Order matters for deterministic fallback when only event-level config exists.\n */\nconst REPLY_PLATFORM_EVENTS: NotificationEvent[] = [\n  \"session-start\",\n  \"ask-user-question\",\n  \"session-stop\",\n  \"session-idle\",\n  \"session-end\",\n];\n\n/**\n * Resolve the effective enabled platform config for reply-listener bootstrap.\n *\n * Priority:\n * 1) Top-level platform config when enabled\n * 2) First enabled event-level platform config (deterministic event order)\n */\nfunction getEnabledReplyPlatformConfig<T extends { enabled: boolean }>(\n  config: NotificationConfig,\n  platform: \"discord-bot\" | \"telegram\",\n): T | undefined {\n  const topLevel = config[platform] as T | undefined;\n  if (topLevel?.enabled) {\n    return topLevel;\n  }\n\n  for (const event of REPLY_PLATFORM_EVENTS) {\n    const eventConfig = config.events?.[event];\n    const eventPlatform =\n      eventConfig?.[platform as keyof EventNotificationConfig];\n\n    if (\n      eventPlatform &&\n      typeof eventPlatform === \"object\" &&\n      \"enabled\" in eventPlatform &&\n      (eventPlatform as { enabled: boolean }).enabled\n    ) {\n      return eventPlatform as T;\n    }\n  }\n\n  return undefined;\n}\n\n/**\n * Resolve bot credentials used by the reply listener daemon.\n * Supports both top-level and event-level platform configs.\n */\nexport function getReplyListenerPlatformConfig(\n  config: NotificationConfig | null,\n): {\n  telegramBotToken?: string;\n  telegramChatId?: string;\n  discordBotToken?: string;\n  discordChannelId?: string;\n  discordMention?: string;\n} {\n  if (!config) return {};\n\n  const telegramConfig =\n    getEnabledReplyPlatformConfig<TelegramNotificationConfig>(\n      config,\n      \"telegram\",\n    );\n  const discordBotConfig =\n    getEnabledReplyPlatformConfig<DiscordBotNotificationConfig>(\n      config,\n      \"discord-bot\",\n    );\n\n  return {\n    telegramBotToken: telegramConfig?.botToken || config.telegram?.botToken,\n    telegramChatId: telegramConfig?.chatId || config.telegram?.chatId,\n    discordBotToken:\n      discordBotConfig?.botToken || config[\"discord-bot\"]?.botToken,\n    discordChannelId:\n      discordBotConfig?.channelId || config[\"discord-bot\"]?.channelId,\n    discordMention:\n      discordBotConfig?.mention || config[\"discord-bot\"]?.mention,\n  };\n}\n\n/**\n * Parse Discord user IDs from environment variable or config array.\n * Returns empty array if neither is valid.\n */\nfunction parseDiscordUserIds(\n  envValue: string | undefined,\n  configValue: unknown,\n): string[] {\n  // Try env var first (comma-separated list)\n  if (envValue) {\n    const ids = envValue\n      .split(\",\")\n      .map((id) => id.trim())\n      .filter((id) => /^\\d{17,20}$/.test(id));\n    if (ids.length > 0) return ids;\n  }\n\n  // Try config array\n  if (Array.isArray(configValue)) {\n    const ids = configValue\n      .filter((id) => typeof id === \"string\" && /^\\d{17,20}$/.test(id));\n    if (ids.length > 0) return ids;\n  }\n\n  return [];\n}\n\n/**\n * Get reply injection configuration.\n *\n * Returns null when:\n * - Reply listening is disabled\n * - No reply-capable bot platform (discord-bot or telegram) is configured\n * - Notifications are globally disabled\n *\n * Reads from .omc-config.json notifications.reply section.\n * Environment variables override config file values:\n * - OMC_REPLY_ENABLED: enable reply listening (default: false)\n * - OMC_REPLY_POLL_INTERVAL_MS: polling interval in ms (default: 3000)\n * - OMC_REPLY_RATE_LIMIT: max messages per minute (default: 10)\n * - OMC_REPLY_DISCORD_USER_IDS: comma-separated authorized Discord user IDs\n * - OMC_REPLY_INCLUDE_PREFIX: include visual prefix (default: true)\n *\n * SECURITY: Logs warning when Discord bot is enabled but authorizedDiscordUserIds is empty.\n */\nexport function getReplyConfig(): import(\"./types.js\").ReplyConfig | null {\n  const notifConfig = getNotificationConfig();\n  if (!notifConfig?.enabled) return null;\n\n  // Check if any reply-capable platform (discord-bot or telegram) is enabled.\n  // Supports event-level platform config (not just top-level defaults).\n  const hasDiscordBot = !!getEnabledReplyPlatformConfig<DiscordBotNotificationConfig>(\n    notifConfig,\n    \"discord-bot\",\n  );\n  const hasTelegram = !!getEnabledReplyPlatformConfig<TelegramNotificationConfig>(\n    notifConfig,\n    \"telegram\",\n  );\n  if (!hasDiscordBot && !hasTelegram) return null;\n\n  // Read reply-specific config\n  const raw = readRawConfig();\n  const replyRaw = (raw?.notifications as any)?.reply;\n\n  const enabled = process.env.OMC_REPLY_ENABLED === \"true\" || replyRaw?.enabled === true;\n  if (!enabled) return null;\n\n  const authorizedDiscordUserIds = parseDiscordUserIds(\n    process.env.OMC_REPLY_DISCORD_USER_IDS,\n    replyRaw?.authorizedDiscordUserIds,\n  );\n\n  // SECURITY: If Discord bot is enabled but no authorized user IDs, log warning\n  if (hasDiscordBot && authorizedDiscordUserIds.length === 0) {\n    console.warn(\n      \"[notifications] Discord reply listening disabled: authorizedDiscordUserIds is empty. \" +\n      \"Set OMC_REPLY_DISCORD_USER_IDS or add to .omc-config.json notifications.reply.authorizedDiscordUserIds\"\n    );\n  }\n\n  return {\n    enabled: true,\n    pollIntervalMs: parseInt(process.env.OMC_REPLY_POLL_INTERVAL_MS || \"\") || replyRaw?.pollIntervalMs || 3000,\n    maxMessageLength: replyRaw?.maxMessageLength || 500,\n    rateLimitPerMinute: parseInt(process.env.OMC_REPLY_RATE_LIMIT || \"\") || replyRaw?.rateLimitPerMinute || 10,\n    includePrefix: process.env.OMC_REPLY_INCLUDE_PREFIX !== \"false\" && (replyRaw?.includePrefix !== false),\n    authorizedDiscordUserIds,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\notifications\\dispatcher.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\notifications\\formatter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\notifications\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\notifications\\reply-listener.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":572,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":572,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17559,17562],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17559,17562],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Reply Listener Daemon\n *\n * Background daemon that polls Discord and Telegram for replies to notification messages,\n * sanitizes input, verifies the target pane, and injects reply text via sendToPane().\n *\n * Security considerations:\n * - State/PID/log files use restrictive permissions (0600)\n * - Bot tokens stored in state file, NOT in environment variables\n * - Two-layer input sanitization (sanitizeReplyInput + sanitizeForTmux)\n * - Pane verification via analyzePaneContent before every injection\n * - Authorization: only configured user IDs (Discord) / chat ID (Telegram) can inject\n * - Rate limiting to prevent spam/abuse\n *\n * Follows the daemon pattern from src/features/rate-limit-wait/daemon.ts\n */\n\nimport { existsSync, mkdirSync, readFileSync, writeFileSync, unlinkSync, chmodSync, statSync, appendFileSync, renameSync } from 'fs';\nimport { join } from 'path';\nimport { fileURLToPath } from 'url';\nimport { homedir } from 'os';\nimport { spawn } from 'child_process';\nimport { request as httpsRequest } from 'https';\nimport {\n  capturePaneContent,\n  analyzePaneContent,\n  sendToPane,\n  isTmuxAvailable,\n} from '../features/rate-limit-wait/tmux-detector.js';\nimport {\n  lookupByMessageId,\n  removeMessagesByPane,\n  pruneStale,\n} from './session-registry.js';\nimport type { ReplyConfig } from './types.js';\nimport { parseMentionAllowedMentions } from './config.js';\n\n// ESM compatibility: __filename is not available in ES modules\nconst __filename = fileURLToPath(import.meta.url);\n\n// ============================================================================\n// Constants and Types\n// ============================================================================\n\n/** Restrictive file permissions (owner read/write only) */\nconst SECURE_FILE_MODE = 0o600;\n\n/** Maximum log file size before rotation (1MB) */\nconst MAX_LOG_SIZE_BYTES = 1 * 1024 * 1024;\n\n/**\n * Allowlist of environment variables safe to pass to daemon child process.\n * This prevents leaking sensitive variables like ANTHROPIC_API_KEY, GITHUB_TOKEN, etc.\n * OMC_* notification env vars are forwarded so the daemon can call getNotificationConfig().\n */\nconst DAEMON_ENV_ALLOWLIST = [\n  'PATH', 'HOME', 'USERPROFILE',\n  'USER', 'USERNAME', 'LOGNAME',\n  'LANG', 'LC_ALL', 'LC_CTYPE',\n  'TERM', 'TMUX', 'TMUX_PANE',\n  'TMPDIR', 'TMP', 'TEMP',\n  'XDG_RUNTIME_DIR', 'XDG_DATA_HOME', 'XDG_CONFIG_HOME',\n  'SHELL',\n  'NODE_ENV',\n  'HTTP_PROXY', 'HTTPS_PROXY', 'http_proxy', 'https_proxy', 'NO_PROXY', 'no_proxy',\n  'SystemRoot', 'SYSTEMROOT', 'windir', 'COMSPEC',\n] as const;\n\n/** Default paths */\nconst DEFAULT_STATE_DIR = join(homedir(), '.omc', 'state');\nconst PID_FILE_PATH = join(DEFAULT_STATE_DIR, 'reply-listener.pid');\nconst STATE_FILE_PATH = join(DEFAULT_STATE_DIR, 'reply-listener-state.json');\nconst LOG_FILE_PATH = join(DEFAULT_STATE_DIR, 'reply-listener.log');\n\n/** Reply listener daemon state */\nexport interface ReplyListenerState {\n  isRunning: boolean;\n  pid: number | null;\n  startedAt: string | null;\n  lastPollAt: string | null;\n  telegramLastUpdateId: number | null;\n  discordLastMessageId: string | null;\n  messagesInjected: number;\n  errors: number;\n  lastError?: string;\n}\n\n/** Daemon configuration (written to state file) */\nexport interface ReplyListenerDaemonConfig extends ReplyConfig {\n  // Bot tokens stored here (0600 file), NOT in env vars\n  telegramBotToken?: string;\n  telegramChatId?: string;\n  discordBotToken?: string;\n  discordChannelId?: string;\n  /** Discord mention tag to include in injection feedback (e.g. \"<@123456>\") */\n  discordMention?: string;\n}\n\n/** Response from daemon operations */\nexport interface DaemonResponse {\n  success: boolean;\n  message: string;\n  state?: ReplyListenerState;\n  error?: string;\n}\n\n// ============================================================================\n// Utility Functions\n// ============================================================================\n\n/**\n * Create a minimal environment for daemon child processes.\n * Only includes allowlisted variables to prevent credential leakage.\n */\nfunction createMinimalDaemonEnv(): NodeJS.ProcessEnv {\n  const env: NodeJS.ProcessEnv = {};\n  for (const key of DAEMON_ENV_ALLOWLIST) {\n    if (process.env[key] !== undefined) {\n      env[key] = process.env[key];\n    }\n  }\n  // Forward OMC_* env vars so the daemon can call getNotificationConfig()\n  for (const key of Object.keys(process.env)) {\n    if (key.startsWith('OMC_')) {\n      env[key] = process.env[key];\n    }\n  }\n  return env;\n}\n\n/**\n * Ensure state directory exists with secure permissions\n */\nfunction ensureStateDir(): void {\n  if (!existsSync(DEFAULT_STATE_DIR)) {\n    mkdirSync(DEFAULT_STATE_DIR, { recursive: true, mode: 0o700 });\n  }\n}\n\n/**\n * Write file with secure permissions (0600 - owner read/write only)\n */\nfunction writeSecureFile(filePath: string, content: string): void {\n  ensureStateDir();\n  writeFileSync(filePath, content, { mode: SECURE_FILE_MODE });\n  try {\n    chmodSync(filePath, SECURE_FILE_MODE);\n  } catch {\n    // Ignore permission errors (e.g., on Windows)\n  }\n}\n\n/**\n * Rotate log file if it exceeds maximum size\n */\nfunction rotateLogIfNeeded(logPath: string): void {\n  try {\n    if (!existsSync(logPath)) return;\n\n    const stats = statSync(logPath);\n    if (stats.size > MAX_LOG_SIZE_BYTES) {\n      const backupPath = `${logPath}.old`;\n      if (existsSync(backupPath)) {\n        unlinkSync(backupPath);\n      }\n      renameSync(logPath, backupPath);\n    }\n  } catch {\n    // Ignore rotation errors\n  }\n}\n\n/**\n * Log message to daemon log file with rotation\n */\nfunction log(message: string): void {\n  try {\n    ensureStateDir();\n    rotateLogIfNeeded(LOG_FILE_PATH);\n\n    const timestamp = new Date().toISOString();\n    const logLine = `[${timestamp}] ${message}\\n`;\n\n    appendFileSync(LOG_FILE_PATH, logLine, { mode: SECURE_FILE_MODE });\n  } catch {\n    // Ignore log write errors\n  }\n}\n\n/**\n * Read daemon state from disk\n */\nfunction readDaemonState(): ReplyListenerState | null {\n  try {\n    if (!existsSync(STATE_FILE_PATH)) {\n      return null;\n    }\n\n    const content = readFileSync(STATE_FILE_PATH, 'utf-8');\n    const state = JSON.parse(content) as ReplyListenerState;\n    return state;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Write daemon state to disk with secure permissions\n */\nfunction writeDaemonState(state: ReplyListenerState): void {\n  writeSecureFile(STATE_FILE_PATH, JSON.stringify(state, null, 2));\n}\n\n/**\n * Build daemon config from notification config.\n * Derives bot tokens, channel IDs, and reply settings from getNotificationConfig().\n */\nasync function buildDaemonConfig(): Promise<ReplyListenerDaemonConfig | null> {\n  try {\n    const { getReplyConfig, getNotificationConfig, getReplyListenerPlatformConfig } = await import('./config.js');\n    const replyConfig = getReplyConfig();\n    if (!replyConfig) return null;\n    const notifConfig = getNotificationConfig();\n    const platformConfig = getReplyListenerPlatformConfig(notifConfig);\n    return { ...replyConfig, ...platformConfig };\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Read PID file\n */\nfunction readPidFile(): number | null {\n  try {\n    if (!existsSync(PID_FILE_PATH)) {\n      return null;\n    }\n    const content = readFileSync(PID_FILE_PATH, 'utf-8');\n    return parseInt(content.trim(), 10);\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Write PID file with secure permissions\n */\nfunction writePidFile(pid: number): void {\n  writeSecureFile(PID_FILE_PATH, String(pid));\n}\n\n/**\n * Remove PID file\n */\nfunction removePidFile(): void {\n  if (existsSync(PID_FILE_PATH)) {\n    unlinkSync(PID_FILE_PATH);\n  }\n}\n\n/**\n * Check if a process is running\n */\nfunction isProcessRunning(pid: number): boolean {\n  try {\n    process.kill(pid, 0);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Check if daemon is currently running\n */\nexport function isDaemonRunning(): boolean {\n  const pid = readPidFile();\n  if (pid === null) {\n    return false;\n  }\n\n  if (!isProcessRunning(pid)) {\n    removePidFile();\n    return false;\n  }\n\n  return true;\n}\n\n// ============================================================================\n// Input Sanitization\n// ============================================================================\n\n/**\n * Sanitize reply input from Discord/Telegram before tmux injection.\n * Applied BEFORE sendToPane()'s own sanitizeForTmux().\n *\n * Defenses:\n * - Newlines replaced with spaces (prevents multi-command injection)\n * - Backticks escaped (prevents command substitution in some shells)\n * - $() and ${} patterns escaped (prevents command substitution)\n * - Backslashes escaped (prevents escape sequence injection)\n * - Control characters stripped\n */\nexport function sanitizeReplyInput(text: string): string {\n  return text\n    .replace(/[\\x00-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]/g, '')  // Strip control chars (keep \\n, \\r, \\t)\n    .replace(/\\r?\\n/g, ' ')                            // Newlines -> spaces\n    .replace(/\\\\/g, '\\\\\\\\')                            // Escape backslashes\n    .replace(/`/g, '\\\\`')                              // Escape backticks\n    .replace(/\\$\\(/g, '\\\\$(')                          // Escape $()\n    .replace(/\\$\\{/g, '\\\\${')                          // Escape ${}\n    .trim();\n}\n\n// ============================================================================\n// Rate Limiting\n// ============================================================================\n\nclass RateLimiter {\n  private timestamps: number[] = [];\n  private readonly windowMs = 60 * 1000; // 1 minute\n\n  constructor(private readonly maxPerMinute: number) {}\n\n  canProceed(): boolean {\n    const now = Date.now();\n    // Remove timestamps outside the window\n    this.timestamps = this.timestamps.filter(t => now - t < this.windowMs);\n\n    if (this.timestamps.length >= this.maxPerMinute) {\n      return false;\n    }\n\n    this.timestamps.push(now);\n    return true;\n  }\n\n  reset(): void {\n    this.timestamps = [];\n  }\n}\n\n// ============================================================================\n// Injection\n// ============================================================================\n\n/**\n * Inject reply text into a tmux pane after verification and sanitization.\n *\n * Returns true if injection succeeded, false otherwise.\n */\nfunction injectReply(\n  paneId: string,\n  text: string,\n  platform: string,\n  config: ReplyListenerDaemonConfig,\n): boolean {\n  // 1. Verify pane is running Claude Code\n  const content = capturePaneContent(paneId, 15);\n  const analysis = analyzePaneContent(content);\n\n  if (analysis.confidence < 0.4) {\n    log(`WARN: Pane ${paneId} does not appear to be running Claude Code (confidence: ${analysis.confidence}). Skipping injection, removing stale mapping.`);\n    removeMessagesByPane(paneId);\n    return false;\n  }\n\n  // 2. Build prefixed text if configured\n  const prefix = config.includePrefix ? `[reply:${platform}] ` : '';\n\n  // 3. Sanitize the reply text\n  const sanitized = sanitizeReplyInput(prefix + text);\n\n  // 4. Truncate to max length\n  const truncated = sanitized.slice(0, config.maxMessageLength);\n\n  // 5. Inject via sendToPane (which applies its own sanitizeForTmux)\n  const success = sendToPane(paneId, truncated, true);\n\n  if (success) {\n    log(`Injected reply from ${platform} into pane ${paneId}: \"${truncated.slice(0, 50)}${truncated.length > 50 ? '...' : ''}\"`);\n  } else {\n    log(`ERROR: Failed to inject reply into pane ${paneId}`);\n  }\n\n  return success;\n}\n\n// ============================================================================\n// Discord Polling\n// ============================================================================\n\n/** Track when to back off Discord polling due to rate limits */\nlet discordBackoffUntil = 0;\n\n/**\n * Poll Discord for new replies and inject them.\n */\nasync function pollDiscord(\n  config: ReplyListenerDaemonConfig,\n  state: ReplyListenerState,\n  rateLimiter: RateLimiter,\n): Promise<void> {\n  if (!config.discordBotToken || !config.discordChannelId) {\n    return;\n  }\n\n  if (config.authorizedDiscordUserIds.length === 0) {\n    // Discord reply listening disabled when no authorized users\n    return;\n  }\n\n  // Rate limit backoff\n  if (Date.now() < discordBackoffUntil) {\n    return;\n  }\n\n  try {\n    const after = state.discordLastMessageId ? `?after=${state.discordLastMessageId}&limit=10` : '?limit=10';\n    const url = `https://discord.com/api/v10/channels/${config.discordChannelId}/messages${after}`;\n\n    const response = await fetch(url, {\n      method: 'GET',\n      headers: {\n        'Authorization': `Bot ${config.discordBotToken}`,\n      },\n      signal: AbortSignal.timeout(10000),\n    });\n\n    // Read rate limit headers and back off when remaining < 2\n    const remaining = response.headers.get('x-ratelimit-remaining');\n    const reset = response.headers.get('x-ratelimit-reset');\n    if (remaining !== null && parseInt(remaining, 10) < 2) {\n      const resetTime = reset ? parseFloat(reset) * 1000 : Date.now() + 10_000;\n      discordBackoffUntil = resetTime;\n      log(`WARN: Discord rate limit low (remaining: ${remaining}), backing off until ${new Date(resetTime).toISOString()}`);\n    }\n\n    if (!response.ok) {\n      log(`Discord API error: HTTP ${response.status}`);\n      return;\n    }\n\n    const messages = await response.json() as Array<{\n      id: string;\n      author: { id: string };\n      content: string;\n      message_reference?: { message_id: string };\n    }>;\n\n    if (!Array.isArray(messages) || messages.length === 0) return;\n\n    // Process messages in chronological order (oldest first; Discord returns newest first)\n    const sorted = [...messages].reverse();\n\n    for (const msg of sorted) {\n      // Filter: message has message_reference (it's a reply)\n      if (!msg.message_reference?.message_id) {\n        // Still advance the offset\n        state.discordLastMessageId = msg.id;\n        writeDaemonState(state);\n        continue;\n      }\n\n      // Filter: author is in authorizedDiscordUserIds\n      if (!config.authorizedDiscordUserIds.includes(msg.author.id)) {\n        state.discordLastMessageId = msg.id;\n        writeDaemonState(state);\n        continue;\n      }\n\n      // Filter: referenced message exists in session registry\n      const mapping = lookupByMessageId('discord-bot', msg.message_reference.message_id);\n      if (!mapping) {\n        state.discordLastMessageId = msg.id;\n        writeDaemonState(state);\n        continue;\n      }\n\n      // Rate limiting\n      if (!rateLimiter.canProceed()) {\n        log(`WARN: Rate limit exceeded, dropping Discord message ${msg.id}`);\n        state.discordLastMessageId = msg.id;\n        writeDaemonState(state);\n        state.errors++;\n        continue;\n      }\n\n      // AT-MOST-ONCE: persist offset BEFORE injection\n      state.discordLastMessageId = msg.id;\n      writeDaemonState(state);\n\n      // Inject reply\n      const success = injectReply(mapping.tmuxPaneId, msg.content, 'discord', config);\n      if (success) {\n        state.messagesInjected++;\n\n        // Send confirmation reaction (non-critical)\n        try {\n          await fetch(\n            `https://discord.com/api/v10/channels/${config.discordChannelId}/messages/${msg.id}/reactions/%E2%9C%85/@me`,\n            {\n              method: 'PUT',\n              headers: { 'Authorization': `Bot ${config.discordBotToken}` },\n              signal: AbortSignal.timeout(5000),\n            }\n          );\n        } catch (e) {\n          log(`WARN: Failed to add confirmation reaction: ${e}`);\n        }\n\n        // Send injection notification to channel (non-critical)\n        try {\n          const mentionPrefix = config.discordMention ? `${config.discordMention} ` : '';\n          const feedbackAllowedMentions = config.discordMention\n            ? parseMentionAllowedMentions(config.discordMention)\n            : { parse: [] as string[] };\n          await fetch(\n            `https://discord.com/api/v10/channels/${config.discordChannelId}/messages`,\n            {\n              method: 'POST',\n              headers: {\n                'Authorization': `Bot ${config.discordBotToken}`,\n                'Content-Type': 'application/json',\n              },\n              body: JSON.stringify({\n                content: `${mentionPrefix}Injected into Claude Code session.`,\n                message_reference: { message_id: msg.id },\n                allowed_mentions: feedbackAllowedMentions,\n              }),\n              signal: AbortSignal.timeout(5000),\n            }\n          );\n        } catch (e) {\n          log(`WARN: Failed to send injection channel notification: ${e}`);\n        }\n      } else {\n        state.errors++;\n      }\n    }\n\n  } catch (error) {\n    state.errors++;\n    state.lastError = error instanceof Error ? error.message : String(error);\n    log(`Discord polling error: ${state.lastError}`);\n  }\n}\n\n// ============================================================================\n// Telegram Polling\n// ============================================================================\n\n/**\n * Poll Telegram for new replies and inject them.\n * Uses httpsRequest with family:4 to match sendTelegram() pattern.\n */\nasync function pollTelegram(\n  config: ReplyListenerDaemonConfig,\n  state: ReplyListenerState,\n  rateLimiter: RateLimiter,\n): Promise<void> {\n  if (!config.telegramBotToken || !config.telegramChatId) {\n    return;\n  }\n\n  try {\n    const offset = state.telegramLastUpdateId ? state.telegramLastUpdateId + 1 : 0;\n    const path = `/bot${config.telegramBotToken}/getUpdates?offset=${offset}&timeout=0`;\n\n    const updates = await new Promise<any[]>((resolve, reject) => {\n      const req = httpsRequest(\n        {\n          hostname: 'api.telegram.org',\n          path,\n          method: 'GET',\n          family: 4, // Force IPv4\n          timeout: 10000,\n        },\n        (res) => {\n          const chunks: Buffer[] = [];\n          res.on('data', (chunk: Buffer) => chunks.push(chunk));\n          res.on('end', () => {\n            try {\n              const body = JSON.parse(Buffer.concat(chunks).toString('utf-8'));\n              if (res.statusCode && res.statusCode >= 200 && res.statusCode < 300) {\n                resolve(body.result || []);\n              } else {\n                reject(new Error(`HTTP ${res.statusCode}`));\n              }\n            } catch (e) {\n              reject(e);\n            }\n          });\n        }\n      );\n\n      req.on('error', reject);\n      req.on('timeout', () => {\n        req.destroy();\n        reject(new Error('Request timeout'));\n      });\n\n      req.end();\n    });\n\n    for (const update of updates) {\n      const msg = update.message;\n      if (!msg) {\n        // Always advance offset even for non-message updates\n        state.telegramLastUpdateId = update.update_id;\n        writeDaemonState(state);\n        continue;\n      }\n\n      // Filter: message has reply_to_message\n      if (!msg.reply_to_message?.message_id) {\n        state.telegramLastUpdateId = update.update_id;\n        writeDaemonState(state);\n        continue;\n      }\n\n      // Filter: chat.id matches configured chatId\n      if (String(msg.chat.id) !== config.telegramChatId) {\n        state.telegramLastUpdateId = update.update_id;\n        writeDaemonState(state);\n        continue;\n      }\n\n      // Filter: referenced message exists in session registry\n      const mapping = lookupByMessageId('telegram', String(msg.reply_to_message.message_id));\n      if (!mapping) {\n        state.telegramLastUpdateId = update.update_id;\n        writeDaemonState(state);\n        continue;\n      }\n\n      const text = msg.text || '';\n      if (!text) {\n        state.telegramLastUpdateId = update.update_id;\n        writeDaemonState(state);\n        continue;\n      }\n\n      // Rate limiting\n      if (!rateLimiter.canProceed()) {\n        log(`WARN: Rate limit exceeded, dropping Telegram message ${msg.message_id}`);\n        state.telegramLastUpdateId = update.update_id;\n        writeDaemonState(state);\n        state.errors++;\n        continue;\n      }\n\n      // AT-MOST-ONCE: persist offset BEFORE injection\n      state.telegramLastUpdateId = update.update_id;\n      writeDaemonState(state);\n\n      // Inject reply\n      const success = injectReply(mapping.tmuxPaneId, text, 'telegram', config);\n      if (success) {\n        state.messagesInjected++;\n\n        // Send confirmation reply (non-critical)\n        try {\n          const replyBody = JSON.stringify({\n            chat_id: config.telegramChatId,\n            text: 'Injected into Claude Code session.',\n            reply_to_message_id: msg.message_id,\n          });\n\n          await new Promise<void>((resolve) => {\n            const replyReq = httpsRequest(\n              {\n                hostname: 'api.telegram.org',\n                path: `/bot${config.telegramBotToken}/sendMessage`,\n                method: 'POST',\n                family: 4,\n                headers: {\n                  'Content-Type': 'application/json',\n                  'Content-Length': Buffer.byteLength(replyBody),\n                },\n                timeout: 5000,\n              },\n              (res) => {\n                res.resume(); // Drain response\n                resolve();\n              }\n            );\n\n            replyReq.on('error', () => resolve());\n            replyReq.on('timeout', () => {\n              replyReq.destroy();\n              resolve();\n            });\n\n            replyReq.write(replyBody);\n            replyReq.end();\n          });\n        } catch (e) {\n          log(`WARN: Failed to send confirmation reply: ${e}`);\n        }\n      } else {\n        state.errors++;\n      }\n    }\n\n  } catch (error) {\n    state.errors++;\n    state.lastError = error instanceof Error ? error.message : String(error);\n    log(`Telegram polling error: ${state.lastError}`);\n  }\n}\n\n// ============================================================================\n// Main Daemon Loop\n// ============================================================================\n\n/** Prune stale registry entries every hour */\nconst PRUNE_INTERVAL_MS = 60 * 60 * 1000;\n\n/**\n * Main daemon polling loop\n */\nasync function pollLoop(): Promise<void> {\n  log('Reply listener daemon starting poll loop');\n\n  const config = await buildDaemonConfig();\n  if (!config) {\n    log('ERROR: No notification config found for reply listener, exiting');\n    process.exit(1);\n  }\n\n  const state = readDaemonState() || {\n    isRunning: true,\n    pid: process.pid,\n    startedAt: new Date().toISOString(),\n    lastPollAt: null,\n    telegramLastUpdateId: null,\n    discordLastMessageId: null,\n    messagesInjected: 0,\n    errors: 0,\n  };\n\n  state.isRunning = true;\n  state.pid = process.pid;\n\n  const rateLimiter = new RateLimiter(config.rateLimitPerMinute);\n  let lastPruneAt = Date.now();\n\n  // Graceful shutdown handlers\n  const shutdown = () => {\n    log('Shutdown signal received');\n    state.isRunning = false;\n    writeDaemonState(state);\n    removePidFile();\n    process.exit(0);\n  };\n\n  process.on('SIGTERM', shutdown);\n  process.on('SIGINT', shutdown);\n\n  // Prune stale registry entries on startup\n  try {\n    pruneStale();\n    log('Pruned stale registry entries');\n  } catch (e) {\n    log(`WARN: Failed to prune stale entries: ${e}`);\n  }\n\n  while (state.isRunning) {\n    try {\n      state.lastPollAt = new Date().toISOString();\n\n      // Poll platforms sequentially (shared state, avoid race conditions)\n      await pollDiscord(config, state, rateLimiter);\n      await pollTelegram(config, state, rateLimiter);\n\n      // Periodic prune (every hour)\n      if (Date.now() - lastPruneAt > PRUNE_INTERVAL_MS) {\n        try {\n          pruneStale();\n          lastPruneAt = Date.now();\n          log('Pruned stale registry entries');\n        } catch (e) {\n          log(`WARN: Prune failed: ${e instanceof Error ? e.message : String(e)}`);\n        }\n      }\n\n      writeDaemonState(state);\n\n      // Wait for next poll\n      await new Promise((resolve) => setTimeout(resolve, config.pollIntervalMs));\n\n    } catch (error) {\n      state.errors++;\n      state.lastError = error instanceof Error ? error.message : String(error);\n      log(`Poll error: ${state.lastError}`);\n      writeDaemonState(state);\n\n      // Back off on repeated errors\n      await new Promise((resolve) => setTimeout(resolve, config.pollIntervalMs * 2));\n    }\n  }\n\n  log('Poll loop ended');\n}\n\n// ============================================================================\n// Daemon Control\n// ============================================================================\n\n/**\n * Start the reply listener daemon.\n *\n * Forks a daemon process that derives its config from getNotificationConfig().\n * OMC_* env vars are forwarded so the daemon can read both file and env config.\n *\n * Idempotent: if daemon is already running, returns success.\n *\n * @param config - Daemon config (used only for validation, daemon reads config independently)\n */\nexport function startReplyListener(_config: ReplyListenerDaemonConfig): DaemonResponse {\n  // Check if already running (idempotent)\n  if (isDaemonRunning()) {\n    const state = readDaemonState();\n    return {\n      success: true,\n      message: 'Reply listener daemon is already running',\n      state: state ?? undefined,\n    };\n  }\n\n  // Check for tmux\n  if (!isTmuxAvailable()) {\n    return {\n      success: false,\n      message: 'tmux not available - reply injection requires tmux',\n    };\n  }\n\n  ensureStateDir();\n\n  // Fork a new process for the daemon\n  const modulePath = __filename.replace(/\\.ts$/, '.js');\n  const daemonScript = `\n    import('${modulePath}').then(({ pollLoop }) => {\n      return pollLoop();\n    }).catch((err) => { console.error(err); process.exit(1); });\n  `;\n\n  try {\n    const child = spawn('node', ['-e', daemonScript], {\n      detached: true,\n      stdio: 'ignore',\n      cwd: process.cwd(),\n      env: createMinimalDaemonEnv(),\n    });\n\n    child.unref();\n\n    const pid = child.pid;\n    if (pid) {\n      writePidFile(pid);\n\n      const state: ReplyListenerState = {\n        isRunning: true,\n        pid,\n        startedAt: new Date().toISOString(),\n        lastPollAt: null,\n        telegramLastUpdateId: null,\n        discordLastMessageId: null,\n        messagesInjected: 0,\n        errors: 0,\n      };\n      writeDaemonState(state);\n\n      log(`Reply listener daemon started with PID ${pid}`);\n\n      return {\n        success: true,\n        message: `Reply listener daemon started with PID ${pid}`,\n        state,\n      };\n    }\n\n    return {\n      success: false,\n      message: 'Failed to start daemon process',\n    };\n  } catch (error) {\n    return {\n      success: false,\n      message: 'Failed to start daemon',\n      error: error instanceof Error ? error.message : String(error),\n    };\n  }\n}\n\n/**\n * Stop the reply listener daemon\n */\nexport function stopReplyListener(): DaemonResponse {\n  const pid = readPidFile();\n\n  if (pid === null) {\n    return {\n      success: true,\n      message: 'Reply listener daemon is not running',\n    };\n  }\n\n  if (!isProcessRunning(pid)) {\n    removePidFile();\n    return {\n      success: true,\n      message: 'Reply listener daemon was not running (cleaned up stale PID file)',\n    };\n  }\n\n  try {\n    process.kill(pid, 'SIGTERM');\n    removePidFile();\n\n    const state = readDaemonState();\n    if (state) {\n      state.isRunning = false;\n      state.pid = null;\n      writeDaemonState(state);\n    }\n\n    log(`Reply listener daemon stopped (PID ${pid})`);\n\n    return {\n      success: true,\n      message: `Reply listener daemon stopped (PID ${pid})`,\n      state: state ?? undefined,\n    };\n  } catch (error) {\n    return {\n      success: false,\n      message: 'Failed to stop daemon',\n      error: error instanceof Error ? error.message : String(error),\n    };\n  }\n}\n\n/**\n * Get daemon status\n */\nexport function getReplyListenerStatus(): DaemonResponse {\n  const state = readDaemonState();\n  const running = isDaemonRunning();\n\n  if (!running && !state) {\n    return {\n      success: true,\n      message: 'Reply listener daemon has never been started',\n    };\n  }\n\n  if (!running && state) {\n    return {\n      success: true,\n      message: 'Reply listener daemon is not running',\n      state: { ...state, isRunning: false, pid: null },\n    };\n  }\n\n  return {\n    success: true,\n    message: 'Reply listener daemon is running',\n    state: state ?? undefined,\n  };\n}\n\n// Export pollLoop for use by the daemon subprocess\nexport { pollLoop };\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\notifications\\session-registry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\notifications\\tmux.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\notifications\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\platform\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\platform\\process-utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\providers\\azure-devops.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\providers\\bitbucket.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\providers\\gitea.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\providers\\github.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\providers\\gitlab.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\providers\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\providers\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\shared\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\shared\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\skills\\__tests__\\mingw-escape.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\team\\__tests__\\activity-log.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\team\\__tests__\\audit-log.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\team\\__tests__\\bridge-entry.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\team\\__tests__\\bridge-integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\team\\__tests__\\capabilities.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\team\\__tests__\\edge-cases.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\team\\__tests__\\fs-utils.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\team\\__tests__\\git-worktree.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\team\\__tests__\\heartbeat.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\team\\__tests__\\inbox-outbox.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\team\\__tests__\\merge-coordinator.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\team\\__tests__\\message-router.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\team\\__tests__\\outbox-reader.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\team\\__tests__\\permissions.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\team\\__tests__\\prompt-sanitization.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\team\\__tests__\\summary-report.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\team\\__tests__\\task-file-ops.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\team\\__tests__\\task-router.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\team\\__tests__\\team-registration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\team\\__tests__\\team-status.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\team\\__tests__\\tmux-session.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\team\\__tests__\\unified-team.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\team\\__tests__\\usage-tracker.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\team\\__tests__\\worker-health.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\team\\__tests__\\worker-restart.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\team\\activity-log.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\team\\audit-log.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\team\\bridge-entry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\team\\capabilities.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\team\\fs-utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\team\\git-worktree.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\team\\heartbeat.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\team\\inbox-outbox.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\team\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\team\\mcp-team-bridge.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\team\\merge-coordinator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\team\\message-router.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\team\\outbox-reader.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\team\\permissions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\team\\summary-report.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\team\\task-file-ops.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\team\\task-router.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\team\\team-registration.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\team\\team-status.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\team\\tmux-session.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\team\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\team\\unified-team.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\team\\usage-tracker.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\team\\worker-health.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\team\\worker-restart.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\tools\\__tests__\\schema-conversion.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\tools\\__tests__\\state-tools.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\tools\\ast-tools.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\tools\\diagnostics\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\tools\\diagnostics\\lsp-aggregator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\tools\\diagnostics\\tsc-runner.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":56,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":56,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1238,1241],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1238,1241],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * TypeScript Compiler Diagnostics Runner\n *\n * Executes `tsc --noEmit` to get project-level type checking diagnostics.\n */\n\nimport { execSync } from 'child_process';\nimport { existsSync } from 'fs';\nimport { join } from 'path';\n\nexport interface TscDiagnostic {\n  file: string;\n  line: number;\n  column: number;\n  code: string;\n  message: string;\n  severity: 'error' | 'warning';\n}\n\nexport interface TscResult {\n  success: boolean;\n  diagnostics: TscDiagnostic[];\n  errorCount: number;\n  warningCount: number;\n}\n\n/**\n * Run TypeScript compiler diagnostics on a directory\n * @param directory - Project directory containing tsconfig.json\n * @returns Result with diagnostics, error count, and warning count\n */\nexport function runTscDiagnostics(directory: string): TscResult {\n  const tsconfigPath = join(directory, 'tsconfig.json');\n\n  if (!existsSync(tsconfigPath)) {\n    return {\n      success: true,\n      diagnostics: [],\n      errorCount: 0,\n      warningCount: 0\n    };\n  }\n\n  try {\n    execSync('tsc --noEmit --pretty false', {\n      cwd: directory,\n      encoding: 'utf-8',\n      stdio: 'pipe'\n    });\n    return {\n      success: true,\n      diagnostics: [],\n      errorCount: 0,\n      warningCount: 0\n    };\n  } catch (error: any) {\n    const output = error.stdout || error.stderr || '';\n    return parseTscOutput(output);\n  }\n}\n\n/**\n * Parse TypeScript compiler output into structured diagnostics\n * Format: file(line,col): error TS1234: message\n */\nfunction parseTscOutput(output: string): TscResult {\n  const diagnostics: TscDiagnostic[] = [];\n\n  // Parse tsc output format: file(line,col): error TS1234: message\n  const regex = /^(.+)\\((\\d+),(\\d+)\\):\\s+(error|warning)\\s+(TS\\d+):\\s+(.+)$/gm;\n  let match;\n\n  while ((match = regex.exec(output)) !== null) {\n    diagnostics.push({\n      file: match[1],\n      line: parseInt(match[2], 10),\n      column: parseInt(match[3], 10),\n      severity: match[4] as 'error' | 'warning',\n      code: match[5],\n      message: match[6]\n    });\n  }\n\n  const errorCount = diagnostics.filter(d => d.severity === 'error').length;\n  const warningCount = diagnostics.filter(d => d.severity === 'warning').length;\n\n  return {\n    success: errorCount === 0,\n    diagnostics,\n    errorCount,\n    warningCount\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\tools\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\tools\\lsp-tools.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\tools\\lsp\\__tests__\\client-eviction.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\tools\\lsp\\__tests__\\client-win32-spawn.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\tools\\lsp\\client.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\tools\\lsp\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\tools\\lsp\\servers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\tools\\lsp\\utils.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":81,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":81,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1687,1690],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1687,1690],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":84,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":84,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1828,1831],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1828,1831],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":84,"column":89,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":84,"endColumn":92,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1861,1864],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1861,1864],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * LSP Utilities\n *\n * Helper functions for formatting LSP results and converting between formats.\n */\n\nimport type { Hover, Location, DocumentSymbol, SymbolInformation, Diagnostic, CodeAction, WorkspaceEdit, Range } from './client.js';\n\n/**\n * Symbol kind names (LSP spec)\n */\nconst SYMBOL_KINDS: Record<number, string> = {\n  1: 'File',\n  2: 'Module',\n  3: 'Namespace',\n  4: 'Package',\n  5: 'Class',\n  6: 'Method',\n  7: 'Property',\n  8: 'Field',\n  9: 'Constructor',\n  10: 'Enum',\n  11: 'Interface',\n  12: 'Function',\n  13: 'Variable',\n  14: 'Constant',\n  15: 'String',\n  16: 'Number',\n  17: 'Boolean',\n  18: 'Array',\n  19: 'Object',\n  20: 'Key',\n  21: 'Null',\n  22: 'EnumMember',\n  23: 'Struct',\n  24: 'Event',\n  25: 'Operator',\n  26: 'TypeParameter'\n};\n\n/**\n * Diagnostic severity names\n */\nconst SEVERITY_NAMES: Record<number, string> = {\n  1: 'Error',\n  2: 'Warning',\n  3: 'Information',\n  4: 'Hint'\n};\n\n/**\n * Convert URI to file path\n */\nexport function uriToPath(uri: string): string {\n  if (uri.startsWith('file://')) {\n    return decodeURIComponent(uri.slice(7));\n  }\n  return uri;\n}\n\n/**\n * Format a position for display\n */\nexport function formatPosition(line: number, character: number): string {\n  return `${line + 1}:${character + 1}`;\n}\n\n/**\n * Format a range for display\n */\nexport function formatRange(range: Range): string {\n  const start = formatPosition(range.start.line, range.start.character);\n  const end = formatPosition(range.end.line, range.end.character);\n  return start === end ? start : `${start}-${end}`;\n}\n\n/**\n * Format a location for display\n */\nexport function formatLocation(location: Location): string {\n  const uri = location.uri || (location as any).targetUri;\n  if (!uri) return 'Unknown location';\n  const path = uriToPath(uri);\n  const locationRange = location.range || (location as any).targetRange || (location as any).targetSelectionRange;\n  if (!locationRange) return path;\n  const range = formatRange(locationRange);\n  return `${path}:${range}`;\n}\n\n/**\n * Format hover content\n */\nexport function formatHover(hover: Hover | null): string {\n  if (!hover) return 'No hover information available';\n\n  let text = '';\n\n  if (typeof hover.contents === 'string') {\n    text = hover.contents;\n  } else if (Array.isArray(hover.contents)) {\n    text = hover.contents.map(c => {\n      if (typeof c === 'string') return c;\n      return c.value;\n    }).join('\\n\\n');\n  } else if ('value' in hover.contents) {\n    text = hover.contents.value;\n  }\n\n  if (hover.range) {\n    text += `\\n\\nRange: ${formatRange(hover.range)}`;\n  }\n\n  return text || 'No hover information available';\n}\n\n/**\n * Format locations array\n */\nexport function formatLocations(locations: Location | Location[] | null): string {\n  if (!locations) return 'No locations found';\n\n  const locs = Array.isArray(locations) ? locations : [locations];\n\n  if (locs.length === 0) return 'No locations found';\n\n  return locs.map(loc => formatLocation(loc)).join('\\n');\n}\n\n/**\n * Format document symbols (hierarchical)\n */\nexport function formatDocumentSymbols(symbols: DocumentSymbol[] | SymbolInformation[] | null, indent = 0): string {\n  if (!symbols || symbols.length === 0) return 'No symbols found';\n\n  const lines: string[] = [];\n  const prefix = '  '.repeat(indent);\n\n  for (const symbol of symbols) {\n    const kind = SYMBOL_KINDS[symbol.kind] || 'Unknown';\n\n    if ('range' in symbol) {\n      // DocumentSymbol\n      const range = formatRange(symbol.range);\n      lines.push(`${prefix}${kind}: ${symbol.name} [${range}]`);\n\n      if (symbol.children && symbol.children.length > 0) {\n        lines.push(formatDocumentSymbols(symbol.children, indent + 1));\n      }\n    } else {\n      // SymbolInformation\n      const loc = formatLocation(symbol.location);\n      const container = symbol.containerName ? ` (in ${symbol.containerName})` : '';\n      lines.push(`${prefix}${kind}: ${symbol.name}${container} [${loc}]`);\n    }\n  }\n\n  return lines.join('\\n');\n}\n\n/**\n * Format workspace symbols\n */\nexport function formatWorkspaceSymbols(symbols: SymbolInformation[] | null): string {\n  if (!symbols || symbols.length === 0) return 'No symbols found';\n\n  const lines = symbols.map(symbol => {\n    const kind = SYMBOL_KINDS[symbol.kind] || 'Unknown';\n    const loc = formatLocation(symbol.location);\n    const container = symbol.containerName ? ` (in ${symbol.containerName})` : '';\n    return `${kind}: ${symbol.name}${container}\\n  ${loc}`;\n  });\n\n  return lines.join('\\n\\n');\n}\n\n/**\n * Format diagnostics\n */\nexport function formatDiagnostics(diagnostics: Diagnostic[], filePath?: string): string {\n  if (diagnostics.length === 0) return 'No diagnostics';\n\n  const lines = diagnostics.map(diag => {\n    const severity = SEVERITY_NAMES[diag.severity || 1] || 'Unknown';\n    const range = formatRange(diag.range);\n    const source = diag.source ? `[${diag.source}]` : '';\n    const code = diag.code ? ` (${diag.code})` : '';\n    const location = filePath ? `${filePath}:${range}` : range;\n\n    return `${severity}${code}${source}: ${diag.message}\\n  at ${location}`;\n  });\n\n  return lines.join('\\n\\n');\n}\n\n/**\n * Format code actions\n */\nexport function formatCodeActions(actions: CodeAction[] | null): string {\n  if (!actions || actions.length === 0) return 'No code actions available';\n\n  const lines = actions.map((action, index) => {\n    const preferred = action.isPreferred ? ' (preferred)' : '';\n    const kind = action.kind ? ` [${action.kind}]` : '';\n    return `${index + 1}. ${action.title}${kind}${preferred}`;\n  });\n\n  return lines.join('\\n');\n}\n\n/**\n * Format workspace edit\n */\nexport function formatWorkspaceEdit(edit: WorkspaceEdit | null): string {\n  if (!edit) return 'No edits';\n\n  const lines: string[] = [];\n\n  if (edit.changes) {\n    for (const [uri, changes] of Object.entries(edit.changes)) {\n      const path = uriToPath(uri);\n      lines.push(`File: ${path}`);\n      for (const change of changes) {\n        const range = formatRange(change.range);\n        const preview = change.newText.length > 50\n          ? change.newText.slice(0, 50) + '...'\n          : change.newText;\n        lines.push(`  ${range}: \"${preview}\"`);\n      }\n    }\n  }\n\n  if (edit.documentChanges) {\n    for (const docChange of edit.documentChanges) {\n      const path = uriToPath(docChange.textDocument.uri);\n      lines.push(`File: ${path}`);\n      for (const change of docChange.edits) {\n        const range = formatRange(change.range);\n        const preview = change.newText.length > 50\n          ? change.newText.slice(0, 50) + '...'\n          : change.newText;\n        lines.push(`  ${range}: \"${preview}\"`);\n      }\n    }\n  }\n\n  return lines.length > 0 ? lines.join('\\n') : 'No edits';\n}\n\n/**\n * Count edits in a workspace edit\n */\nexport function countEdits(edit: WorkspaceEdit | null): { files: number; edits: number } {\n  if (!edit) return { files: 0, edits: 0 };\n\n  let files = 0;\n  let edits = 0;\n\n  if (edit.changes) {\n    files += Object.keys(edit.changes).length;\n    edits += Object.values(edit.changes).reduce((sum, changes) => sum + changes.length, 0);\n  }\n\n  if (edit.documentChanges) {\n    files += edit.documentChanges.length;\n    edits += edit.documentChanges.reduce((sum, doc) => sum + doc.edits.length, 0);\n  }\n\n  return { files, edits };\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\tools\\memory-tools.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\tools\\notepad-tools.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\tools\\python-repl\\__tests__\\bridge-manager-cleanup.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\tools\\python-repl\\bridge-manager.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":726,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":726,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22404,22407],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22404,22407],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-require-imports","severity":1,"message":"A `require()` style import is forbidden.","line":263,"column":7,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":263,"endColumn":31,"suppressions":[{"kind":"directive","justification":"inline one-off call, no top-level import needed"}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Bridge Manager - Python process lifecycle management\n *\n * Manages the gyoshu_bridge.py process:\n * - Spawning with proper environment detection\n * - Ensuring single bridge per session with security validations\n * - Graceful shutdown with signal escalation\n * - PID reuse detection via process identity verification\n */\n\nimport { spawn, ChildProcess } from 'child_process';\nimport * as fs from 'fs';\nimport * as fsPromises from 'fs/promises';\nimport * as path from 'path';\nimport { fileURLToPath } from 'url';\nimport { execFile } from 'child_process';\nimport { promisify } from 'util';\n\nimport { BridgeMeta, PythonEnvInfo } from './types.js';\nimport { getRuntimeDir, getSessionDir, getBridgeSocketPath, getBridgeMetaPath, getSessionLockPath } from './paths.js';\nimport { atomicWriteJson, safeReadJson, ensureDirSync } from '../../lib/atomic-write.js';\nimport { getProcessStartTime, isProcessAlive } from '../../platform/index.js';\n\nconst execFileAsync = promisify(execFile);\n\n// =============================================================================\n// CONSTANTS\n// =============================================================================\n\nconst BRIDGE_SPAWN_TIMEOUT_MS = 30000; // 30 seconds to wait for socket\nconst DEFAULT_GRACE_PERIOD_MS = 5000; // 5 seconds for SIGINT\nconst SIGTERM_GRACE_MS = 2500; // 2.5 seconds for SIGTERM\n\n// =============================================================================\n// TYPES\n// =============================================================================\n\nexport interface EscalationResult {\n  terminated: boolean;\n  terminatedBy?: 'SIGINT' | 'SIGTERM' | 'SIGKILL';\n  terminationTimeMs?: number;\n}\n\nexport interface BridgeSessionCleanupResult {\n  requestedSessions: number;\n  foundSessions: number;\n  terminatedSessions: number;\n  errors: string[];\n}\n\nexport interface StaleBridgeCleanupResult {\n  scannedSessions: number;\n  staleSessions: number;\n  activeSessions: number;\n  filesRemoved: number;\n  metaRemoved: number;\n  socketRemoved: number;\n  lockRemoved: number;\n  errors: string[];\n}\n\n// =============================================================================\n// BRIDGE PATH RESOLUTION\n// =============================================================================\n\n/**\n * Resolve the path to gyoshu_bridge.py relative to this module.\n * The bridge script is at: <package-root>/bridge/gyoshu_bridge.py\n *\n * Handles both ESM and CJS contexts (for bundled MCP server).\n */\nfunction getBridgeScriptPath(): string {\n  // Check for OMC_BRIDGE_SCRIPT environment variable first (set by MCP server context)\n  if (process.env.OMC_BRIDGE_SCRIPT) {\n    return process.env.OMC_BRIDGE_SCRIPT;\n  }\n\n  let moduleDir: string;\n\n  // Try ESM import.meta.url first\n  try {\n    if (import.meta.url) {\n      const __filename = fileURLToPath(import.meta.url);\n      moduleDir = path.dirname(__filename);\n    } else {\n      throw new Error('import.meta.url is empty');\n    }\n  } catch {\n    // Fallback for CJS context (bundled MCP server)\n    // In CJS bundle, __dirname points to the bundle's directory\n     \n    moduleDir = typeof __dirname !== 'undefined' ? __dirname : process.cwd();\n  }\n\n  // From src/tools/python-repl/ -> ../../.. -> package root -> bridge/\n  // Or from bridge/ (CJS bundle) -> bridge/\n  const packageRoot = path.resolve(moduleDir, '..', '..', '..');\n  const bridgePath = path.join(packageRoot, 'bridge', 'gyoshu_bridge.py');\n\n  // If that doesn't exist, try relative to moduleDir (for bundled CJS)\n  if (!fs.existsSync(bridgePath)) {\n    // In bundled CJS, moduleDir is the bridge/ directory itself\n    const bundledBridgePath = path.join(moduleDir, 'gyoshu_bridge.py');\n    if (fs.existsSync(bundledBridgePath)) {\n      return bundledBridgePath;\n    }\n  }\n\n  return bridgePath;\n}\n\n// =============================================================================\n// PYTHON ENVIRONMENT DETECTION\n// =============================================================================\n\n/**\n * Detect an existing Python virtual environment in the project directory.\n * Returns null if no .venv is found.\n */\nfunction detectExistingPythonEnv(projectRoot: string): PythonEnvInfo | null {\n  const isWindows = process.platform === 'win32';\n  const binDir = isWindows ? 'Scripts' : 'bin';\n  const pythonExe = isWindows ? 'python.exe' : 'python';\n  const venvPython = path.join(projectRoot, '.venv', binDir, pythonExe);\n\n  if (fs.existsSync(venvPython)) {\n    return { pythonPath: venvPython, type: 'venv' };\n  }\n  return null;\n}\n\n/**\n * Ensure a Python environment is available for the project.\n * Currently requires an existing .venv - does not auto-create.\n */\nasync function ensurePythonEnvironment(projectRoot: string): Promise<PythonEnvInfo> {\n  const existing = detectExistingPythonEnv(projectRoot);\n  if (existing) {\n    return existing;\n  }\n\n  // Fallback: try system python3\n  try {\n    await execFileAsync('python3', ['--version']);\n    return { pythonPath: 'python3', type: 'venv' };\n  } catch {\n    // python3 not available\n  }\n\n  throw new Error(\n    'No Python environment found. Create a virtual environment first:\\n' +\n      '  python -m venv .venv\\n' +\n      '  .venv/bin/pip install pandas numpy matplotlib'\n  );\n}\n\n// =============================================================================\n// PROCESS IDENTITY VERIFICATION\n// =============================================================================\n\n/**\n * Verify that a bridge process is still running and is the same process\n * that was originally spawned (guards against PID reuse).\n *\n * Returns false if:\n * - Process is not alive\n * - Start time was recorded but doesn't match (PID reused)\n * - Start time was recorded but cannot be retrieved (fail-closed)\n */\nexport async function verifyProcessIdentity(meta: BridgeMeta): Promise<boolean> {\n  // Basic alive check first\n  if (!isProcessAlive(meta.pid)) {\n    return false;\n  }\n\n  // If we have a recorded start time, verify it matches\n  if (meta.processStartTime !== undefined) {\n    const currentStartTime = await getProcessStartTime(meta.pid);\n\n    // Fail-closed: if we can't get current start time but we have a recorded one,\n    // assume PID reuse has occurred (safer than assuming same process)\n    if (currentStartTime === undefined) {\n      return false;\n    }\n\n    if (currentStartTime !== meta.processStartTime) {\n      return false; // PID reuse detected\n    }\n  }\n\n  return true;\n}\n\n// =============================================================================\n// SOCKET UTILITIES\n// =============================================================================\n\n/**\n * Check if a path points to a Unix socket.\n */\nfunction isSocket(socketPath: string): boolean {\n  try {\n    const stat = fs.lstatSync(socketPath);\n    return stat.isSocket();\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Safely unlink a socket file if it exists within the expected directory.\n */\nfunction safeUnlinkSocket(socketPath: string): void {\n  try {\n    if (fs.existsSync(socketPath)) {\n      fs.unlinkSync(socketPath);\n    }\n  } catch {\n    // Ignore errors\n  }\n}\n\n// =============================================================================\n// BRIDGE METADATA VALIDATION\n// =============================================================================\n\n/**\n * Validate that parsed JSON matches BridgeMeta schema.\n */\nfunction isValidBridgeMeta(data: unknown): data is BridgeMeta {\n  if (typeof data !== 'object' || data === null) return false;\n  const obj = data as Record<string, unknown>;\n\n  return (\n    typeof obj.pid === 'number' &&\n    Number.isInteger(obj.pid) &&\n    obj.pid > 0 &&\n    typeof obj.socketPath === 'string' &&\n    typeof obj.startedAt === 'string' &&\n    typeof obj.sessionId === 'string' &&\n    typeof obj.pythonEnv === 'object' &&\n    obj.pythonEnv !== null &&\n    typeof (obj.pythonEnv as Record<string, unknown>).pythonPath === 'string' &&\n    (obj.processStartTime === undefined || typeof obj.processStartTime === 'number')\n  );\n}\n\n// =============================================================================\n// PROCESS GROUP MANAGEMENT\n// =============================================================================\n\n/**\n * Kill a process group (process + children).\n * Cross-platform: Uses taskkill /T on Windows, negative PID on Unix.\n */\nfunction killProcessGroup(pid: number, signal: NodeJS.Signals): boolean {\n  if (process.platform === 'win32') {\n    // On Windows, use taskkill with /T for tree kill\n    try {\n      const force = signal === 'SIGKILL';\n      const args = force ? '/F /T' : '/T';\n      // eslint-disable-next-line @typescript-eslint/no-require-imports -- inline one-off call, no top-level import needed\n      require('child_process').execSync(\n        `taskkill ${args} /PID ${pid}`,\n        { stdio: 'ignore', timeout: 5000, windowsHide: true }\n      );\n      return true;\n    } catch {\n      return false;\n    }\n  } else {\n    // Unix: use negative PID for process group\n    try {\n      process.kill(-pid, signal);\n      return true;\n    } catch {\n      try {\n        process.kill(pid, signal);\n        return true;\n      } catch {\n        return false;\n      }\n    }\n  }\n}\n\n// =============================================================================\n// SPAWN BRIDGE SERVER\n// =============================================================================\n\n/**\n * Spawn a new bridge server process for the given session.\n *\n * @param sessionId - Unique session identifier\n * @param projectDir - Optional project directory (defaults to cwd)\n * @returns BridgeMeta containing process information\n */\nexport async function spawnBridgeServer(\n  sessionId: string,\n  projectDir?: string\n): Promise<BridgeMeta> {\n  const sessionDir = getSessionDir(sessionId);\n  ensureDirSync(sessionDir);\n\n  const socketPath = getBridgeSocketPath(sessionId);\n  const bridgePath = getBridgeScriptPath();\n\n  // Verify bridge script exists\n  if (!fs.existsSync(bridgePath)) {\n    throw new Error(`Bridge script not found: ${bridgePath}`);\n  }\n\n  // Clean up any stale socket\n  safeUnlinkSocket(socketPath);\n\n  const effectiveProjectDir = projectDir || process.cwd();\n  const pythonEnv = await ensurePythonEnvironment(effectiveProjectDir);\n\n  // Pass socket path as positional argument (matches gyoshu_bridge.py argparse)\n  const bridgeArgs = [bridgePath, socketPath];\n\n  const proc: ChildProcess = spawn(pythonEnv.pythonPath, bridgeArgs, {\n    stdio: ['ignore', 'ignore', 'pipe'],\n    cwd: effectiveProjectDir,\n    env: { ...process.env, PYTHONUNBUFFERED: '1' },\n    detached: true,\n  });\n\n  proc.unref();\n\n  // Capture stderr for error reporting (capped at 64KB)\n  const MAX_STDERR_CHARS = 64 * 1024;\n  let stderrBuffer = '';\n  let stderrTruncated = false;\n\n  proc.stderr?.on('data', (chunk: Buffer) => {\n    if (stderrTruncated) return;\n    const text = chunk.toString();\n    if (stderrBuffer.length + text.length > MAX_STDERR_CHARS) {\n      stderrBuffer = stderrBuffer.slice(0, MAX_STDERR_CHARS - 20) + '\\n...[truncated]';\n      stderrTruncated = true;\n    } else {\n      stderrBuffer += text;\n    }\n  });\n\n  // Wait for socket to appear\n  const startTime = Date.now();\n  while (!isSocket(socketPath)) {\n    if (Date.now() - startTime > BRIDGE_SPAWN_TIMEOUT_MS) {\n      // Kill the process on timeout\n      if (proc.pid) {\n        killProcessGroup(proc.pid, 'SIGKILL');\n      }\n\n      // Clean up any non-socket file that might exist (poisoning attempt)\n      if (fs.existsSync(socketPath) && !isSocket(socketPath)) {\n        safeUnlinkSocket(socketPath);\n      }\n\n      throw new Error(\n        `Bridge failed to create socket in ${BRIDGE_SPAWN_TIMEOUT_MS}ms. ` +\n          `Stderr: ${stderrBuffer || '(empty)'}`\n      );\n    }\n    await sleep(100);\n  }\n\n  // Get process start time for PID reuse detection\n  const processStartTime = proc.pid ? await getProcessStartTime(proc.pid) : undefined;\n\n  const meta: BridgeMeta = {\n    pid: proc.pid!,\n    socketPath,\n    startedAt: new Date().toISOString(),\n    sessionId,\n    pythonEnv,\n    processStartTime,\n  };\n\n  // Persist metadata\n  const metaPath = getBridgeMetaPath(sessionId);\n  await atomicWriteJson(metaPath, meta);\n\n  return meta;\n}\n\n// =============================================================================\n// ENSURE BRIDGE\n// =============================================================================\n\n/**\n * Get or spawn a bridge server for the session.\n *\n * Implements security validations:\n * - Anti-poisoning: Verifies sessionId in metadata matches expected\n * - Anti-hijack: Verifies socketPath is the expected canonical path\n * - Socket type: Verifies the socket path is actually a socket\n * - Process identity: Verifies PID + start time match\n *\n * @param sessionId - Unique session identifier\n * @param projectDir - Optional project directory (defaults to cwd)\n * @returns BridgeMeta for the active bridge\n */\nexport async function ensureBridge(sessionId: string, projectDir?: string): Promise<BridgeMeta> {\n  const metaPath = getBridgeMetaPath(sessionId);\n  const expectedSocketPath = getBridgeSocketPath(sessionId);\n\n  const meta = await safeReadJson<BridgeMeta>(metaPath);\n\n  if (meta && isValidBridgeMeta(meta)) {\n    // Security validation 1: Anti-poisoning - verify sessionId matches\n    if (meta.sessionId !== sessionId) {\n      await deleteBridgeMeta(sessionId);\n      return spawnBridgeServer(sessionId, projectDir);\n    }\n\n    // Security validation 2: Anti-hijack - verify socket path is expected\n    if (meta.socketPath !== expectedSocketPath) {\n      await deleteBridgeMeta(sessionId);\n      return spawnBridgeServer(sessionId, projectDir);\n    }\n\n    // Security validation 3: Process identity - verify PID is still our process\n    const stillOurs = await verifyProcessIdentity(meta);\n    if (stillOurs) {\n      // Security validation 4: Socket type - verify it's actually a socket\n      if (isSocket(meta.socketPath)) {\n        return meta;\n      } else {\n        // Socket missing or wrong type - kill the orphan process\n        try {\n          process.kill(meta.pid, 'SIGKILL');\n        } catch {\n          // Process might already be dead\n        }\n      }\n    }\n\n    await deleteBridgeMeta(sessionId);\n  }\n\n  return spawnBridgeServer(sessionId, projectDir);\n}\n\n// =============================================================================\n// KILL BRIDGE WITH ESCALATION\n// =============================================================================\n\n/**\n * Terminate a bridge process with signal escalation.\n *\n * Escalation order:\n * 1. SIGINT - wait gracePeriodMs (default 5000ms)\n * 2. SIGTERM - wait 2500ms\n * 3. SIGKILL - immediate termination\n *\n * Uses process group kill (-pid) to also terminate child processes.\n *\n * @param sessionId - Session whose bridge to kill\n * @param options - Optional configuration\n * @returns EscalationResult with termination details\n */\nexport async function killBridgeWithEscalation(\n  sessionId: string,\n  options?: { gracePeriodMs?: number }\n): Promise<EscalationResult> {\n  const gracePeriod = options?.gracePeriodMs ?? DEFAULT_GRACE_PERIOD_MS;\n  const startTime = Date.now();\n\n  const metaPath = getBridgeMetaPath(sessionId);\n  const meta = await safeReadJson<BridgeMeta>(metaPath);\n\n  if (!meta || !isValidBridgeMeta(meta)) {\n    return { terminated: true }; // Already dead or no metadata\n  }\n\n  // Anti-poisoning check\n  if (meta.sessionId !== sessionId) {\n    await deleteBridgeMeta(sessionId);\n    return { terminated: true };\n  }\n\n  // Verify we're killing the right process\n  if (!(await verifyProcessIdentity(meta))) {\n    await deleteBridgeMeta(sessionId);\n    return { terminated: true }; // Process already dead or PID reused\n  }\n\n  // Helper to wait for process exit with identity verification\n  const waitForExit = async (timeoutMs: number): Promise<boolean> => {\n    const checkStart = Date.now();\n    while (Date.now() - checkStart < timeoutMs) {\n      const stillOurs = await verifyProcessIdentity(meta);\n      if (!stillOurs) {\n        return true; // Process is gone or PID reused\n      }\n      await sleep(100);\n    }\n    return false;\n  };\n\n  let terminatedBy: 'SIGINT' | 'SIGTERM' | 'SIGKILL' = 'SIGINT';\n\n  // Stage 1: SIGINT\n  killProcessGroup(meta.pid, 'SIGINT');\n\n  if (!(await waitForExit(gracePeriod))) {\n    // Stage 2: SIGTERM\n    terminatedBy = 'SIGTERM';\n    killProcessGroup(meta.pid, 'SIGTERM');\n\n    if (!(await waitForExit(SIGTERM_GRACE_MS))) {\n      // Stage 3: SIGKILL\n      terminatedBy = 'SIGKILL';\n      killProcessGroup(meta.pid, 'SIGKILL');\n      await waitForExit(1000); // Brief wait for SIGKILL\n    }\n  }\n\n  // Cleanup\n  await deleteBridgeMeta(sessionId);\n\n  const sessionDir = getSessionDir(sessionId);\n  const socketPath = meta.socketPath;\n  if (socketPath.startsWith(sessionDir)) {\n    safeUnlinkSocket(socketPath);\n  }\n\n  return {\n    terminated: true,\n    terminatedBy,\n    terminationTimeMs: Date.now() - startTime,\n  };\n}\n\n/**\n * Clean up bridge processes for explicit session IDs.\n * Used by session-end to terminate bridges created during the ending session.\n */\nexport async function cleanupBridgeSessions(\n  sessionIds: Iterable<string>\n): Promise<BridgeSessionCleanupResult> {\n  const uniqueSessionIds = [...new Set(Array.from(sessionIds).filter(Boolean))];\n\n  const result: BridgeSessionCleanupResult = {\n    requestedSessions: uniqueSessionIds.length,\n    foundSessions: 0,\n    terminatedSessions: 0,\n    errors: [],\n  };\n\n  for (const sessionId of uniqueSessionIds) {\n    try {\n      const metaPath = getBridgeMetaPath(sessionId);\n      const socketPath = getBridgeSocketPath(sessionId);\n      const lockPath = getSessionLockPath(sessionId);\n      const hasArtifacts =\n        fs.existsSync(metaPath) || fs.existsSync(socketPath) || fs.existsSync(lockPath);\n\n      if (!hasArtifacts) {\n        continue;\n      }\n\n      result.foundSessions++;\n\n      const meta = await safeReadJson<BridgeMeta>(metaPath);\n      if (meta && isValidBridgeMeta(meta)) {\n        const escalation = await killBridgeWithEscalation(sessionId);\n        if (escalation.terminatedBy) {\n          result.terminatedSessions++;\n        }\n      } else {\n        await removeFileIfExists(metaPath);\n        await removeFileIfExists(socketPath);\n      }\n\n      // Lock files can linger after abnormal exits; always best-effort cleanup.\n      await removeFileIfExists(lockPath);\n    } catch (error) {\n      result.errors.push(`session=${sessionId}: ${(error as Error).message}`);\n    }\n  }\n\n  return result;\n}\n\n/**\n * Clean up stale bridge artifacts across all runtime sessions.\n * \"Stale\" means metadata is invalid OR process is no longer alive.\n */\nexport async function cleanupStaleBridges(): Promise<StaleBridgeCleanupResult> {\n  const result: StaleBridgeCleanupResult = {\n    scannedSessions: 0,\n    staleSessions: 0,\n    activeSessions: 0,\n    filesRemoved: 0,\n    metaRemoved: 0,\n    socketRemoved: 0,\n    lockRemoved: 0,\n    errors: [],\n  };\n\n  const runtimeDir = getRuntimeDir();\n  if (!fs.existsSync(runtimeDir)) {\n    return result;\n  }\n\n  let entries: fs.Dirent[];\n  try {\n    entries = await fsPromises.readdir(runtimeDir, { withFileTypes: true });\n  } catch (error) {\n    result.errors.push(`runtimeDir=${runtimeDir}: ${(error as Error).message}`);\n    return result;\n  }\n\n  for (const entry of entries) {\n    if (!entry.isDirectory()) {\n      continue;\n    }\n\n    const sessionDir = path.join(runtimeDir, entry.name);\n    const metaPath = path.join(sessionDir, 'bridge_meta.json');\n    const socketPath = path.join(sessionDir, 'bridge.sock');\n    const lockPath = path.join(sessionDir, 'session.lock');\n    const hasArtifacts =\n      fs.existsSync(metaPath) || fs.existsSync(socketPath) || fs.existsSync(lockPath);\n\n    if (!hasArtifacts) {\n      continue;\n    }\n\n    result.scannedSessions++;\n\n    try {\n      // No metadata means we cannot verify ownership/process identity; treat as stale artifacts.\n      if (!fs.existsSync(metaPath)) {\n        result.staleSessions++;\n        const socketRemoved = await removeFileIfExists(socketPath);\n        const lockRemoved = await removeFileIfExists(lockPath);\n        if (socketRemoved) {\n          result.socketRemoved++;\n          result.filesRemoved++;\n        }\n        if (lockRemoved) {\n          result.lockRemoved++;\n          result.filesRemoved++;\n        }\n        continue;\n      }\n\n      const meta = await safeReadJson<BridgeMeta>(metaPath);\n      if (!meta || !isValidBridgeMeta(meta)) {\n        result.staleSessions++;\n        const metaRemoved = await removeFileIfExists(metaPath);\n        const socketRemoved = await removeFileIfExists(socketPath);\n        const lockRemoved = await removeFileIfExists(lockPath);\n        if (metaRemoved) {\n          result.metaRemoved++;\n          result.filesRemoved++;\n        }\n        if (socketRemoved) {\n          result.socketRemoved++;\n          result.filesRemoved++;\n        }\n        if (lockRemoved) {\n          result.lockRemoved++;\n          result.filesRemoved++;\n        }\n        continue;\n      }\n\n      const alive = await verifyProcessIdentity(meta);\n      if (alive) {\n        result.activeSessions++;\n        continue;\n      }\n\n      result.staleSessions++;\n      const metaRemoved = await removeFileIfExists(metaPath);\n      const socketRemoved = await removeFileIfExists(socketPath);\n      const lockRemoved = await removeFileIfExists(lockPath);\n      if (metaRemoved) {\n        result.metaRemoved++;\n        result.filesRemoved++;\n      }\n      if (socketRemoved) {\n        result.socketRemoved++;\n        result.filesRemoved++;\n      }\n      if (lockRemoved) {\n        result.lockRemoved++;\n        result.filesRemoved++;\n      }\n    } catch (error) {\n      result.errors.push(`sessionDir=${sessionDir}: ${(error as Error).message}`);\n    }\n  }\n\n  return result;\n}\n\n// =============================================================================\n// HELPER FUNCTIONS\n// =============================================================================\n\n/**\n * Delete bridge metadata file.\n */\nasync function deleteBridgeMeta(sessionId: string): Promise<void> {\n  const metaPath = getBridgeMetaPath(sessionId);\n  try {\n    await fsPromises.unlink(metaPath);\n  } catch {\n    // Ignore errors (file might not exist)\n  }\n}\n\n/**\n * Remove a file if it exists. Returns true when a file was removed.\n */\nasync function removeFileIfExists(filePath: string): Promise<boolean> {\n  try {\n    await fsPromises.unlink(filePath);\n    return true;\n  } catch (error: any) {\n    if (error?.code === 'ENOENT') {\n      return false;\n    }\n    throw error;\n  }\n}\n\n/**\n * Sleep for specified milliseconds.\n */\nfunction sleep(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\tools\\python-repl\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\tools\\python-repl\\paths.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\tools\\python-repl\\session-lock.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":190,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":190,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6403,6406],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6403,6406],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":209,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":209,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6919,6922],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6919,6922],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":392,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":392,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11972,11975],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11972,11975],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":419,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":419,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12675,12678],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12675,12678],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":459,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":459,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13614,13617],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13614,13617],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Session Lock - Cross-platform file-based session locking\n *\n * Provides single-writer enforcement per session with:\n * - PID-reuse safety via process start time verification\n * - Cross-platform support (Linux, macOS, Windows)\n * - Stale lock detection and safe breaking\n * - Request queuing with timeout\n */\n\nimport * as fs from 'fs/promises';\nimport * as fsSync from 'fs';\nimport * as path from 'path';\nimport * as os from 'os';\nimport * as crypto from 'crypto';\nimport { execFile } from 'child_process';\nimport { promisify } from 'util';\nimport { LockInfo } from './types.js';\nimport { ensureDirSync } from '../../lib/atomic-write.js';\nimport { getSessionLockPath } from './paths.js';\nimport { getProcessStartTime } from '../../platform/index.js';\n\nconst execFileAsync = promisify(execFile);\n\n// =============================================================================\n// CONSTANTS\n// =============================================================================\n\nconst STALE_LOCK_AGE_MS = 60000; // 60 seconds\nconst DEFAULT_ACQUIRE_TIMEOUT_MS = 30000; // 30 seconds\nconst LOCK_RETRY_INTERVAL_MS = 100; // 100ms between retries\nconst REMOTE_LOCK_STALE_AGE_MS = 300000; // 5 minutes for remote locks\n\n// =============================================================================\n// ERRORS\n// =============================================================================\n\nexport class LockTimeoutError extends Error {\n  constructor(\n    public readonly lockPath: string,\n    public readonly timeout: number,\n    public readonly lastHolder?: LockInfo\n  ) {\n    super(\n      `Failed to acquire lock within ${timeout}ms. ` +\n        (lastHolder\n          ? `Held by PID ${lastHolder.pid} on ${lastHolder.hostname} since ${lastHolder.acquiredAt}`\n          : 'Unknown holder') +\n        `. Lock path: ${lockPath}`\n    );\n    this.name = 'LockTimeoutError';\n  }\n}\n\nexport class LockError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'LockError';\n  }\n}\n\n// =============================================================================\n// LOCK RESULT TYPE\n// =============================================================================\n\nexport interface LockResult {\n  acquired: boolean;\n  reason?: 'success' | 'held_by_other' | 'stale_broken' | 'error';\n  holder?: LockInfo;\n}\n\n// =============================================================================\n// PID VALIDATION\n// =============================================================================\n\n/**\n * Validate that a PID is a positive integer.\n * Defense in depth against command injection via poisoned lock files.\n */\nfunction isValidPid(pid: unknown): pid is number {\n  return typeof pid === 'number' && Number.isInteger(pid) && pid > 0;\n}\n\n// =============================================================================\n// PROCESS START TIME DETECTION\n// =============================================================================\n\n/**\n * Get the start time of the current process.\n * Used when creating lock files to enable PID reuse detection.\n */\nexport async function getCurrentProcessStartTime(): Promise<number | undefined> {\n  return getProcessStartTime(process.pid);\n}\n\n// =============================================================================\n// PROCESS LIVENESS DETECTION\n// =============================================================================\n\n/**\n * Check if a process is alive with PID-reuse detection via start time comparison.\n *\n * @param pid - Process ID to check\n * @param recordedStartTime - Start time recorded when lock was acquired\n * @returns true if process is alive AND start time matches (or wasn't recorded)\n */\nexport async function isProcessAlive(pid: number, recordedStartTime?: number): Promise<boolean> {\n  if (!isValidPid(pid)) return false;\n\n  if (process.platform === 'linux') {\n    const currentStartTime = await getProcessStartTime(pid);\n    if (currentStartTime === undefined) return false;\n\n    // If we have a recorded start time, verify it matches\n    if (recordedStartTime !== undefined && currentStartTime !== recordedStartTime) {\n      return false; // PID reuse detected\n    }\n\n    return true;\n  } else if (process.platform === 'darwin') {\n    try {\n      // First check if process exists\n      const { stdout } = await execFileAsync('ps', ['-p', String(pid), '-o', 'pid='], {\n        env: { ...process.env, LC_ALL: 'C' },\n      });\n      if (stdout.trim() === '') return false;\n\n      // If we have a recorded start time, verify it matches\n      if (recordedStartTime !== undefined) {\n        const currentStartTime = await getProcessStartTime(pid);\n        // Fail-closed: if we can't get current start time but we have a recorded one,\n        // assume PID reuse has occurred (safer than assuming same process)\n        if (currentStartTime === undefined) {\n          return false;\n        }\n        if (currentStartTime !== recordedStartTime) {\n          return false; // PID reuse detected\n        }\n      }\n\n      return true;\n    } catch {\n      return false;\n    }\n  } else if (process.platform === 'win32') {\n    // On Windows, check if process exists and optionally verify start time\n    try {\n      process.kill(pid, 0);\n\n      if (recordedStartTime !== undefined) {\n        const currentStartTime = await getProcessStartTime(pid);\n        if (currentStartTime === undefined) {\n          return false;\n        }\n        if (currentStartTime !== recordedStartTime) {\n          return false;\n        }\n      }\n\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  // Unknown platform: conservative assumption that process is alive\n  return true;\n}\n\n// =============================================================================\n// SYMLINK-SAFE FILE OPERATIONS\n// =============================================================================\n\n/**\n * Open a file with O_NOFOLLOW to prevent symlink attacks.\n * Falls back to lstat check on platforms that don't support O_NOFOLLOW.\n */\nasync function openNoFollow(\n  filePath: string,\n  flags: number,\n  mode: number\n): Promise<fs.FileHandle> {\n  // Add O_NOFOLLOW if available (Linux, macOS)\n  // O_NOFOLLOW doesn't exist on Windows. Use 0 to disable the flag.\n  const O_NOFOLLOW = fsSync.constants.O_NOFOLLOW ?? 0;\n  const flagsWithNoFollow = flags | O_NOFOLLOW;\n\n  try {\n    return await fs.open(filePath, flagsWithNoFollow, mode);\n  } catch (err: any) {\n    // ELOOP means it's a symlink - reject it\n    if (err.code === 'ELOOP') {\n      throw new LockError(`Lock file is a symlink: ${filePath}`);\n    }\n    throw err;\n  }\n}\n\n/**\n * Read a file safely, rejecting symlinks.\n */\nasync function readFileNoFollow(filePath: string): Promise<string> {\n  // First check if it's a symlink via lstat\n  try {\n    const stat = await fs.lstat(filePath);\n    if (stat.isSymbolicLink()) {\n      throw new LockError(`Lock file is a symlink: ${filePath}`);\n    }\n  } catch (err: any) {\n    if (err.code === 'ENOENT') {\n      throw err; // File doesn't exist - propagate\n    }\n    if (err instanceof LockError) {\n      throw err;\n    }\n    // Other errors - let readFile handle them\n  }\n\n  return fs.readFile(filePath, 'utf8');\n}\n\n// =============================================================================\n// LOCK FILE OPERATIONS\n// =============================================================================\n\n/**\n * Read and validate a lock file.\n * Returns null if file doesn't exist, is invalid, or is a symlink.\n */\nasync function readLockFile(lockPath: string): Promise<LockInfo | null> {\n  try {\n    const content = await readFileNoFollow(lockPath);\n    const lockInfo = JSON.parse(content) as LockInfo;\n\n    // Validate required fields\n    if (\n      !lockInfo.lockId ||\n      !isValidPid(lockInfo.pid) ||\n      !lockInfo.hostname ||\n      !lockInfo.acquiredAt\n    ) {\n      return null;\n    }\n\n    return lockInfo;\n  } catch {\n    // ENOENT = doesn't exist, ELOOP = symlink rejected, or parse error\n    return null;\n  }\n}\n\n/**\n * Create a new LockInfo for the current process.\n */\nasync function createLockInfo(lockId: string): Promise<LockInfo> {\n  return {\n    lockId,\n    pid: process.pid,\n    processStartTime: await getCurrentProcessStartTime(),\n    hostname: os.hostname(),\n    acquiredAt: new Date().toISOString(),\n  };\n}\n\n/**\n * Check if a lock can be safely broken. A lock is breakable if:\n * - Age > 60 seconds AND owning process is dead OR start time differs (PID reuse)\n * - For remote hosts: Only breaks if age > 5 minutes\n */\nasync function canBreakLock(lockInfo: LockInfo): Promise<boolean> {\n  const age = Date.now() - new Date(lockInfo.acquiredAt).getTime();\n\n  // Lock is too fresh to break\n  if (age < STALE_LOCK_AGE_MS) {\n    return false;\n  }\n\n  // For remote hosts, require much longer timeout\n  if (lockInfo.hostname !== os.hostname()) {\n    return age > REMOTE_LOCK_STALE_AGE_MS;\n  }\n\n  // Check if owning process is still alive with same start time\n  const alive = await isProcessAlive(lockInfo.pid, lockInfo.processStartTime);\n\n  return !alive;\n}\n\n// =============================================================================\n// SESSION LOCK CLASS\n// =============================================================================\n\n/**\n * SessionLock manages a single lock file for session coordination.\n *\n * @example\n * const lock = new SessionLock('my-session-id');\n * try {\n *   await lock.acquire();\n *   // ... do work ...\n * } finally {\n *   await lock.release();\n * }\n */\nexport class SessionLock {\n  private lockPath: string;\n  private lockId: string;\n  private held: boolean = false;\n  private lockInfo: LockInfo | null = null;\n\n  constructor(sessionId: string) {\n    this.lockPath = getSessionLockPath(sessionId);\n    this.lockId = crypto.randomUUID();\n  }\n\n  /**\n   * Acquire lock with timeout (default 30s).\n   * Blocks until lock is acquired or timeout is reached.\n   *\n   * @param timeout - Maximum time to wait in milliseconds\n   * @throws LockTimeoutError if lock cannot be acquired within timeout\n   */\n  async acquire(timeout: number = DEFAULT_ACQUIRE_TIMEOUT_MS): Promise<void> {\n    if (this.held) {\n      throw new LockError('Lock already held by this instance');\n    }\n\n    const startTime = Date.now();\n    let lastHolder: LockInfo | undefined;\n\n    while (Date.now() - startTime < timeout) {\n      const result = await this.tryAcquire();\n\n      if (result.acquired) {\n        return;\n      }\n\n      if (result.holder) {\n        lastHolder = result.holder;\n      }\n\n      await sleep(LOCK_RETRY_INTERVAL_MS);\n    }\n\n    throw new LockTimeoutError(this.lockPath, timeout, lastHolder);\n  }\n\n  /**\n   * Try to acquire lock (non-blocking).\n   * Returns immediately with result indicating success or failure.\n   */\n  async tryAcquire(): Promise<LockResult> {\n    try {\n      const existingLock = await readLockFile(this.lockPath);\n\n      if (existingLock) {\n        // Check if we can break the stale lock\n        if (await canBreakLock(existingLock)) {\n          try {\n            await fs.unlink(this.lockPath);\n          } catch {\n            // Lock might have been removed by another process\n          }\n          // Fall through to acquire\n        } else {\n          return {\n            acquired: false,\n            reason: 'held_by_other',\n            holder: existingLock,\n          };\n        }\n      }\n\n      // Create new lock info\n      const newLockInfo = await createLockInfo(this.lockId);\n\n      try {\n        // Ensure directory exists\n        ensureDirSync(path.dirname(this.lockPath));\n\n        // Atomic exclusive create with O_NOFOLLOW\n        const flags =\n          fsSync.constants.O_WRONLY | fsSync.constants.O_CREAT | fsSync.constants.O_EXCL;\n\n        const lockFile = await openNoFollow(this.lockPath, flags, 0o644);\n        try {\n          await lockFile.writeFile(JSON.stringify(newLockInfo, null, 2), { encoding: 'utf8' });\n          await lockFile.sync();\n        } finally {\n          await lockFile.close();\n        }\n      } catch (err: any) {\n        if (err.code === 'EEXIST') {\n          // Another process created the lock file first\n          return {\n            acquired: false,\n            reason: 'held_by_other',\n          };\n        }\n        throw err;\n      }\n\n      // Verify our lock wasn't overwritten (race condition check)\n      const verifyLock = await readLockFile(this.lockPath);\n      if (!verifyLock || verifyLock.lockId !== this.lockId) {\n        return {\n          acquired: false,\n          reason: 'error',\n        };\n      }\n\n      this.held = true;\n      this.lockInfo = newLockInfo;\n\n      return {\n        acquired: true,\n        reason: existingLock ? 'stale_broken' : 'success',\n      };\n    } catch (_err: any) {\n      return {\n        acquired: false,\n        reason: 'error',\n      };\n    }\n  }\n\n  /**\n   * Release held lock.\n   * Safe to call multiple times - subsequent calls are no-ops.\n   */\n  async release(): Promise<void> {\n    if (!this.held) {\n      return;\n    }\n\n    try {\n      // Verify we still own the lock before deleting\n      const currentLock = await readLockFile(this.lockPath);\n\n      if (currentLock && currentLock.lockId === this.lockId) {\n        await fs.unlink(this.lockPath);\n      }\n    } catch {\n      // Ignore errors (lock might already be gone)\n    } finally {\n      this.held = false;\n      this.lockInfo = null;\n    }\n  }\n\n  /**\n   * Force break a stale lock.\n   * USE WITH CAUTION: This will break the lock regardless of who holds it.\n   * Should only be used for recovery from known stale states.\n   */\n  async forceBreak(): Promise<void> {\n    try {\n      await fs.unlink(this.lockPath);\n    } catch (err: any) {\n      if (err.code !== 'ENOENT') {\n        throw err;\n      }\n    }\n    this.held = false;\n    this.lockInfo = null;\n  }\n\n  /**\n   * Check if lock is held by us.\n   */\n  isHeld(): boolean {\n    return this.held;\n  }\n\n  /**\n   * Get the lock file path.\n   */\n  getLockPath(): string {\n    return this.lockPath;\n  }\n\n  /**\n   * Get current lock info (if held).\n   */\n  getLockInfo(): LockInfo | null {\n    return this.lockInfo;\n  }\n}\n\n// =============================================================================\n// UTILITY FUNCTIONS\n// =============================================================================\n\nfunction sleep(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\n/**\n * Execute a function while holding a lock, releasing automatically on completion.\n *\n * @example\n * await withLock('session-id', async () => {\n *   // ... critical section ...\n * });\n */\nexport async function withLock<T>(\n  sessionId: string,\n  fn: () => Promise<T>,\n  timeout: number = DEFAULT_ACQUIRE_TIMEOUT_MS\n): Promise<T> {\n  const lock = new SessionLock(sessionId);\n  await lock.acquire(timeout);\n  try {\n    return await fn();\n  } finally {\n    await lock.release();\n  }\n}\n\n/**\n * Get the current status of a session lock.\n */\nexport async function getLockStatus(sessionId: string): Promise<{\n  locked: boolean;\n  lockInfo: LockInfo | null;\n  canBreak: boolean;\n  ownedByUs: boolean;\n}> {\n  const lockPath = getSessionLockPath(sessionId);\n  const lockInfo = await readLockFile(lockPath);\n\n  if (!lockInfo) {\n    return {\n      locked: false,\n      lockInfo: null,\n      canBreak: false,\n      ownedByUs: false,\n    };\n  }\n\n  const canBreakResult = await canBreakLock(lockInfo);\n  const ownedByUs = lockInfo.pid === process.pid && lockInfo.hostname === os.hostname();\n\n  return {\n    locked: true,\n    lockInfo,\n    canBreak: canBreakResult,\n    ownedByUs,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\tools\\python-repl\\socket-client.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\tools\\python-repl\\tool.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\tools\\python-repl\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\tools\\resume-session.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\tools\\skills-tools.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\tools\\state-tools.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\tools\\trace-tools.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\tools\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\utils\\__tests__\\paths.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\utils\\__tests__\\string-width.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\utils\\config-dir.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\utils\\paths.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\utils\\string-width.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\verification\\tier-selector.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ljyih\\Desktop\\ultrapower\\src\\verification\\tier-selector.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
